# 11.2 使用非受限联合类型

为了让联合类型更加实用，在C++11标准中解除了大部分限制，联合类型的成员可以是除了引用类型外的所有类型。不过这样的修改引入了另外一个问题，如何精确初始化联合类型成员对象。这一点在过去的联合类型中不是一个问题，因为对于平凡类型，编译器只需要对成员对象都执行编译器提供的默认构造即可，虽然从同一内存多次初始化的角度来说这是不正确的，但是从结果上看没有任何问题。现在情况发生了变化，由于允许非平凡类型的存在，对所有成员一一进行默认构造明显是不可取的，因此我们需要有选择地初始化成员对象。实际上，让编译器去选择初始化本身也是不合适的，这个事情应该交给程序员来做。基于这些考虑，在C++11中如果有联合类型中存

在非平凡类型，那么这个联合类型的特殊成员函数将被隐式删除，也就是说我们必须自己至少提供联合类型的构造和析构函数，比如：

```c
include<iostream>   
#include<string>   
#include<vector>   
union U   
{ U（）{} //存在非平凡类型成员，必须提供构造函数 \~U（）{} //存在非平凡类型成员，必须提供析构函数 intx1; float x2; std::stringx3; std::vector<int>x4;   
}；   
int main()   
{ Uu; u.x3  $=$  "hello world"; std::cout<<u.x3;
```

在上面的代码中，由于x3和x4的类型std::string和std::vector是非平凡类型，因此u必须提供构造和析构函数。虽然这里提供的构造和析构函数什么也没有做，但是代码依然可以成功编译。不过请注意，能够编译通过并不代表没有问题，实际上这段代码会运行出错，因为非平凡类型x3并没有被构造，所以在赋值操作的时候必然会出错。现在修改一下代码：

```txt
include<iostream> #include<string>#include <vector> unionU { U() :x3（）{} \~U（）{x3..basic_string();}
```

```cpp
int x1; float x2; std::string x3; std::vector<int> x4;   
}; int main() { U u; u.x3  $=$  "hello world"; std::cout<<u.x3;
```

在上面的代码中，我们对联合类型U的构造和析构函数进行了修改。其中在构造函数中添加了初始化列表来构造x3，在析构函数中手动调用了x3的析构函数。前者很容易理解，而后者需要注意，联合类型在析构的时候编译器并不知道当前激活的是哪个成员，所以无法自动调用成员的析构函数，必须由程序员编写代码完成这部分工作。现在联合类型U的成员对象x3可以正常工作了，但是这种解决方案依然存在问题，因为在编写联合类型构造函数的时候无法确保哪个成员真正被使用。具体来说，如果在main函数内使用U的成员x4，由于x4并没有经过初始化，因此会导致程序出错：

```cpp
include<iostream>   
#include<string>   
#include<vector>   
union U { U() : x3(){ } ~U（）{x3..basic_string();} int x1; float x2; std::string x3; std::vector<int> x4;   
};   
int main()   
{
```

```txt
U u; u.x4.push_back(58); }
```

基于这些考虑，我还是比较推荐让联合类型的构造和析构函数为空，也就是什么也不做，并且将其成员的构造和析构函数放在需要使用联合类型的地方。让我们继续修改上面的代码：

```cpp
include<iostream>   
#include<string>   
#include<vector>   
union U   
{ U（）{} ~U（）{} int x1; floatx2; std::stringx3; std::vector<int>x4;   
}；   
int main()   
{ Uu; new(&u.x3)std::string("hello world"); std::cout<<u.x3<<std::endl; u.x3.~basic_string(); new(&u.x4)std::vector<int>; u.x4.push_back(58); std::cout<<u.x4[0]<<std::endl; u.x4.~vector();   
}
```

请注意，上面的代码用了placement new的技巧来初始化构造x3和x4对象，在使用完对象后手动调用对象的析构函数。通过这样的方法保证了联合类型使用的灵活性和正确性。

最后简单介绍一下非受限联合类型对静态成员变量的支持。联合类型的静态成员不属于联合类型的任何对象，所以并不是对象构造时被定义的，不能在联合类型内部初始化。实际上这一点和类的静态成员变量是一样的，当然了，它的初始化方法也和类的静态成员变量相同：

```cpp
include<iostream>   
union U   
{ static int x1;   
}； intU::x1=42;   
int main()   
{ std::cout<<U::x1<<std::endl;
```

