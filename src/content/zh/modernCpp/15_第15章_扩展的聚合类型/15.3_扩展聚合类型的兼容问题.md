# 15.3 扩展聚合类型的兼容问题

虽然扩展的聚合类型给我们提供了一些方便，但同时也带来了一个兼容老代码的问题，请考虑以下代码：

```cpp
include<iostream> #include<string> class BaseData { int data_; public: int Get() { return data_; } protected: BaseData():data_(11){} }; class DerivedData :public BaseData { public: }; int main(){
```

```cpp
DerivedData d{}; std::cout << d.Get() << std::endl; }
```

以上代码使用C++11或者C++14标准可以编译成功，而使用C++17标准编译则会出现错误，主要原因就是聚合类型的定义发生了变化。在C++17之前，类DerivedData不是一个聚合类型，所以DerivedData d{}会调用编译器提供的默认构造函数。调用DerivedData默认构造函数的同时还会调用BaseData的构造函数。虽然这里BaseData声明的是受保护的构造函数，但是这并不妨碍派生类调用它。从C++17开始情况发生了变化，类DerivedData变成了一个聚合类型，以至于DerivedData d{}也跟着变成聚合类型的初始化，因为基类BaseData中的构造函数是受保护的关系，它不允许在聚合类型初始化中被调用，所以编译器无奈之下给出了一个编译错误。如果读者在更新开发环境到C++17标准的时候遇到了这样的问题，只需要为派生类提供一个默认构造函数即可。

