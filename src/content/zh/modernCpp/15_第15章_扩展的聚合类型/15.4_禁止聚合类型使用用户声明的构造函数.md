# 15.4 禁止聚合类型使用用户声明的构造函数

在前面我们提到没有用户提供的构造函数是聚合类型的条件之一，但是请注意，用户提供的构造函数和用户声明的构造函数是有区别的，比如：

```txt
include<iostream> struct X{  $\mathrm{X}() =$  default;   
};   
struct Y{
```

```cpp
Y()  $=$  delete;   
}；   
int main(){ std::cout<<std::boolalpha <<"std::is_aggregate_v<X>:"<<std::is_aggregate_v<X><std::endl <<"std::is_aggregate_v<X>:"<<std::is_aggregate_v<X><std::endl; }
```

用C++17标准编译运行以上代码会输出:

```rust
std::is_aggregate_v<X> : true  
std::is_aggregate_v<Y> : true
```

由此可见，虽然类x和y都有用户声明的构造函数，但是它们依旧是聚合类型。不过这就引出了一个问题，让我们将目光放在结构体Y上，因为它的默认构造函数被显式地删除了，所以该类型应该无法实例化对象，例如：

```txt
Yy1; //编译失败，使用了删除函数
```

但是作为聚合类型，我们却可以通过聚合初始化的方式将其实例化：

```txt
Yy2{}； //编译成功
```

编译成功的这个结果显然不是类型Y的设计者想看到的，而且这个问题很容易在真实的开发过程中被忽略，从而导致意想不到的结果。除了删除默认构造函数，将其列入私有访问中也会有同样的问题，比如：

```txt
struct Y {
private:
    Y() = default;
};
Y y1; //编译失败，构造函数为私有访问
Y y2{}; //编译成功
```

请注意，这里Y() = default; 中的 = default 不能省略，否则 Y 会被识别为一个非聚合类型。

为了避免以上问题的出现，在C++17标准中可以使用explicit说明符或者将  $=$  default声明到结构体外，例如：

```txt
struct X {
    explicit X() = default;
};
struct Y {
    Y();
};
```

这样一来，结构体x和y被转变为非聚合类型，也就无法使用聚合初始化了。不过即使这样，还是没有解决相同类型不同实例化方式表现不一致的尴尬问题，所以在C++20标准中禁止聚合类型使用用户声明的构造函数，这种处理方式让所有的情况保持一致，是最为简单明确的方法。同样是本节中的第一段代码示例，用C++20环境编译的输出结果如下：

```txt
std::is_aggregate_v<X> : false  
std::is_aggregate_v<Y> : false
```

值得注意的是，这个规则的修改会改变一些旧代码的意义，比如我们经常用到的禁止复制构造的方法：

```cpp
struct X {
    std::string s;
    std::vector<int> v;
    X() = default;
    X(const X&) = delete;
    X(X&&) = default;
};
```

上面这段代码中结构体x在C++17标准中是聚合类型，所以可以使用聚合类型初始化对象。但是升级编译环境到C++20标准会使x转变为非聚合对象，从而造成无法通过编译的问题。一个可行的解决方案是，不要直接使用= delete;来删除复制构造函数，而是通过加入或者继承一个不可复制构造的类型来实现类型的不可复制，例如：

```c
struct X {
    std::string s;
    std::vector<int> v;
    [[no_unique_address]] NonCopyable nc;
};
// 或者
struct X : NonCopyable {
    std::string s;
    std::vector<int> v;
};
```

这种做法能让代码看起来更加简洁，所以我们往往会被推荐这样做。

