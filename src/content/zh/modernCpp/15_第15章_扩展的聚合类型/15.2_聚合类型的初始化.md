# 15.2 聚合类型的初始化

由于聚合类型定义的扩展，聚合对象的初始化方法也发生了变化。过去要想初始化派生类的基类，需要在派生类中提供构造函数，例如：

```cpp
include<iostream>   
#include<string>   
class MyStreamWithIndex : public std::string{   
public: MyStringWithIndex(const std::string& str, int idx) : std::string(str), index_(idx) {} int index_ = 0;   
};   
std::ostream& operator << (std::ostream &o, const MyStreamWithIndex& s) { o << s.index_ << "." << s.c_str(); return o;   
}   
int main() { MyStringWithIndex s("hello world", 11); std::cout << s << std::endl;
```

在上面的代码中，为了初始化基类我们不得不为 MyStringWithIndex提供一个构造函数，用构造函数的初始化列表来初始化std::string。现在，由于聚合类型的扩展，这个过程得到了简化。需要做的修改只有两点，第一是删除派生类中用户提供的构造函数，第二是直接初始化：

```cpp
include<iostream> #include<string> class MyStringWithIndex : public std::string { public: int index  $\equiv$  0; }; std::ostream& operator << (std::ostream &o, const MyStringWithIndex& s) { o<<s.index<<"::"<<s.c_str(); return o; }
```

```cpp
int main()   
{ MyStringWithIndex s{ {"hello world"，11}； std::cout<<s<<std::endl;
```

删除派生类中用户提供的构造函数是为了让

MyStringWithIndex成为一个C++17标准的聚合类型，而作为聚合类型直接使用大括号初始化即可。MyStringWithIndex s{{"hello world"，11}是典型的初始化基类聚合类型的方法。其中{"hello world"}用于基类的初始化，11用于index_的初始化。这里的规则总是假设基类是一种在所有数据成员之前声明的特殊成员。所以实际上，{"hello world"}的大括号也可以省略，直接使用MyStringWithIndex s{ "hello world"，11}也是可行的。另外，如果派生类存在多个基类，那么其初始化的顺序与继承的顺序相同：

```cpp
include<iostream>   
#include<string>   
class Count {   
public: int Get() { return count_  $^{+ + }$  ； } int count  $\equiv$  0;   
}；   
class MyStreamWithIndex : public std::string, public Count {   
public: int index  $\equiv$  0;   
}；   
std::ostream& operator << (std::ostream &o, MyStringWithIndex& s) { o<<s.index<<":"<<s.Get()<<":"<<s.c_str();
```

```cpp
return o;   
}   
int main()   
{ MyStringWithIndex s{"hello world",7,11}; std::cout<<s<<std::endl; std::cout<<s<<std::endl;
```

在上面的代码中，类MyStringWithIndex先后继承了std::string和Count，所以在初始化时需要按照这个顺序初始化对象。{ "hello world"，7，11}中字符串"hello world"对应基类std::string，7对应基类Count，11对应数据成员index_。

