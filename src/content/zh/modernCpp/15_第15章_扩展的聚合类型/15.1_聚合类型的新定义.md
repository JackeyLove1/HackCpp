# 15.1 聚合类型的新定义

C++17标准对聚合类型的定义做出了大幅修改，即从基类公开且非虚继承的类也可能是一个聚合。同时聚合类型还需要满足常规条件。

1. 没有用户提供的构造函数。  
2. 没有私有和受保护的非静态数据成员。  
3. 没有虚函数。

在新的扩展中，如果类存在继承关系，则额外满足以下条件。

4. 必须是公开的基类，不能是私有或者受保护的基类。  
5. 必须是非虚继承。

请注意，这里并没有讨论基类是否需要是聚合类型，也就是说基类是否是聚合类型与派生类是否为聚合类型没有关系，只要满足上述5个条件，派生类就是聚合类型。在标准库<type Traits>中提供了

一个聚合类型的甄别办法is_aggregate，它可以帮助我们判断目标类型是否为聚合类型：

```cpp
include<iostream>   
#include<string>   
class MyString : public std::string {};   
int main()   
{ std::cout << "std::is_aggregate_v<std::string> = " << std::is_aggregate_v<std::string> << std::endl; std::cout << "std::is_aggregate_v<String> = " << std::is_aggregate_v<String> << std::endl; }
```

在上面的代码中，先通过std::is_aggregate_v判断std::string是否为聚合类型，根据我们对std::string的了解，它存在用户提供的构造函数，所以一定是非聚合类型。然后判断类MyString是否为聚合类型，虽然该类继承了std::string，但因为它是公开继承且是非虚继承，另外，在类中不存在用户提供的构造函数、虚函数以及私有或者受保护的数据成员，所以MyString应该是聚合类型。编译运行以上代码，输出的结果也和我们判断的一致：

```txt
std::is_aggregate_v<std::string> = 0
std::is_aggregate_v<MyString> = 1
```

