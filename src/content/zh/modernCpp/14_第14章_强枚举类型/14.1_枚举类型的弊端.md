# 14.1 枚举类型的弊端

C++之父本贾尼·斯特劳斯特卢普曾经在他的The Design And Evolution Of C++一书中写道“C enumerations constitute a curiously half-baked concept.”。翻译过来就是“C语言的枚举类型构成了一个奇怪且半生不熟的概念”，可见这位C++之父对于enum类型的现状是不满意的，主要原因是enum类型破坏了C++的类型安全。大多数情况下，我们说C++是一门类型安全的强类型语言，但是枚举类型在一定程度上却是一个例外，具体来说有以下几个方面的原因。

首先，虽然枚举类型存在一定的安全检查功能，一个枚举类型不允许分配到另外一种枚举类型，而且整型也无法隐式转换成枚举类型。但是枚举类型却可以隐式转换为整型，因为C++标准文档提到“枚举类型可以采用整型提升的方法转换成整型”。请看下面的代码示例：

```txt
enum School { principal, teacher, student };   
enum Company { chairman, manager,
```

```txt
employee   
}；   
int main()   
{ School  $\mathbf{x} =$  student; Company y  $=$  manager; bool b  $=$  student  $\rightharpoondown$  manager; //不同类型之间的比较操作  $\mathrm{b} = \mathrm{x} <   \mathrm{employee};$  inty  $=$  student; //隐式转换为int
```

在上面的代码中两个不同类型的枚举标识符student和manager可以进行比较，这在C++语言的其他类型中是很少看到的。这种比较合法的原因是枚举类型先被隐式转换为整型，然后才进行比较。同样的问题也出现在student直接赋值到int类型变量上的情况中。另外，下面的代码会触发C++对枚举的检查，它们是无法编译通过的：

```txt
School x = chairman; // 类型不匹配，无法通过编译  
Company y = student; // 类型不匹配，无法通过编译  
x = 1; // 整型无法隐式转换到枚举类型
```

然后是枚举类型的作用域问题，枚举类型会把其内部的枚举标识符导出到枚举被定义的作用域。也是就说，我们使用枚举标识符的时候，可以跳过对于枚举类型的描述：

```txt
School x = student;  
Company y = manager;
```

无论是初始化x，还是初始化y，我们都没有对student和manager的枚举类型进行描述。因为它们已经跳出了School和Company。在我们看到的第一个例子中，这没有什么问题，两种类型相安无事。但是如果遇到下面的这种情况就会让人头痛了：

```txt
enum HighSchool { student, teacher, principal };   
enum University { student, professor, principal };
```

HighSchool和University都有student和principal，而枚举类型又会将其枚举标识符导出到定义它们的作用域，这样就会发生重复定义，无法通过编译。解决此类问题的一个办法是使用命名空间，例如：

```txt
enum HighSchool { student, teacher, principal };   
namespace AcademicInstitution   
{   
enum University { student, professor, principal };   
}
```

这样一来，University的枚举标识符就会被导出到AcademicInstitution的作用域，和HighSchool的全局作用域区分开来。

对于上面两个问题，有一个比较好但并不完美的解决方案，代码如下：

```txt
include<iostream>   
class AuthorityType{ enum InternalType { ITBan, ITGuest, ITMember, ITAdmin, ITSystem, } ; InternalType self_;   
public: AuthorityType(InternalType self) : self_(self) {} bool operator < (const AuthorityType &other) const { return self_ < other.self_; } bool operator > (const AuthorityType &other) const { return self_ > other.self_; } bool operator <= (const AuthorityType &other) const { return self_ <= other.self_; } bool operator >= (const AuthorityType &other) const { return self_ >= other.self_; } bool operator == (const AuthorityType &other) const { return self_ == other.self_; } bool operator != (const AuthorityType &other) const { return self_ != other.self_; } const static AuthorityType System, Admin, Member, Guest, Ban; };
```

```cpp
define DEFINE_AuthorityType(x) const AuthorityType \ AuthorityType::x(AuthorityType::IT ## x)   
DEFINE_AuthorityType(System);   
DEFINE_AuthorityType(Admin);   
DEFINE_AuthorityType(Member);   
DEFINE_AuthorityType(Guest);   
DEFINE_AuthorityType(Ban);   
int main()   
{ bool b  $=$  AuthorityType::System  $>$  AuthorityType::Admin; std::cout << std::boolalpha << b << std::endl; }
```

让我们先看一看以上代码的优点。

将枚举类型变量封装成类私有数据成员，保证无法被外界访问。访问枚举类型的数据成员必须通过对应的常量静态对象。另外，根据C++标准的约束，访问静态对象必须指明对象所属类型。也就是说，如果我们想访问ITSystem这个枚举标识符，就必须访问常量静态对象System，而访问System对象，就必须说明其所属类型，这使我们需要将代码写成AuthorityType:: System才能编译通过。

由于我们实现了比较运算符，因此可以对枚举类型进行比较。但是比较运算符函数只接受同类型的参数，所以只允许相同类型进行比较。

当然很明显，这样做也有缺点。

最大的缺点是实现起来要多敲很多代码。

枚举类型本身是一个POD类型，而我们实现的类破坏了这种特性。

还有一个严重的问题是，无法指定枚举类型的底层类型。因此，不同的编译器对于相同枚举类型可能会有不同的底层类型，甚至有无符号也会不同。来看下面这段代码：

```cpp
enum E {
    e1 = 1,
    e2 = 2,
    e3 = 0xFFFFFFf0
};
int main()
{
    bool b = e1 < e3;
    std::cout << std::boolalpha << b << std::endl;
}
```

读者可以思考一下，上面这段代码的输出结果是什么？答案是不同的编译器会得到不同的结果。在GCC中，结果返回true，我们可以认为E的底层类型为unsigned int。如果输出e3，会发现其值为4294967280。但是在MSVC中结果输出为false，很明显在编译器内部将E定义为了int类型，输出e3的结果为-16。这种编译器上的区别会使在编写跨平台程序时出现重大问题。

虽然说了这么多枚举类型存在的问题，但是我这里想强调一个观点，如果代码中有需要表达枚举语义的地方，还是应该使用枚举类型。原因就是在第一个问题中讨论的，枚举类型还是有一定的类型检查能力。我们应该避免使用宏和const int的方法去实现枚举，因为其缺点更加严重。

值得一提的是，枚举类型缺乏类型检查的问题倒是成就了一种特殊用法。如果读者了解模板元编程，那么肯定见过一种被称为enum hack的枚举类型的用法。简单来说就是利用枚举值在编译期就能确定下来的特性，让编译器帮助我们完成一些计算：

```txt
include<iostream>   
template<int a, int b>   
struct add{ enum{ result  $=$  a  $^+$  b }；   
}；   
int main() { std::cout<<add<5，8>：:result<<std::endl; 1
```

用GCC查看其GIMPLE的中间代码:

```cpp
main ()  
{  
    int D.39267;  
    _1 = std::basic_ostream<char>::operator<< (&cout, 13);  
    std::basic_ostream<char>::operator<< (_1, endl);  
    D.39267 = 0;  
    return D.39267;  
}
```

可以看到add<5，8>::result在编译器编译代码的时候就已经计算出来了，运行时直接使用<<运算符输出结果13。

