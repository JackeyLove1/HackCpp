# 14.3 列表初始化有底层类型枚举对象

从C++17标准开始，对有底层类型的枚举类型对象可以直接使用列表初始化。这条规则适用于所有的强枚举类型，因为它们都有默认的底层类型int，而枚举类型就必须显式地指定底层类型才能使用该特性：

```txt
enum class Color {
    Red,
    Green,
    Blue
};
int main()
{
    Color c{5}; //编译成功
    Color c1 = 5; //编译失败
    Color c2 = {5}; //编译失败
    Color c3(5); //编译失败
}
```

在上面的代码中，c可以在C++17环境下成功编译运行，因为Color有默认底层类型int，所以能够通过列表初始化对象，但是c1、c2和c3就没有那么幸运了，它们的初始化方法都是非法的。同样的道理，下面的代码能编译通过：

```txt
enum class Color1 : char {};  
enum Color2 : short {};  
int main()  
{  
    Color1 c{7};  
    Color2 c1{11};  
    Color2 c2 = Color2{5};  
}
```

请注意，虽然Color2 c2 = Color2{5}和Color c2 = {5}在代码上有些类似，但是其含义是完全不同的。对于Color2 c2

= Color2{5}来说，代码先通过列表初始化了一个临时对象，然后再赋值到c2，而Color c2 = {5}则没有这个过程。另外，没有指定底层类型的枚举类型是无法使用列表初始化的，比如：

```txt
enum Color3 {};  
int main()  
{  
    Color3 c{7};  
}
```

以上代码一定会编译报错，因为无论是C++17还是在此之前的标准，Color3都没有底层类型。同所有的列表初始化一样，它禁止缩窄转换，所以下面的代码也是不允许的：

```txt
enum class Color1 : char {};  
int main()  
{  
    Color1 c{7.11};  
}
```

到此为止，读者应该都会有一个疑问，C++11标准中对强枚举类型初始化做了严格限制，目的就是防止枚举类型的滥用。可是C++17又打破了这种严格的限制，我们似乎看不出这样做的好处。实际上，让有底层类型的枚举类型支持列表初始化的确有一个十分合理的动机。

现在假设一个场景，我们需要一个新整数类型，该类型必须严格区别于其他整型，也就是说不能够和其他整型做隐式转换，显然使用 typedef的方法是不行的。另外，虽然通过定义一个类的方法可以到

达这个目的，但是这个方法需要编写大量的代码来重载运算符，也不是一个理想的方案。所以，C++的专家把目光投向了有底层类型的枚举类型，其特性几乎完美地符合以上要求，除了初始化整型值的时候需要用到强制类型转换。于是，C++17为有底层类型的枚举类型放宽了初始化的限制，让其支持列表初始化：

```txt
include<iostream>   
enum class Index : int {};   
int main()   
{ Index a{5}； Index b{10}； //a=12; //int c=b; std::cout<<"a<b is" <<std::boolalpha << (a < b) << std::endl;   
}
```

在上面的代码中，定义了Index的底层类型为int，所以可以使用列表初始化a和b，由于a和b的枚举类型相同，因此所有  $a < b$  的用法也是合法的。但是  $a = 12$  和 int  $c = b$  无法成功编译，因为强枚举类型是无法与整型隐式相互转换的。

最后提示一点，在C++17的标准库中新引入的std::byte类型就是用这种方法定义的。

