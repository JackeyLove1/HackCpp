# 14.2 使用强枚举类型

由于枚举类型确实存在一些类型安全的问题，因此C++标准委员会在C++11标准中对其做出了重大升级，增加了强枚举类型。另外，为了保证老代码的兼容性，也保留了枚举类型之前的特性。强枚举类型具备以下3个新特性。

1. 枚举标识符属于强枚举类型的作用域。  
2. 枚举标识符不会隐式转换为整型。  
3. 能指定强枚举类型的底层类型，底层类型默认为int类型。

定义强枚举类型的方法非常简单，只需要在枚举定义的enum关键字之后加上class关键字就可以了。下面将HighSchool和University改写为强枚举类型：

```cpp
include<iostream>   
enum class HighSchool{ student, teacher, principal };   
enum class University { student, professor, principal };   
int main()   
{ HighSchool  $\mathbf{x} =$  HighSchool::student; University y  $=$  University::student; bool b  $=$  x  $<$  HighSchool::headmaster; std::cout << std::boolalpha << b << std::endl;
```

观察上面的代码可以发现，首先，在不使用命名空间的情况下，两个有着相同枚举标识符的强枚举类型可以在一个作用域内共存。这符合强枚举类型的第一个特性，其枚举标识符属于强枚举类型的作用域，无法从外部直接访问它们，所以在访问时必须加上枚举类型名，否则会编译失败，如HighSchool::student。其次，相同枚举类型的枚举标识符可以进行比较，但是不同枚举类型就无法比较其枚举标识符了，因为它们失去了隐式转换为整型的能力，这一点符合强枚举类型的第二个特性：

```txt
HighSchool x = student; //编译失败，找不到student的定义  
bool b = University::student < HighSchool::headmaster; //编译失败，比较的类型不同  
int y = University::student; //编译失败，无法隐式转换为int类型
```

有了这两个特性的支持，强枚举类型就可以完美替代14.1节中实现的AuthorityType类，强枚举类型不仅实现起来非常简洁，而且还是POD类型。

对于强枚举类型的第三个特性，我们可以在定义类型的时候使用：符号来指明其底层类型。利用它可以消除不同编译器带来的歧义：

```cpp
enum class E : unsigned int { e1 = 1, e2 = 2, e3 = 0xFFFFFF0 }; int main() { bool b = e1 < e3; std::cout << std::boolalpha << b << std::endl; }
```

上面这段代码明确指明了枚举类型E的底层类型是无符号整型，这样一来无论使用GCC还是MSVC，最后返回的结果都是true。如果这里不指定具体的底层类型，编译器会使用int类型。但GCC和MSVC的行为又出现了一些区别：MSVC会编译成功，e3被编译为一个负值；而GCC则会报错，因为0xFFFFFF0超过了int能表达的最大正整数范围。

在C++11标准中，我们除了能指定强枚举类型的底层类型，还可以指定枚举类型的底层类型，例如：

```cpp
enum E : unsigned int { e1 = 1, e2 = 2, e3 = 0xffffff0 }; int main() { bool b = e1 < e3; std::cout << std::boolalpha << b << std::endl; }
```

另外，虽然我们多次强调了强枚举类型的枚举标识符是无法隐式转换为整型的，但还是可以通过static_cast对其进行强制类型转换，但我建议不要这样做。最后说一点，强枚举类型不允许匿名，我们必须给定一个类型名，否则无法通过编译。

