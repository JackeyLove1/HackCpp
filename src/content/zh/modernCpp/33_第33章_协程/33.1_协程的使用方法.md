# 33.1 协程的使用方法

协程并不是一个新鲜的概念，如果读者熟悉C#或者Python，可能或多或少对它有所了解。概括来讲，协程是一种可以被挂起和恢复的函数，它提供了一种创建异步代码的方法。

事实上，C++中协程的概念早在2017年已经被提出，并且作为技术规范（Technical Specification）加入C++扩展中。不过协程迟迟没有加入C++标准中，因为很多专家质疑和反对这项新特性，他们认为协程过于复杂让人难以理解，并且有过多需要自定义的代码才能让其正常工作。所以这项提案直到2019年3月的C++标准委员会上才通过投票加入C++20标准中，并且最终采用了微软的实现方案。

在我看来，协程的实现确实非常复杂，只想通过文字描述来理解协程有一定的困难，想要充分理解协程甚至可能需要深入汇编层面去观察其代码的生成详情。为了便于读者理解，我将本章分为两个部分，首先讨论协程的使用方法，由于C++20标准库提供了一系列的辅助代码，因此在协程的使用的理解上不会有太大难度。然后我们再去讨论协程的实现原理，这部分我会通过实现一套辅助代码的方法尽可能理清协程的实现原理。最后请注意，本章中的示例代码均采用MSVC进行编译。

刚刚提到过，协程是一种可以被挂起和恢复的函数，那么究竟如何让函数挂起和恢复呢？请看下面的代码：

```cpp
include<iostream> #include<chrono>#include <future> using namespace std::chrono_literals; std::future<int> foo(){ std::cout << "call foo\n"; std::this_thread::sleep_for(3s); co_return 5; } std::future<std::future<int>> bar(){ std::cout << "call bar\n"; std::cout << "before foo\n"; auto n = co_wait std::async(foo); //挂起点 std::cout << "after foo\n"; co_return n; } int main() { std::cout << "before bar\n"; auto i  $=$  bar(); std::cout << "after bar\n"; i.wait(); std::cout << "result  $=$  "<< i.get().get();
```

编译运行以上代码，输出结果如下：

```txt
before bar call bar before foo after bar call foo after foo result  $= 5$
```

仔细观察输出结果就会发现，代码在输出before foo以后的运行流程不同寻常。普通情况下，即使异步调用foo()函数，before foo之后输出的应该也是after foo，但是真实结果输出的却是after bar。也就是说线程执行到auto n = coAwait std::async (foo);之后跳出了bar函数，如同从函数中间return了一般，返回后执行了std::cout << "after bar\n";，最后等待std::future<std::future<int>>的结果。实际上，我们看到的这个过程就是协程的挂起操作，而auto n = coAwait std::async.foo);是协程的挂起点。观察这句代码我们会发现一个新的关键字coAwait，读者暂时不需要理会它的具体功能，只需要将其当作是挂起点的标识即可。继续观察输出结果会看到call foo和紧随其后的after foo，说明函数foo执行结束之后，bar函数从当前的挂起点恢复了执行。进一步来说，coAwait会触发一个挂起点，在触发挂起点后执行流程会返回到调用者继续执行，同时异步执行coAwait所等待的对象，在等待对象执行完毕后，挂起点恢复执行流程继续执行后续代码。观察foo函数的代码，也会发现一个新的关键字co_return，我们暂时不需要关心它的详情，只需要知道它设置了返回值的结果，并且触发了挂起点的恢复，伪代码如下：

```cpp
std::cout << "call foo\n";  
std::this_thread::sleep_for(3s);  
set_return_future_value(5);  
set_future_ready();
```

需要说明的是，这里没有使用<< std::endl换行是因为异步执行会打乱输出，为了防止输出格式混乱，这里直接在字符串中使用\n换行。

在理解co_wait和co_return挂起和恢复协程之后，我们再来讨论另一种情况：

```cpp
include<iostream>   
#include <experimental/generator>   
std::experimental::generator<int> foo()   
{ std::cout << "begin" << std::endl; for (int i = 0; i < 10; i++) { co_yield i; } std::cout << "end" << std::endl;   
}   
int main()   
{ for (auto i : foo()) { std::cout << i << std::endl; }   
}
```

编译运行以上代码，输出结果如下：

```txt
begin 0 1 2 3 4 5 6 7 8 9 end
```

这次读者应该能猜到挂起点的位置了，就是co_yield i;。代码在执行到for (auto i : foo())的时候调用函数foo()，并且输出字符串begin。然后进入循环，当执行到co_yield i;时协程被挂起，并将i的值返回给调用者。对于第一次执行，i的值为0，紧跟在begin之后的输出为0。再次进入循环并调用foo()的时候，函数并不会从头开始执行，而是从上次执行的挂起点恢复执行，于是0之后不会再次输出begin，而是输出数字1。依此类推，执行到输出9后再次进入foo函数，从挂起点恢复后跳出循环并执行std::cout << "end" << std::endl;。

上面的两个例子中出现了3个新关键字，分别是co await、co_return和coymax。C++20标准规定，具有以上3个关键字中任意一个的函数就是协程。请注意，因为main函数不能为协程，所以函数体中不能出现这3个关键字。通常情况下，建议将协程和标准库中的future、generator一起使用，因为协程辅助代码较为复杂，所以应该尽量避免自定义它们。

请注意，协程虽然提供了一种异步代码的编写方法，但是并不会自动执行异步操作，例如：

```cpp
include<iostream>   
#include<chrono>   
#include <future>   
using namespace std::chrono_literals;   
std::packaged_task<int()  $\rightharpoondown$  task( []（）{ std::cout<<"calltask\n"; std::this_thread::sleep_for(3s);
```

```cpp
return 5;   
}   
);   
std::future<int> bar() { return task.get_future();   
}   
std::future<void> foo() { std::cout << "call foo\n"; std::cout << "before bar\n"; auto i = co_wait bar(); std::cout << "after bar\n"; std::cout << "result = " << i;   
}   
int main() { std::cout << "before foo\n"; auto w = foo(); std::cout << "after foo\n"; w.wait();   
}
```

在上面的代码中，虽然使用auto i = co_wait bar();挂起了协程，但是并没有其他线程执行异步操作，造成的结果就是w.wait();一直等待。代码运行的结果如下：

```txt
before foo call foo before bar after foo
```

除了编写协程代码，我们还需要为协程创建异步执行环境，让我们修改上面代码的bar函数：

```cpp
std::future<int> bar()
{
    std::future<int> r = task.get_future();
    std::thread t(std::move(task));
```

```txt
tdetach(); return r; }
```

再次编译运行代码，可以获得正确的输出结果如下：

```txt
before foo call foo before bar after foo call task after bar result  $= 5$
```

