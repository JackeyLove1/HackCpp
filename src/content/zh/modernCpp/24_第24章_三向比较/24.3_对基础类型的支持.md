# 24.3 对基础类型的支持

1. 对两个算术类型的操作数进行一般算术转换，然后进行比较。其中整型的比较结果为std::strong_ordering，浮点型的比较结果为std::partial_ordering。例如7 <= 11.1中，整型7会转换为浮点类型，然后再进行比较，最终结果为std::partial_ordering类型。

2. 对于无作用域枚举类型和整型操作数，枚举类型会转换为整型再进行比较，无作用域枚举类型无法与浮点类型比较：

```txt
enum color {
    red
};
auto r = red <= 11; //编译成功
auto r = red <= 11.1; //编译失败
```

3. 对两个相同枚举类型的操作数比较结果，如果枚举类型不同，则无法编译。  
4. 对于其中一个操作数为bool类型的情况，另一个操作数必须也是bool类型，否则无法编译。比较结果为

```txt
std::strong_ordering。
```

5. 不支持作比较的两个操作数为数组的情况，会导致编译出错，例如：

```txt
int arr1[5];  
int arr2[5];  
auto r = arr1 <= arr2; //编译失败
```

6. 对于其中一个操作数为指针类型的情况，需要另一个操作数是同样类型的指针，或者是可以转换为相同类型的指针，比如数组到指针的转换、派生类指针到基类指针的转换等，最终比较结果为

```txt
std::strong_ordering:
```

```txt
char arr1[5]; char arr2[5];
```

```txt
char\*ptr  $\equiv$  arr2;   
auto  $r =$  ptr  $<   = >$  arr1;
```

上面的代码可以编译成功，若将代码中的arr1改写为int arr1[5]，则无法编译，因为int [5]无法转换为char *。如果将 char * ptr = arr2;修改为void * ptr = arr2;，代码就可以编译成功了。

