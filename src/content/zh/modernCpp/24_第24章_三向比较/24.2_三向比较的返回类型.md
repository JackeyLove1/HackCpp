# 24.2 三向比较的返回类型

可以看出  $\leqslant >$  的返回结果并不是一个普通类型，根据标准三向比较会返回3种类型，分别为std::strong_ordering、std::weak_ordering以及std::partial_ordering，而这3种类型又会分为有  $3\sim 4$  种最终结果，下面就来一一介绍它们。

# 24.2.1 std::strong_ordering

std::strong_ordering类型有3种比较结果，分别为std::strong_ordering::less、std::strong_ordering::equal以及std::strong_ordering::greater。表达式lhs <= > rhs分别表示lhs <rhs、lhs == rhs以及lhs > rhs。std::strong_ordering类型的结果强调的是strong的含义，表达的是一种可替换性，简单来说，若lhs == rhs，那么在任何情况下rhs和lhs都可以相互替换，也就是fx(lhs) == fx(rhs)。

对于基本类型中的int类型，三向比较返回的是std::strong_ordering，例如：

```cpp
std::cout << typeid(decltype(7 <= 11)).name();
```

用MSVC编译运行以上代码，会在输出窗口显示class std::strong_ordering，刻意使用MSVC是因为它的

```c
typedef(x).name() 可以输出友好可读的类型名称。对于有复杂结构的类型，std::strong_ordering 要求其数据成员和基类的三向比较结果都为 std::strong_ordering。例如：

```cpp
include <compare>   
struct B { int a; long b; auto operator  $\text{一} = >$  (const B&） const  $=$  default; }；   
struct D:B { short c; auto operator  $\text{一} = >$  (const D&） const  $=$  default; }；   
Dx1，x2; std::cout<<typeid(decltype(x1  $\text{一} = >$  x2)).name();
```

上面这段代码用MSVC编译运行会输出class

std::strong_ordering。请注意，默认情况下自定义类型是不存在三向比较运算符函数的，需要用户显式默认声明，比如在结构体B和D中声明auto operator  $<=$  (const B&） const = default;和auto operator  $<=$  (const D&） const = default;。对结构体B而言，由于int和long的比较结果都是std::strong_ordering，因此结构体B的三向比较结果也是std::strong_ordering。同理，对于结构体D，其基类和成员的比较结果是std::strong_ordering，D的三向比较结果同样是

std::strong_ordering。另外，明确运算符的返回类型，使用std::strong_ordering替换auto也是没问题的。

# 24.2.2 std::weak_ordering

std::weak_ordering类型也有3种比较结果，分别为std::weak_ordering::less、std::weak_ordering::equivalent以及std::weak_ordering::greater。std::weak_ordering的含义正好与std::strong_ordering相对，表达的是不可替换性。即若有lhs == rhs，则rhs和lhs不可以相互替换，也就是fx(lhs) != fx(rhs)。这种情况在基础类型中并没有，但是它常常发生在用户自定义类中，比如一个大小写不敏感的字符串类：

```cpp
include <compare> #include <string> int ci comparc(const char\* s1, const char\* s2) { while (tolower(\*s1)  $= =$  tolower(\*s2++)）{ if (\*s1++  $= =$  '\0') { return 0; } return tolower(\*s1)-tolower(\*-s2);   
}   
class CIsring { public: CIsring(const char \*s) : str_(s){ std::weak_ordering operator  $<   = >$  (const CIsring& b) const { return ci_compare(str_.c_str(),b.str_.c_str())  $<   = > 0$  .
```

```cpp
private: std::string str_;   
};   
CString s1{ "HELLO" },s2{"hello"}; std::cout << (s1 <=> s2 == 0); // 输出为true
```

以上代码实现了一个简单的大小写不敏感的字符串类，它对于s1和s2的比较结果是std::weak_ordering::equivalent，表示两个操作数是等价的，但是它们不是相等的也不能相互替换。当

std::weak_ordering和std::strong_ordering同时出现在基类和数据成员的类型中时，该类型的三向比较结果是

std::weak_ordering，例如：

```cpp
struct D : B
{
    CString c[")];
    auto operator <= => (const D&) const = default;
};
D w1, w2;
std::cout << typeid(decltype(w1 <= > w2)).name();
```

用MSVC编译运行上面这段代码会输出class

std::weak_ordering，因为D中的数据成员CString的三向比较结果为std::weak_ordering。请注意，如果显式声明默认三向比较运算符函数为std::strong_ordering operator <= (const D&) const = default;，那么一定会遭遇到一个编译错误。

# 24.2.3 std::partial_ordering

```cpp
std::partial_ordering类型有4种比较结果，分别为std::partial_ordering::less、std::partial_ordering::equivalent、std::partial_ordering::greater以及std::partial_ordering::unordered。std::partial_ordering约束力比std::weak_ordering更弱，它可以接受当lhs == rhs时rhs和lhs不能相互替换，同时它还能给出第四个结果std::partial_ordering::unordered，表示进行比较的两个操作数没有关系。比如基础类型中的浮点数：
```

```cpp
std::cout << typeid(decltype(7.7 <= 11.1)).name();
```

```cpp
用MSVC编译运行以上代码会输出class std::partial_ordering。之所以会输出class std::partial_ordering而不是std::strong_ordering，是因为浮点的集合中存在一个特殊的NaN，它和其他浮点数值是没关系的：
```

```cpp
std::cout << ((0.0 / 0.0 <= 1.0) == std::partial_ordering::unordered);
```

```txt
这段代码编译输出的结果为true。当std::weak_ordering和std::partial_ordering同时出现在基类和数据成员的类型中时，该类型的三向比较结果是std::partial_ordering，例如：
```

```txt
struct D : B {
```

```txt
CString c[""]; float u; auto operator  $<  = >$  (const D&） const  $\equiv$  default;   
}；   
Dw1，w2; std::cout<<typeid(decltype(w1  $<   =   >$  w2)).name();
```

用MSVC编译运行以上代码会输出class

std::partial_ordering，因为D中的数据成员u的三向比较结果为std::partial_ordering，同样，显式声明为其他返回类型也会让编译器报错。在C++20的标准库中有一个模板元函数

std::common comparision_category，它可以帮助我们在一个类型合集中判断出最终三向比较的结果类型，当类型合集中存在不支持三向比较的类型时，该模板元函数返回void。

再次强调一下，std::strong_ordering、

std::weak_ordering和`std::partial_ordering`只能与`0`和类型自身比较。深究其原因，是这3个类只实现了参数类型为自身类型和`nullptr_t`的比较运算符函数。

