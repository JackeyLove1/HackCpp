# 24.5 兼容旧代码

现在C++20标准已经推荐使用<>和==运算符自动生成其他比较运算符函数，而使用<、==以及std::relOps生成其他比较运算符函数则会因为std::relOps已经不被推荐使用而被编译器警告。那么对于老代码，我们是否需要去实现一套<>和==运算符函数呢？其实大可不必，C++委员会在裁决这项修改的时候已经考虑到老代码的维护成本，所以做了兼容性处理，即在用户自定义类型中，实现了<、==运算符函数的数据成员类型，在该类型的三向比较中将自动生成合适的比较代码。比如：

```txt
struct Legacy {
    int n;
    bool operator == (const Legacy& rhs) const {
        return n == rhs.n;
    }
    bool operator < (const Legacy& rhs) const
```

```txt
{ return n < rhs.n; }   
}；   
struct TreeWay { Legacy m; std::strong_ordering operator  $\leqslant >$  (const TreeWay &) const  $=$  default; 1;   
TreeWay t1, t2; bool r = t1 < t2;
```

在上面的代码中，结构体TreeWay的三向比较操作会调用结构体Legacy中的<和  $==$  运算符来完成，其代码类似于：

```cpp
struct TreeWay {
    Legacy m;
    std::strong_ordering operator<> (const TreeWay& rhs) const {
        if (m < rhs.m) return std::strong_ordering::less;
        if (m == rhs.m) return std::strong_ordering::equal;
        return std::strong_ordering::greater;
    }
};
```

需要注意的是，这里operator<>必须显式声明返回类型为std::strong_ordering，使用auto是无法通过编译的。

