# 24.4 自动生成的比较运算符函数

标准库中提供了一个名为std::relOps的命名空间，在用户自定义类型已经提供了==运算符函数和<运算符函数的情况下，帮助用户实现其他4种运算符函数，包括!=、>、<=和>=，例如：

```cpp
include <string>   
#include <utility>   
class CString2{   
public: CString2(const char\* s) : str_(s){ bool operator  $<$  (const CString2& b) const { return ci比較(str_c_str(),b.str_c_str())  $<  0$  .   
}   
private: std::string str;   
};   
using namespace std::relOps;   
CString2 s1{ "hello" }, s2{ "world" };   
bool r = s1 >= s2;
```

不过因为C++20标准有了三向比较运算符的关系，所以不推荐上面这种做法了。C++20标准规定，如果用户为自定义类型声明了三向

比较运算符，那么编译器会为其自动生成<、>、<=和>=这4种运算符函数。对于CSTRING我们可以直接使用这4种运算符函数：

```txt
CString s1 {"hello", s2 {"world"}; bool r = s1 >= s2;
```

那么这里就会产生一个疑问，很明显三向比较运算符能表达两个操作数是相等或者等价的含义，为什么标准只允许自动生成4种运算符函数，却不能自动生成==和!=这两个运算符函数呢？实际上这里存在一个严重的性能问题。在C++20标准拟定三向比较的早期，是允许通过三向比较自动生成6个比较运算符函数的，而三向比较的结果类型也不是3种而是5种，多出来的两种分别是std::strong equality和std::weak Equality。但是在提案文档p1190中提出了一个严重的性能问题。简单来说，假设有一个结构体：

```cpp
struct S {
    std::vector<std::string> names;
    auto operator<> (const S &) const = default;
};
```

它的三向比较运算符的默认实现这样的:

```cpp
template<typename T> std::strong_ordering operator<<(const std::vector<T>& lhs, const std::vector<T>& rhs) {
    size_t min_size = min(lhs.size(), rhs.size());
    for (size_t i = 0; i != min_size; ++i) {
        if (auto const cmp = std::compare_3way(lhs[i], rhs[i]);
        cmp != 0) {
            return cmp;
        }
    }
    return lhs.size() <= >rhs.size();
}
```

这个实现对于<和>这样的运算符函数没有问题，因为需要比较容器中的每个元素。但是==运算符就显得十分低效，对于==运算符高效的做法是先比较容器中的元素数量是否相等，如果元素数量不同，则直接返回false：

```cpp
template<typename T> bool operator = (const std::vector<T>& lhs, const std::vector<T>& rhs) {
    const size_t size = lhs.size();
    if (size != rhs.size())
        return false;
    for (size_t i = 0; i != size; ++i) {
        if ( lhs[i] != rhs[i])
            return false;
    }
    return true;
}
```

想象一下，如果标准允许用三向比较的算法自动生成  $==$  运算符函数会发生什么事情，很多旧代码升级编译环境后会发现运行效率下降了，尤其是在容器中元素数量众多且每个元素数据量庞大的情况下。很少有程序员会注意到三向比较算法的细节，导致这个性能问题难以排查。基于这种考虑，C++委员会修改了原来的三向比较提案，规定声明三向比较运算符函数只能够自动生成4种比较运算符函数。由于不需要负责判断是否相等，因此std::strong Equality和std::weakEquality也退出了历史舞台。对于  $==$  和 != 两种比较运算符函数，只需要多声明一个  $==$  运算符函数，! = 运算符函数会根据前者自动生成：

```cpp
class CString {
public:
    CString(const char* s): str_(s) {}
    std::weak_ordering operator<<(const CString& b) const {
        return ci比較(str_.c_str(), b.str_.c_str()) <= 0;
    }
    bool operator == (const CString& b) const {
        return ci比較(str_.c_str(), b.str_.c_str()) == 0;
    }
private:
    std::string str_;
```

