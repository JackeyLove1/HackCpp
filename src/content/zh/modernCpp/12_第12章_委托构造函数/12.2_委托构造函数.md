# 12.2 委托构造函数

为了合理复用构造函数来减少代码冗余，C++11标准支持了委托构造函数：某个类型的一个构造函数可以委托同类型的另一个构造函数对对象进行初始化。为了描述方便我们称前者为委托构造函数，后者为代理构造函数（英文直译为目标构造函数）。委托构造函数会将控制权交给代理构造函数，在代理构造函数执行完之后，再执行委托构造函数的主体。委托构造函数的语法非常简单，只需要在委托构造函数的初始化列表中调用代理构造函数即可，例如：

```txt
class X   
{   
public: X() : X(0, 0.) {} X(int a) : X(a, 0.) {} X(double b) : X(0, b) {} X(int a, double b) : a_(a), b_(b) { CommonInit(); } private: void CommonInit() {} int a_; double b_; };
```

可以看到X()、X(int a)、X(double b)分别作为委托构造函数将控制权交给了代理构造函数X(int a, double b)。它们的执行顺序是先执行代理构造函数的初始化列表，接着执行代理构造函数的主体（也就是CommonInit函数），最后执行委托构造函数的主体，在这个例子中委托构造函数的主体都为空。

委托构造函数的语法很简单，不过想合理使用它还需注意以下5点。

1. 每个构造函数都可以委托另一个构造函数为代理。也就是说，可能存在一个构造函数，它既是委托构造函数也是代理构造函数，例如：

```cpp
class X   
{   
public: X() : X(0) {} X(int a) : X(a, 0.) {} X(double b) : X(0, b) {} X(int a, double b) : a_(a), b_(b) { CommonInit(); } private: void CommonInit() {} int a_; double b_; };
```

在上面的代码中构造函数X(int a)，它既是一个委托构造函数，也是X()的代理构造函数。另外，除了自定义构造函数以外，我们还能让特殊构造函数也成为委托构造函数，例如：

```cpp
class X   
{   
public: X() : X(0) {} X(int a) : X(a, 0.) {} X(double b) : X(0, b) {} X(int a, double b) : a_(a), b_(b) { CommonInit(); } X(const X &other) : X(other.a_, other.b_) {} // 委托复制构造函数 private: void CommonInit() {} int a_; double b_; };
```

以上代码增加了一个复制构造函数X(const X &other)，并且把复制构造函数的控制权委托给了X(int a, double b)，而其自

身主体不需要执行。

2. 不要递归循环委托！这一点非常重要，因为循环委托不会被编译器报错，随之而来的是程序运行时发生未定义行为，最常见的结果是程序因栈内存用尽而崩溃：

```txt
class X   
{   
public: X() : X(0) {} X(int a) : X(a, 0.) {} X(double b) : X(0, b) {} X(int a, double b) : X() { CommonInit(); }   
private: void CommonInit() {} int a_; double b_; };
```

上面代码中的3个构造函数形成了一个循环递归委托，X()委托到X(int a)，X(int a)委托到X(int a, double b)，最后X(int a, double b)又委托到X()。请读者务必注意不要编写出这样的循环递归委托代码，因为我目前实验的编译器，默认情况下除了CLang会给出错误提示，MSVC和GCC都不会发出任何警告。这里也建议读者在使用委托构造函数时，通常只指定一个代理构造函数即可，其他的构造函数都委托到这个代理构造函数，尽量不要形成链式委托，避免出现循环递归委托。

3. 如果一个构造函数为委托构造函数，那么其初始化列表里就不能对数据成员和基类进行初始化：

```cpp
class X   
{   
public: X() : a_(0), b_(0) { CommonInit(); } X(int a) : X(), a_(a) {} //编译错误，委托构造函数不能在初始化列表初始化成员变量 X(double b) : X(), b_(b) {} //编译错误，委托构造函数不能在初始化列表初始化成员变量   
private: void CommonInit() {} int a_; double b_; };
```

在上面的代码中X(int a)和X(double b)都委托了X()作为代理构造函数，但是它们又打算初始化自己所需的成员变量，这样就导致了编译错误。其实这个错误很容易理解，因为根据C++标准规定，一旦类型有一个构造函数完成执行，那么就会认为其构造的对象已经构造完成。将这个规则放在这里来看，委托构造函数将控制权交给代理构造函数，代理构造函数执行完成以后，编译器认为对象已经构造成功，再次执行初始化列表必然会导致不可预知的问题，所以C++标准禁止了这样的语法。

4. 委托构造函数的执行顺序是先执行代理构造函数的初始化列表，然后执行代理构造函数的主体，最后执行委托构造函数的主体，例如：

```txt
include<iostream>   
class X   
public: X() :X(0){InitStep3();} X(int a) :X(a,0.){InitStep2();} X(double b) :X(0,b){}
```

```cpp
X(int a, double b): a_(a), b_(b) { InitStep1(); } private: void InitStep1() { std::cout << "InitStep1(" << std::endl; } void InitStep2() { std::cout << "InitStep2(" << std::endl; } void InitStep3() { std::cout << "InitStep3(" << std::endl; } int a_; double b_; }；   
int main() { X x; }
```

编译执行以上代码，输出结果如下：

```lua
InitStep1()
InitStep2()
InitStep3()
```

5. 如果在代理构造函数执行完成后，委托构造函数主体抛出了异常，则自动调用该类型的析构函数。这一条规则看起来有些奇怪，因为通常在没有完成构造函数的情况下，也就是说构造函数发生异常，对象类型的析构函数是不会被调用的。而这里的情况正好是一种中间状态，是否应该调用析构函数看似存在争议，其实不然，因为C++标准规定（规则3也提到过），一旦类型有一个构造函数完成执行，那么就会认为其构造的对象已经构造完成，所以发生异常后需要调用析构函数，来看一看具体的例子：

```txt
include<iostream>   
class X   
{   
public: X() :X(0,0.) { throw 1; } X(int a) :X(a,0.) {} X(double b) :X(0,b){ } X(int a,double b):a_(a),b_(b){ CommonInit();}
```

```txt
\~X（）{std::cout<<"\~X()""<<std::endl;} private: voidCommonInit(）{} inta_; doubleb_;   
};   
intmain() { try{ Xx; } catch（...）{ 1
```

上面的代码中，构造函数x()委托构造函数X(int a, double b)对对象进行初始化，在代理构造函数初始化完成后，在x()主体内抛出了一个异常。这个异常会被main函数的try cache捕获，并且调用x的析构函数析构对象。读者不妨自己编译运行代码，并观察运行结果。

