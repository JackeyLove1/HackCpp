# 12.3 委托模板构造函数

委托模板构造函数是指一个构造函数将控制权委托到同类型的一个模板构造函数，简单地说，就是代理构造函数是一个函数模板。这样做的意义在于泛化了构造函数，减少冗余的代码的产生。将代理构造函数编写成函数模板往往会获得很好的效果，让我们看一看例子：

```cpp
include <vector>   
#include <list>   
#include <deque>   
class X { template<class T> X(T first, T last) : l_(first, last) { std::list<int> 1;
```

```cpp
public: X(std::vector<short>&); X(std::deque<int>&); }; X::X(std::vector<short>& v) : X(v.begin(), v.end()) { } X::X(std::deque<int>& v) : X(v.begin(), v.end())) { } int main() { std::vector<short> a{ 1,2,3,4,5 }; std::deque<int> b{ 1,2,3,4,5 }; X x1(a); X x2(b); }
```

在上面的代码中template<class T> X(T first, T last)是一个代理模板构造函数，X(std::vector<short>&)和X(std::deque<int>&)将控制权委托给了它。这样一来，我们就无须编写std::vector<short>和std::deque<int>版本的代理构造函数。后续增加委托构造函数也不需要修改代理构造函数，只需要保证参数类型支持迭代器就行了。

