# 12.1 冗余的构造函数

一个类有多个不同的构造函数在C++中是很常见的，例如：

```javascript
class X   
{   
public: X() : a_(0), b_(0.) { CommonInit(); } X(int a) : a_(a), b_(0.) { CommonInit(); } X(double b) : a_(0), b_(b) { CommonInit(); } X(int a, double b) : a_(a), b_(b) { CommonInit(); } private: void CommonInit(){ int a_; double b_; };
```

虽然这段代码在语法上没有任何问题，但是构造函数包含了太多重复代码，这使代码的维护变得困难。首先，类X需要在每个构造函数的初始化列表中初始化构造所有的成员变量，这段代码只有两个数据成员，而在现实代码编写中常常会有更多的数据成员或者更多的构造函数，那么在初始化列表中会有更多的重复内容，非常不利于代码的维护。其次，在构造函数主体中也有相同的情况，一旦类的构造过程需要依赖某个函数，那么所有构造函数的主体就需要调用这个函数，在例子中这个函数就是CommonInit。

也许有读者会提出将数据成员的初始化放到CommonInit函数里，从而减轻初始化列表代码冗余的问题，例如：

```txt
class X1   
public: X1(){CommonInit(0,0.）; } X1(int a){CommonInit(a，0.）; } X1(double b){CommonInit(0,b);} X1(int a,double b){CommonInit(a,b);} private: void CommonInit(int a,double b) {  $\mathrm{a}_{-} = \mathrm{a};$ $\mathrm{b}_{-} = \mathrm{b};$  1 int a; double b_;   
}；
```

以上代码在编译和运行上都没有问题，因为类x1的成员变量都是基本类型，所以在构造函数主体进行赋值也不会有什么问题。但是，如果成员函数中包含复杂的对象，那么就可能引发不确定问题，最好的情况是只影响类的构造效率，例如：

```cpp
class X2   
public: X2() { CommonInit(0, 0.); } X2(int a) { CommonInit(a, 0.); } X2(double b) { CommonInit(0, b); } X2(int a, double b) { CommonInit(a, b); } private: void CommonInit(int a, double b) { a_ = a; b_ = b; c_ = "hello world"; } int a_; double b_;
```

```cpp
std::string c_;   
}；
```

在上面的代码中，std::string类型的对象c_看似是在CommonInit函数中初始化为hello world，但是实际上它并不是一个初始化过程，而是一个赋值过程。因为对象的初始化过程早在构造函数主体执行之前，也就是初始化列表阶段就已经执行了。所以这里的c_对象进行了两次操作，一次为初始化，另一次才是赋值为hello world，很明显这样对程序造成了不必要的性能损失。另外，有些情况是不能使用函数主体对成员对象进行赋值的，比如禁用了赋值运算符的数据成员。

当然读者还可能会提出通过为构造函数提供默认参数的方法来解决代码冗余的问题，例如：

```cpp
class X3   
{   
public: X3(double b) : a_(0), b_(b) { CommonInit(); } X3(int a = 0, double b = 0.): a_(a), b_(b) { CommonInit(); } private: void CommonInit() {} int a_; double b_;   
};
```

这种做法的作用非常有限，可以看到上面这段代码，虽然通过默认参数的方式优化了两个构造函数，但是对于X3(double b)这个构造函数依然需要在初始化列表中重复初始化成员变量。另外，使用默认参数稍不注意就会引发二义性的问题，例如：

```txt
class X4   
{   
public: X4(int c) : a_(0), b_(0.), c_(c) { CommonInit(); } X4(double b) : a_(0), b_(b), c_(0) { CommonInit(); } X4(int a = 0, double b = 0., int c = 0) : a_(a), b_(b), c_(c) { CommonInit(); } private: void CommonInit() {} int a_; double b_; int c_;   
};   
int main()   
{ X4 x4(1);
```

以上代码无法通过编译，因为当main函数对x4进行构造时，编译器不知道应该调用x4(int c)还是x4(int a = 0, double b = 0., int c = 0)。所以让构造函数使用默认参数也不是一个好的解决方案。

现在读者可以看出其中的问题了，过去C++没有提供一种复用同类型构造函数的方法，也就是说无法让一个构造函数将初始化的一部分工作委托给同类型的另外一个构造函数。这种功能的缺失就造成了程序员不得不编写重复烦琐代码的困境，更进一步来说它也造成了代码维护性下降。比如，如果想在类x中增加一个数据成员d_，那么就必须在4个构造函数的初始化列表中初始化成员变量d_，修改和删除也一样。

