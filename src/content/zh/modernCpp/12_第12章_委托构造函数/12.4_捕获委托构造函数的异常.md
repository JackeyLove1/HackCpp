# 12.4 捕获委托构造函数的异常

当使用Function-try-block去捕获委托构造函数异常时，其过程和捕获初始化列表异常如出一辙。如果一个异常在代理构造函数的初始化列表或者主体中被抛出，那么委托构造函数的主体将不再被执行，与之相对的，控制权会交到异常捕获的catch代码块中：

```txt
include<iostream>   
class X   
public: X()try:X(0){
```

```cpp
catch (int e)   
{ std::cout << "catch:" << e << std::endl; throw 3;   
} X(int a) try : X(a, 0.) {} catch (int e) { std::cout << "catch:" << e << std::endl; throw 2; } X(double b) : X(0, b) {} X(int a, double b) : a_(a), b_(b) { throw 1; } private: int a_; double b_;   
};   
int main()   
{ try { X x; } catch (int e) { std::cout << "catch:" << e << std::endl; }
```

编译运行以上代码，输出结果如下：

```yaml
catch: 1  
catch: 2  
catch: 3
```

由于这段代码是一个链式委托构造，X()委托到X(int a), X(int a)委托到X(int a, double b)。因此在X(int a, double b)发生异常的时候，会以相反的顺序抛出异常。

