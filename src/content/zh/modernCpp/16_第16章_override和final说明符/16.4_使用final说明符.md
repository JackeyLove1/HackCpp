# 16.4 使用final说明符

在C++中，我们可以为基类声明纯虚函数来迫使派生类继承并且重写这个纯虚函数。但是一直以来，C++标准并没有提供一种方法来阻止派生类去继承基类的虚函数。C++11标准引入final说明符解决了上述问题，它告诉编译器该虚函数不能被派生类重写。final说明符用法和override说明符相同，需要声明在虚函数的尾部。

```javascript
class Base { public: virtual void foo(int x){ }; class Derived :public Base { public: void foo(int x) final {}; class Derived2 :public Derived{ public: void foo(int x){};
```

在上面的代码中，因为基类Derived的虚函数foo声明为final，所以派生类Derived2重写foo函数的时候编译器会给出错误提示。请注意final和override说明符的一点区别，final说明符可以修饰最底层

基类的虚函数而override则不行，所以在这个例子中final可以声明基类Base的虚函数foo，只不过我们通常不会这样做。

有时候，override和final会同时出现。这种情况通常是由中间派生类继承基类后，希望后续其他派生类不能修改本类虚函数的行为而产生的，举个例子：

```cpp
class Base { public: virtual void log(const char \*) const \{...\} virtual void foo(int x) \{\};   
class BaseWithFileLog : public Base { public: virtual void log(const char \*) const override final \{...\}   
class Derived : public BaseWithFileLog { public: void foo(int x) \{\};
```

在上面这段代码中基类Base有一个虚函数log，它将日志打印到标准输出。但是为了能更好地保存日志，我们写了一个派生类BaseWithFileLog，重写了log函数将日志写入文件中。为了保证重写不会出现错误，并且后来的继承者不要改变日志的行为，为log函数添加了override和final说明符。这样一来，后续的派生类Derived只能重写虚函数foo而无法修改日志函数，保证了日志的一致。

最后要说明的是，final说明符不仅能声明虚函数，还可以声明类。如果在类定义的时候声明了final，那么这个类将不能作为基类被

其他类继承，例如：

```txt
class Base final { public: virtual void foo(int x){ };   
class Derived :public Base { public: void foo(int x){};   
}；
```

在上面的代码中，由于Base被声明为final，因此Derived继承Base会在编译时出错。

