# 16.3 使用override说明符

可以看到重写如此容易出错，光靠人力排查避免出错是很困难的，尤其当类的继承关系非常复杂的时候。所以C++11标准提供了一个非常实用的override说明符，这个说明符必须放到虚函数的尾部，它明确告诉编译器这个虚函数需要覆盖基类的虚函数，一旦编译器发现该虚函数不符合重写规则，就会给出错误提示。

```txt
class Base {   
public: virtual void some_func() {} virtual void foo(int x) {} virtual void bar() const {} void baz(){};   
class Derived : public Base {   
public: virtual void sone_func() override {} virtual void foo(int &x) override {} virtual void bar() override {} virtual void baz() override {} };
```

上面这段代码示例针对16.2节中的示例在派生类虚函数尾部都加上了override说明符，编译后编译器给出了4条错误信息，明确指出这4个函数都无法重写。如此一来，我们可以轻松地找到代码中的错误，而不必等到运行时再慢慢调试排查。override说明符不仅为派生类的编写者提供了方便，对于基类编写者同样也有帮助。假设某个基类需要

修改虚函数的形参以确保满足新需求，那么在override的帮助下，基类编写者可以轻松地发现修改基类虚函数的代价。如果没有override说明符，则修改基类虚函数将面临很大的风险，因为编译器不会给出错误提示，我们只能靠测试来检查问题所在。

