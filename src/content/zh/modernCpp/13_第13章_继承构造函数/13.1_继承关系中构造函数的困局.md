# 13.1 继承关系中构造函数的困局

相信读者在编程经历中一定遇到过下面的问题，假设现在有一个类Base提供了很多不同的构造函数。某一天，你发现Base无法满足未来业务需求，需要把Base作为基类派生出一个新类Derived并且对某些函数进行改造以满足未来新的业务需求，比如下面的代码：

```csv
class Base {   
public: Base(  $\mathbf{\rho}$  0),y(0.）{}; Base(int x,double y):x_(x),y_(y){} Base(int x):x_(x),y_(0.){} Base(double y):x_(0),y_(y){} void SomeFunc(){   
private: int x_; double y_;   
};   
class Derived : public Base{   
public: Derived(  $\mathbf{\rho}$  {} Derived(int x,double y):Base(x,y){} Derived(int x):Base(x){} Derived(double y):Base(y){} void SomeFunc(){   
}；
```

基类Base的SomeFunc无法满足当前的业务需求，于是在其派生类Derived中重写了这个函数，但令人头痛的是，面对Base中大量的构造函数，我们不得不在Derived中定义同样多的构造函数，目的

仅仅是转发构造参数，因为派生类本身并没有需要初始化的数据成员。单纯地转发构造函数不仅会导致代码的冗余，而且大量重复的代码也会让程序更容易出错。实际上，这个工作完全可以让编译器自动完成，因为它实在太简单了，让编译器代劳不仅消除了代码冗余而且意图上也更加明确。

