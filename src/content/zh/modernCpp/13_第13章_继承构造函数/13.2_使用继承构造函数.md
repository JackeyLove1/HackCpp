# 13.2 使用继承构造函数

我们都知道C++中可以使用using关键字将基类的函数引入派生类，比如：

```cpp
class Base { public: void foo(int) {} };   
class Derived :public Base { public: using Base::foo; void foo(char\*）{} };   
int main() { Derived d; d.foo(5); }
```

C++11的继承构造函数正是利用了这一点，将using关键字的能力进行了扩展，使其能够引入基类的构造函数：

```txt
class Base { public: Base(  $\mathbf{\rho}:$  x_(0),y_(0.)  $\{\}$  ： Base(intx,doubley):x_(x)，y_(y）{} Base(intx):x_(x)，y_(0.){}
```

```cpp
Base(double y) : x_(0), y_(y) {}  
private:  
    int x_;  
    double y_;  
};  
class Derived : public Base {  
public:  
    using Base::Base;  
};
```

在上面的代码中，派生类Derived使用using Base::Base让编译器为自己生成转发到基类的构造函数，从结果上看这种实现方式和前面人工编写代码转发构造函数没有什么区别，但是在过程上代码变得更加简洁易于维护了。

使用继承构造函数虽然很方便，但是还有6条规则需要注意。

1. 派生类是隐式继承基类的构造函数，所以只有在程序中使用了这些构造函数，编译器才会为派生类生成继承构造函数的代码。  
2. 派生类不会继承基类的默认构造函数和复制构造函数。这一点乍看有些奇怪，但仔细想想也是顺理成章的。因为在C++语法规则中，执行派生类默认构造函数之前一定会先执行基类的构造函数。同样的，在执行复制构造函数之前也一定会先执行基类的复制构造函数。所以继承基类的默认构造函数和默认复制构造函数的做法是多余的，这里不会这么做。  
3. 继承构造函数不会影响派生类默认构造函数的隐式声明，也就是说对于继承基类构造函数的派生类，编译器依然会为其自动生成默认构造函数的代码。

4. 在派生类中声明签名相同的构造函数会禁止继承相应的构造函数。这一条规则不太好理解，让我们结合代码来看一看：

```cpp
class Base {   
public: Base() : x_(0), y_(0) {}; Base(int x, double y) : x_(x), y_(y) {} Base(int x) : x_(x), y_(0.) { std::cout << "Base(int x)" << std::endl; } Base(double y) : x_(0), y_(y) { std::cout << "Base(double y)" << std::endl; } private: int x_; double y_; }; class Derived : public Base { public: using Base::Base; Derived(int x) { std::cout << "Derived(int x)" << std::endl; } }; int main() { Derived d(5); Derived d1(5.5); }
```

在上面的代码中，派生类Derived使用using Base::Base继承了基类的构造函数，但是由于Derived定义了构造函数Derived(int x)，该函数的签名与基类的构造函数Base(int x)相同，因此这个构造函数的继承被禁止了，Derived d(5)会调用派生类的构造函数并且输出"Derived(int x)"。另外，这个禁止动作并不会影响到其他签名的构造函数，Derived d1(5.5)依然可以成功地使用基类的构造函数进行构造初始化。

5. 派生类继承多个签名相同的构造函数会导致编译失败:

```cpp
class Base1 {
public:
    Base1(int) { std::cout << "Base1(int x)" << std::endl; };
};
class Base2 {
public:
    Base2(int) { std::cout << "Base2(int x)" << std::endl; };
};
class Derived : public Base1, Base2 {
public:
    using Base1::Base1;
    using Base2::Base2;
};
int main()
{
Derived d(5);
}
```

在上面的代码中，Derived继承了两个类Base1和Base2，并且继承了它们的构造函数。但是由于这两个类的构造函数Base1(int)和Base2(int)拥有相同的签名，导致编译器在构造对象的时候不知道应该使用哪一个基类的构造函数，因此在编译时给出一个二义性错误。

6. 继承构造函数的基类构造函数不能为私有:

```cpp
class Base {
    Base(int) {}
public:
        Base(double) {}
};
class Derived : public Base {
public:
    using Base::Base;
};
int main()
{
```

```txt
Derived d(5.5);  
Derived d1(5);  
}
```

在上面的代码中，Derived d1(5)无法通过编译，因为它对应的基类构造函数Base(int)是一个私有函数，Derived d(5.5)则没有这个问题。

最后再介绍一个有趣的问题，在早期的C++11编译器中，继承构造函数会把基类构造函数注入派生类，于是导致了这样一个问题：

```cpp
include<iostream>   
struct Base{ Base()  $=$  default; template<typename T>Base(T，typenameT::type  $= 0$  1 std::cout<<"Base(T，typenameT::type)"<<std::endl; } Base(int){std::cout<<"Base(int)"<<std::endl;}   
};   
struct Derived:Base{ using Base::Base; Derived(int){std::cout<<"Derived(int)"<<std::endl;} }； int main(){ Derived d(42L);
```

上面这段代码用早期的编译器（比如GCC 6.4）编译运行的输出结果是Base(int)，而用新的GCC编译运行的输出结果是Derived(int)。在老的版本中，template<typename T> Base(T, typename T::type = 0)被注入派生类中，形成了这样两个构造函数：

```cpp
template<typename T> Derived(T);
template<typename T> Derived(T, typename T::type);
```

这是因为继承基类构造函数时，不会继承默认参数，而是在派生类中注入带有各种参数数量的构造函数的重载集合。于是，编译器理所当然地选择推导Derived(T)为Derived(long)作为构造函数。在构造基类时，由于Base(long, typename long::type = 0)显然是一个非法的声明，因此编译器选择使用Base(int)作为基类的构造函数。最终结果就是我们看到的输出了Base(int)。而在新版本中继承构造函数不会注入派生类，所以不存在这个问题，编译器会直接使用派生类的Derived(int)构造函数构造对象。

