# 22.2 别名模板

前面我们已经了解到使用using定义别名的基本用法，但是显然 $\mathrm{C}++$  委员会不会因为这点内容就添加一个新的关键字。事实上using还承担着一个更加重要的特性——别名模板。所谓别名模板本质上也应该是一种模板，它的实例化过程是用自己的模板参数替换原始模板的模板参数，并实例化原始模板。定义别名模板的语法和定义类型别名并没有太大差异，只是多了模板形参列表：

```txt
template < template-parameter-list>
using identifier = type-id;
```

其中 template-parameter-list 是模板的形参列表，而 identifier 和 type-id 是别名类模板型名和原始类模板型名。下面来看一个例子：

```cpp
include <map> #include <string> template<class T> using int_map  $\equiv$  std::map<int,T>; int main() { int_map<std::string> int2string;
```

```javascript
int2string[11] = "7";
```

在上面的代码中，int_map是一个别名模板，它有一个模板形参。当int_map发生实例化的时候，模板的实参std::string会替换std::map<int, T>中的T，所以真正实例化的类型是std::map<int, std::string>。通过这种方式，我们可以在模板形参比较多的时候简化模板形参。

看到这里，有模板元编程经验的读者可能会提出 typedef 其实也能做到相同的事情。没错，我们是可以用 typedef 来改写上面的代码：

```cpp
include <map>   
#include <string>   
template<class T>   
struct int_map{ typedef std::map<int,T> type;   
}；   
int main() { int map<std::string>::type int2string; int2string[11]  $= 7$  "；   
}
```

以上代码使用 typedef 和类型嵌套的方案也能达到同样的目的。不过很明显这种方案要复杂不少，不仅要定义一个 int_map 的结构体类型，还需要在类型里使用 typedef 来定义目标类型，最后必须使用 int_map<std::string>::type 来声明变量。除此之外，如果遇上了待决的类型，还需要在变量声明前加上 typename 关键字：

```cpp
template<class T> struct int_map {
    typedef std::map<int, T> type;
}; template<class T> struct X {
    typename int_map<T>::type int2other; // 必须带有typename关键字，否则编译错误
};
```

在上面这段代码中，类模板x没有确定模板形参T的类型，所以int_map<T>::type是一个未决类型，也就是说int_map<T>::type既有可能是一个类型，也有可能是一个静态成员变量，编译器是无法处理这种情况的。这里的typename关键字告诉编译器应该将int_map<T>::type作为类型来处理。而别名模板不会有::type的困扰，当然也不会有这样的问题了：

```cpp
template<class T> using int_map = std::map<int, T>;  
template<class T> struct X { int_map<T> int2other; //编译成功，别名模板不会有任何问题};
```

值得一提的是，虽然别名模板有很多 typedef不具备的优势，但是C++11标准库中的模板元编程函数都还是使用的 typedef和类型嵌套的方案，例如：

```c
template bool, typename _Tp = void> struct enable_if { };
template<typename _Tp> struct enable_if(true, _Tp> { typedef _Tp type; };
```

不过这种情况在C++14中得到了改善，在C++14标准库中模板元编程函数已经有了别名模板的版本。当然，为了保证与老代码的兼容性，typedef的方案依然存在。别名模板的模板元编程函数使用_t作为其名称的后缀以示区分：

```txt
template bool _Cond, typename _Tp = void> using enable_if_t = typename enable_if_<Cond, _Tp>::type;
```

