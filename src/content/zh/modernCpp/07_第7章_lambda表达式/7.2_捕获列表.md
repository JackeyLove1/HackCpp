# 7.2 捕获列表

在lambda表达式的语法中，与传统C++语法差异最大的部分应该算是捕获列表了。实际上，除了语法差异较大之外，它也是lambda表达式中最为复杂的一个部分。接下来我们会把捕获列表分解开来逐步讨论其特性。

# 7.2.1 作用域

我们必须了解捕获列表的作用域，通常我们说一个对象在某一个作用域内，不过这种说法在捕获列表中发生了变化。捕获列表中的变量存在于两个作用域——lambda表达式定义的函数作用域以及lambda表达式函数体的作用域。前者是为了捕获变量，后者是为了使用变量。另外，标准还规定能捕获的变量必须是一个自动存储类型。简单来说就是非静态的局部变量。让我们看一看下面的例子：

```latex
int  $\mathbf{x} = 0$    
int main()   
{ int  $\mathrm{y} = 0$  static int  $\mathrm{z} = 0$  auto foo  $=$  [x，y,z]{};
```

以上代码可能是无法通过编译的，其原因有两点：第一，变量x和z不是自动存储类型的变量；第二，x不存在于lambda表达式定义的作用域。这里可能无法编译，因为不同编译器对于这段代码的处理会有所不同，比如GCC就不会报错，而是给出警告。那么如果想在lambda表达式中使用全局变量或者静态局部变量该怎么办呢？马上能想到的

办法是用参数列表传递全局变量或者静态局部变量，其实不必这么麻烦，直接用就行了，来看一看下面的代码：

```cpp
include<iostream>   
int  $\mathrm{x} = 1$    
int main()   
{ int  $\mathrm{y} = 2$  static int  $\mathrm{z} = 3$  auto foo  $=$  [y] { return x  $^+$  y  $^+$  z;}; std::cout<<foo()<<std::endl;
```

在上面的代码中，虽然我们没有捕获变量x和z，但是依然可以使用它们。进一步来说，如果我们将一个lambda表达式定义在全局作用域，那么lambda表达式的捕获列表必须为空。因为根据上面提到的规则，捕获列表的变量必须是一个自动存储类型，但是全局作用域并没有这样的类型，比如：

```txt
int  $\mathbf{x} = 1$    
auto foo  $= []$  {return x;};   
int main()   
{ foo();
```

# 7.2.2 捕获值和捕获引用

捕获列表的捕获方式分为捕获值和捕获引用，其中捕获值的语法我们已经在前面的例子中看到了，在[]中直接写入变量名，如果有多个变量，则用逗号分隔，例如：

```txt
int main()   
{ int  $\mathrm{x} = 5$  ，y  $= 8$  auto foo  $\equiv$  [x，y] {return x\* y;};   
1
```

捕获值是将函数作用域的x和y的值复制到lambda表达式对象的内部，就如同lambda表达式的成员变量一样。

捕获引用的语法与捕获值只有一个&的区别，要表达捕获引用我们只需要在捕获变量之前加上&，类似于取变量指针。只不过这里捕获的是引用而不是指针，在lambda表达式内可以直接使用变量名访问变量而不需解引用，比如：

```c
int main()   
{ int  $\mathrm{x} = 5$  ，y  $= 8$  auto foo  $\equiv$  [&x，&y] { return x\* y; }
```

上面的两个例子只是读取变量的值，从结果上看两种捕获没有区别，但是如果加入变量的赋值操作，情况就不同了，请看下面的例子：

```cpp
void bar1()
{
    int x = 5, y = 8;
    auto foo = [x, y] {
        x += 1; //编译失败，无法改变捕获变量的值
        y += 2; //编译失败，无法改变捕获变量的值
        return x * y;
    };
    std::cout << foo() << std::endl;
}
```

```cpp
auto foo = [&x, &y] {
    x += 1;
    y += 2;
    return x * y;
}; std::cout << foo() << std::endl; }
```

在上面的代码中函数bar1无法通过编译，原因是我们无法改变捕获变量的值。这就引出了lambda表达式的一个特性：捕获的变量默认为常量，或者说lambda是一个常量函数（类似于常量成员函数）。bar2函数里的lambda表达式能够顺利地通过编译，虽然其函数体内也有改变变量x和y的行为。这是因为捕获的变量默认为常量指的是变量本身，当变量按值捕获的时候，变量本身就是值，所以改变值就会发生错误。相反，在捕获引用的情况下，捕获变量实际上是一个引用，我们在函数体内改变的并不是引用本身，而是引用的值，所以并没有被编译器拒绝。

另外，还记得上文提到的可选说明符mutable吗？使用mutable说明符可以移除lambda表达式的常量性，也就是说我们可以在lambda表达式的函数体中修改捕获值的变量了，例如：

```cpp
void bar3()
{
    int x = 5, y = 8;
    auto foo = [x, y] () mutable {
        x += 1;
        y += 2;
        return x * y;
    };
    std::cout << foo() << std::endl;
}
```

以上代码可以通过编译，也就是说lambda表达式成功地修改了其作用域内的x和y的值。值得注意的是，函数bar3相对于函数bar1除了增加说明符mutable，还多了一对()，这是因为语法规定lambda表达式如果存在说明符，那么形参列表不能省略。

编译运行bar2和bar3两个函数会输出相同的结果，但这并不代表两个函数是等价的，捕获值和捕获引用还是存在着本质区别。当 lambda表达式捕获值时，表达式内实际获得的是捕获变量的复制，我们可以任意地修改内部捕获变量，但不会影响外部变量。而捕获引用则不同，在lambda表达式内修改捕获引用的变量，对应的外部变量也会被修改：

```cpp
include<iostream>   
int main()   
{ int  $\mathrm{x} = 5$  ，y  $= 8$  ： auto foo  $=$  [x,&y] () mutable { x  $+ = 1$  ： y  $+ = 2$  std::cout<<"lambda  $\mathbf{x} = \mathbf{"}\ll \mathbf{x}\ll \mathbf{"}$  ，y  $=$  "<<y<< std::endl; return  $\texttt{x}^{\star}\texttt{y};$  ）; foo(); std::cout<<"call1 x  $=$  "<<x<<"，y  $=$  "<<y<<std::endl; foo(); std::cout<<"call2 x  $=$  "<<x<<"，y  $=$  "<<y<<std::endl; }
```

运行结果如下:

```txt
lambda x = 6, y = 10  
call1 x = 5, y = 10  
lambda x = 7, y = 12  
call2 x = 5, y = 12
```

观察上面这段代码的运行结果会发现，由于x是捕获值的变量，因此无论在lambda表达式内如何改变x的值，其外部作用域的变量都不会发生变化（一直保持为5）。而捕获引用的变量y会随着lambda表达式内的改变而改变。进一步审视x值的变化会发现另一个有趣的事实，虽然在lambda表达式内修改x不会影响外部x的值，但是它却能影响下次调用lambda表达式时x的值。更具体来说，当第一次调用foo的时候，x的值从5增加到6，这个状态持续到第二次调用foo，然后将x的值从6增加到7。

对于捕获值的lambda表达式还有一点需要注意，捕获值的变量在lambda表达式定义的时候已经固定下来了，无论函数在lambda表达式定义后如何修改外部变量的值，lambda表达式捕获的值都不会变化，例如：

```cpp
include<iostream>   
int main()   
{ int  $\mathrm{x} = 5$  ，y  $= 8$  auto foo  $\equiv$  [x,&y]() mutable { x  $+ = 1$  y  $+ = 2$  std::cout<<"lambda  $\mathbf{x} = \mathbf{"}$  <<x<<"，y  $=$  "<<y<< std::endl; return  $\texttt{x}^{\star}\texttt{y};$  }；  $\mathrm{x} = 9$  ：  $\mathrm{y} = 20$  ： foo();   
}
```

运行结果如下:

```txt
lambda x = 6, y = 22
```

在上面的代码中，虽然在调用foo之前分别修改了x和y的值，但是捕获值的变量x依然延续着lambda定义时的值，而在捕获引用的变量y被重新赋值以后，lambda表达式捕获的变量y的值也跟着发生了变化。

# 7.2.3 特殊的捕获方法

lambda表达式的捕获列表除了指定捕获变量之外还有3种特殊的捕获方法。

1. [this] —— 捕获this指针，捕获this指针可以让我们使用this类型的成员变量和函数。  
2.  $[=]$  —— 捕获lambda表达式定义作用域的全部变量的值，包括 this。  
3. [&] —— 捕获lambda表达式定义作用域的全部变量的引用，包括this。

首先来看看捕获this的情况：

```cpp
include<iostream>   
class A   
{   
public: void print() { std::cout << "class A" << std::endl; } void test() {
```

```txt
auto foo = [this] { print(); x = 5; }; foo(); } private: int x; }; int main() { A a; a.test(); }
```

在上面的代码中，因为lambda表达式捕获了this指针，所以可以在lambda表达式内调用该类型的成员函数print或者使用其成员变量x。

捕获全部变量的值或引用则更容易理解：

```cpp
include<iostream>   
int main()   
{ int  $\mathrm{x} = 5$  ，y  $= 8$  auto foo  $= [ = ]$  {return x \* y;}; std::cout<<foo()<<std::endl;
```

以上代码并没有指定需要捕获的变量，而是使用  $[=]$  捕获所有变量的值，这样在lambda表达式内也能访问x和y的值。同理，使用&&也会有同样的效果，读者不妨自己尝试一下。

