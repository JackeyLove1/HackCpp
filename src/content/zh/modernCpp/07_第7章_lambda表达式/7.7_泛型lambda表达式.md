# 7.7 泛型lambda表达式

C++14标准让lambda表达式具备了模版函数的能力，我们称它为泛型lambda表达式。虽然具备模版函数的能力，但是它的定义方式却用不到template关键字。实际上泛型lambda表达式语法要简单很多，我们只需要使用auto占位符即可，例如：

```txt
int main() {
```

```txt
auto foo = [] (auto a) { return a; }; int three = foo(3); char const* hello = foo("hello"); }
```

由于泛型lambda表达式更多地利用了auto占位符的特性，而lambda表达式本身并没有什么变化，因此想更多地理解泛型lambda表达式，可以阅读第3章，这里就不再赘述了。

# 7.8 常量lambda表达式和捕获\*this

C++17标准对lambda表达式同样有两处增强，一处是常量lambda表达式，另一处是对捕获\*this的增强。其中常量lambda表达式的主要特性体现在constexpr关键字上，请阅读constexpr的有关章节来掌握常量lambda表达式的特性，这里主要说明一下对于捕获this的增强。

还记得前面初始化捕获\*this对象的代码吗？我们在捕获列表内复制了一份this指向的对象到tmp，然后使用tmp的value。没错，这样做确实解决了异步问题，但是这个解决方案并不优美。试想一下，如果在lambda表达式中用到了大量this指向的对象，那我们就不得不将它们全部修改，一旦遗漏就会引发问题。为了更方便地复制和使用\*this对象，C++17增加了捕获列表的语法来简化这个操作，具体来说就是在捕获列表中直接添加\*this]，然后在lambda表达式函数体内直接使用this指向对象的成员，还是以前面的Work类为例：

```txt
class Work { private: int value;
```

```cpp
public: Work():value(42){} std::future<int> spawn() { return std::async([=，\*this](->int{return value;});   
};
```

在上面的代码中没有再使用tmp=*this来初始化捕获列表，而是直接使用*this。在lambda表达式内也没有再使用tmp.value而是直接返回了value。编译运行这段代码可以得到预期的结果42。从结果可以看出，[*this]的语法让程序生成了一个*this对象的副本并存储在lambda表达式内，可以在lambda表达式内直接访问这个复制对象的成员，消除了之前lambda表达式需要通过tmp访问对象成员的尴尬。

# 7.9 捕获  $[\equiv, \text{this}]$

在C++20标准中，又对lambda表达式进行了小幅修改。这一次修改没有加强lambda表达式的能力，而是让this指针的相关语义更加明确。我们知道  $[=]$  可以捕获this指针，相似的， $[=,\text{*this}]$  会捕获this对象的副本。但是在代码中大量出现  $[=]$  和  $[=,\text{*this}]$  的时候我们可能很容易忘记前者与后者的区别。为了解决这个问题，在C++20标准中引入了  $[=,\text{this}]$  捕获this指针的语法，它实际上表达的意思和  $[=]$  相同，目的是让程序员们区分它与  $[=,\text{*this}]$  的不同：

```txt
\[
\left[ = , \text{this}\right]\{\}; // \mathrm{C} + + 17 \text{编译报错或者报警告，} \mathrm{C} + + 20 \text{成功编译}
\]
```

虽然在  $\mathrm{C} + + 17$  标准中认为  $[= ,\mathrm{this}]\{\}$  ;是有语法问题的，但是实践中GCC和CLang都只是给出了警告而并未报错。另外，在  $\mathrm{C} + + 20$  标准中

还特别强调了要用  $\left[ = ,\text{this}\right]$  代替  $\left[ = \right]$ , 如果用GCC编译下面这段代码:

```txt
template<class T> void g(T) {}
struct Foo {
    int n = 0;
    void f(int a) {
        g([[=](int k) { return n + a * k; });
    }
};
```

编译器会输出警告信息，表示标准已经不再支持使用[=]隐式捕获this指针了，提示用户显式添加this或者\*this。最后值得注意的是，同时用两种语法捕获this指针是不允许的，比如：

```txt
[this, \*this]{};
```

这种写法在CLang中一定会给出编译错误，而GCC则稍显温柔地给出警告，在我看来这种写法没有意义，是应该避免的。

