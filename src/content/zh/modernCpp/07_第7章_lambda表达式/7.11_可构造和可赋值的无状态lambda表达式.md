# 7.11 可构造和可赋值的无状态lambda表达式

在7.4节中我们提到了无状态lambda表达式可以转换为函数指针，但遗憾的是，在C++20标准之前无状态的lambda表达式类型既不能构造也无法赋值，这阻碍了许多应用的实现。举例来说，我们已经了解了像std::sort和std::find_if这样的函数需要一个函数对象或函数指针来辅助排序和查找，这种情况我们可以使用lambda表达式完成任务。但是如果遇到std::map这种容器类型就不好办了，因为std::map的比较函数对象是通过模板参数确定的，这个时候我们需要的是一个类型：

```txt
auto greater  $=$  [] (auto x, auto y) { return  $\mathrm{x} > \mathrm{y}$  ;}; std::map<std::string, int, decltype(greater)> mymap;
```

这段代码的意图很明显，它首先定义了一个无状态的lambda表达式greater，然后使用decltype(greater)获取其类型作为模板实参传入模

板。这个想法非常好，但是在C++17标准中是不可行的，因为lambda表达式类型无法构造。编译器会明确告知，lambda表达式的默认构造函数已经被删除了（“note:a lambda closure type has a deleted default constructor”）。

除了无法构造，无状态的lambda表达式也没办法赋值，比如：

```cpp
auto greater  $=$  [] (auto x, auto y) { return  $\mathrm{x} > \mathrm{y}$  ;}; std::map<std::string, int,ocltype(greater)> mymap1, mymap2; mymap1  $=$  mymap2;
```

这里mymap1 = mymap2; 也会被编译器报错，原因是复制赋值函数也被删除了（“note: a lambda closure type has a deleted copy assignment operator”）。

为了解决以上问题，C++20标准允许了无状态lambda表达式类型的构造和赋值，所以使用C++20标准的编译环境来编译上面的代码是可行的。

