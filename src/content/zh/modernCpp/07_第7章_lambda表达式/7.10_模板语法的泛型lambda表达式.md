# 7.10 模板语法的泛型lambda表达式

在7.7节中我们讨论了C++14标准中lambda表达式通过支持auto来实现泛型。大部分情况下，这是一种不错的特性，但不幸的是，这种语法也会使我们难以与类型进行互动，对类型的操作变得异常复杂。用提案文档的举例来说：

```cpp
template <typename T> struct is_std_vector : std::false_type { };
template <typename T> struct is_std_vector<std::vector<T>> : std::true_type {});
auto f = [[](auto vector) {
    static_assert(is_std_vector<decltype.vector>)::value, ""};
};
```

普通的函数模板可以轻松地通过形参模式匹配一个实参为vector的容器对象，但是对于lambda表达式，auto不具备这种表达能力，所以不得不实现is_std_vector，并且通过static_assert来辅助判断实参的真实类型是否为vector。在C++委员会的专家看来，把一个本可以通过模板推导完成的任务交给static_assert来完成是不合适的。除此之外，这样的语法让获取vector存储对象的类型也变得十分复杂，比如：

```cpp
auto f = [] (auto vector) {
using T = typenameoclntype.vector)::value_type;
// ...
};
```

当然，能这样实现已经是很侥幸了。我们知道vector容器类型会使用内嵌类型value_type表示存储对象的类型。但我们并不能保证面对的所有容器都会实现这一规则，所以依赖内嵌类型是不可靠的。

进一步来说，decltype(obj)有时候并不能直接获取我们想要的类型。不记得decltype推导规则的读者可以复习一下前面的章节，这里就直接说明示例代码：

```cpp
auto f = [] (const auto& x) {
using T = recltype(x);
T copy = x; // 可以编译，但是语义错误
using Iterator = typename T::iterator; // 编译错误
};
std::vector<int> v;
f(v);
```

请注意，在上面的代码中，decltype(x)推导出来的类型并不是std::vector，而是const std::vector &, 所以T copy = x; 不是一个复制而

是引用。对于一个引用类型来说，T::iterator也是不符合语法的，所以编译出错。在提案文档中，作者很友好地给出了一个解决方案，他使用了STL的decay，这样就可以将类型的cv以及引用属性删除，于是就有了以下代码：

```cpp
auto f = [] (const auto& x) {
using T = std::decay_t<decltype(x)];
T copy = x;
using Iterator = typename T::iterator;
};
```

问题虽然解决了，但是要时刻注意auto，以免给代码带来意想不到的问题，况且这都是建立在容器本身设计得比较完善的情况下才能继续下去的。

鉴于以上种种问题，C++委员会决定在C++20中添加模板对lambda的支持，语法非常简单：

```json
[ ] <typename T > (T t) {}
```

于是，上面那些让我们为难的例子就可以改写为：

```txt
auto f = []; <typename T>(std::vector<T> vector) { // ... }
```

以及

```cpp
auto f = []; <typename T>(T const& x) { T copy = x; using Iterator = typename T::iterator; };
```

上面的代码是否能让读者眼前一亮？这些代码不仅简洁了很多，而且也更符合C++泛型编程的习惯。

最后再说一个有趣的故事，事实上早在2012年，让lambda支持模板的提案文档N3418已经提交给了C++委员会，不过当时这份提案并没有被接受，到2013年N3559中提出的基于auto的泛型在C++14标准中实现，而2017年lambda支持模板的提案又一次被提出来，这一次可以说是踩在N3559的肩膀上成功地加入了C++20标准。回过头来看整个过程，虽说算不上曲折，但也颇为耐人寻味，C++作为一个发展近30年的语言，依然在不断地探索和纠错中砺志前行。

