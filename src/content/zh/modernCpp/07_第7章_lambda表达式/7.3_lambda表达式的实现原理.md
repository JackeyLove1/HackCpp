# 7.3 lambda表达式的实现原理

如果读者是一个C++的老手，可能已经发现lambda表达式与函数对象（仿函数）非常相似，所以让我们从函数对象开始深入探讨lambda表达式的实现原理。请看下面的例子：

```cpp
include<iostream>   
class Bar   
{   
public: Bar(int x, int y): x_(x), y_(y) {} int operator () { return x_ \* y_;   
}   
private: int x_; int y_;   
};   
int main()   
{ int  $x = 5$  ，y  $= 8$  auto foo  $=$  [x，y] { return x \* y; }； Bar bar(x，y); std::cout<< "foo()  $=$  "<< foo()<< std::endl; std::cout<< "bar()  $=$  "<< bar()<< std::endl;
```

在上面的代码中，foo是一个lambda表达式，而bar是一个函数对象。它们都能在初始化的时候获取main函数中变量x和y的值，并在调用之后返回相同的结果。这两者比较明显的区别如下。

1. 使用lambda表达式不需要我们去显式定义一个类，这一点在快速实现功能上有较大的优势。  
2. 使用函数对象可以在初始化的时候有更加丰富的操作，例如Bar bar(x+y, x * y)，而这个操作在C++11标准的lambda表达式中是不允

许的。另外，在Bar初始化对象的时候使用全局或者静态局部变量也是没有问题的。

这样看来在  $\mathrm{C} + + 11$  标准中，lambda表达式的优势在于书写简单方便且易于维护，而函数对象的优势在于使用更加灵活不受限制，但总的来说它们非常相似。而实际上这也正是lambda表达式的实现原理。

lambda表达式在编译期会由编译器自动生成一个闭包类，在运行时由这个闭包类产生一个对象，我们称它为闭包。在C++中，所谓的闭包可以简单地理解为一个匿名且可以包含定义时作用域上下文的函数对象。现在让我们抛开这些概念，观察lambda表达式究竟是什么样的子的。

首先，定义一个简单的lambda表达式：

```cpp
include<iostream>   
int main()   
{ int  $\mathrm{x} = 5$  ，y  $= 8$  auto foo  $= [ = ]$  {return x\* y;}; int z  $=$  foo();   
1
```

接着，我们用GCC输出其GIMPLE的中间代码：

```txt
main ()   
{ int D.39253; { int x; int y; struct _lambda0 foo; typedef struct _lambda0 _lambda0; int z;
```

```txt
try {  $\mathrm{x} = 5$  .  $\mathrm{y} = 8$  . foo._x=x; foo._y=y; z  $=$  main(）::<lambda()>：operator（&foo); } finally { foo  $=$  {CLOBBER}; } D.39253  $= 0$  return D.39253;   
}   
main(）::<lambda()>：operator(） (const struct _lambda0\* const _closure) { int D.39255; const int x [value-expr: _closure->_x]; const int y [value-expr: _closure->_y];  $\underline{1} =$  _closure->_x;  $\underline{2} =$  _closure->_y; D.39255  $= \underline{1}\ast \underline{2}$  return D.39255;   
}
```

从上面的中间代码可以看出lambda表达式的类型名为__lambda0，通过这个类型实例化了对象foo，然后在函数内对foo对象的成员_x和_y进行赋值，最后通过自定义的()运算符对表达式执行计算并将结果赋值给变量z。在这个过程中，__lambda0是一个拥有operator()自定义运算符的结构体，这也正是函数对象类型的特性。所以，在某种程度上来说，lambda表达式是C++11给我们提供的一块语法糖而已，lambda表达式的功能完全能够手动实现，而且如果实现合理，代码在运行效率上也不会有差距，只不过实用lambda表达式让代码编写更加轻松了。

