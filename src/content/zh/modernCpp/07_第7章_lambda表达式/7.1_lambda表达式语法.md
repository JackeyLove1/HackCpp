# 7.1 lambda表达式语法

lambda表达式是现代编程语言的一个基础特性，比如LISP、Python、C#等具备该特性。但是遗憾的是，直到C++11标准之前，C++都没有在语言特性层面上支持lambda表达式。程序员曾尝试使用库来实现lambda表达式的功能，比如Boost/bind或Boost.Lambda，但是它们有着共同的缺点，实现代码非常复杂，使用的时候也需要十分小心，一旦有错误发生，就可能会出现一堆错误和警告信息，总之其编程体验并不好。

另外，虽然C++一直以来都没有支持lambda表达式，但是它对lambda表达式的需求却非常高。最明显的就是STL，在STL中有大量需要传入谓词的算法函数，比如std::find_if、std::replace_if等。过去有两种方法实现谓词函数：编写纯函数或者仿函数。但是它们的定义都无法直接应用到函数调用的实参中，面对复杂工程的代码，我们可能需要四处切换源文件来搜索这些函数或者仿函数。

为了解决上面这些问题，C++11标准为我们提供了lambda表达式的支持，而且语法非常简单明了。这种简单可能会让我们觉得它与传

统的C++语法有点格格不入。不过在习惯新的语法之后，就会发觉 lambda表达式的方便之处。

lambda表达式的语法非常简单，具体定义如下：

```txt
[ captures ] ( params ) specifiers exception -> ret { body }
```

先不用急于解读这个定义，我们可以结合lambda表达式的例子来读懂它的语法：

```cpp
include<iostream>   
int main()   
{ int  $\mathrm{x} = 5$  auto foo  $=$  [x](int y)->int { return x\*y;}; std::cout<<foo(8）<<std::endl;
```

在这个例子中，[x](int y) -> int { return x * y; } 是一个标准的 lambda 表达式，对应到 lambda表达式的语法。

[captures]——捕获列表，它可以捕获当前函数作用域的零个或多个变量，变量之间用逗号分隔。在对应的例子中，[x]是一个捕获列表，不过它只捕获了当前函数作用域的一个变量x，在捕获了变量之后，我们可以在lambda表达式函数体内使用这个变量，比如return x * y。另外，捕获列表的捕获方式有两种：按值捕获和引用捕获，下文会详细介绍。

（params）——可选参数列表，语法和普通函数的参数列表一样，在不需要参数的时候可以忽略参数列表。对应例子中的(int y)。

specifiers——可选限定符， $\mathrm{C}++11$  中可以用mutable，它允许我们在lambda表达式函数体内改变按值捕获的变量，或者调用非const的成员函数。上面的例子中没有使用说明符。

exception——可选异常说明符，我们可以使用noexcept来指明lambda是否会抛出异常。对应的例子中没有使用异常说明符。

ret——可选返回值类型，不同于普通函数，lambda表达式使用返回类型后置的语法来表示返回类型，如果没有返回值（void类型），可以忽略包括->在内的整个部分。另外，我们也可以在有返回值的情况下不指定返回类型，这时编译器会为我们推导出一个返回类型。对应到上面的例子是->int。

{body}——lambda表达式的函数体，这个部分和普通函数的函数体一样。对应例子中的{return x * y;}。

细心的读者肯定发现了一个有趣的事实，由于参数列表，限定符以及返回值都是可选的，于是我们可以写出的最简单的lambda表达式是[]{}。虽然看上去非常奇怪，但它确实是一个合法的lambda表达式。需要特别强调的是，上面的语法定义只属于C++11标准，C++14和C++17标准对lambda表达式又进行了很有用的扩展，我们会在后面介绍。

