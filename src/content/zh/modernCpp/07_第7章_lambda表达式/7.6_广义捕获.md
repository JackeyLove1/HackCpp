# 7.6 广义捕获

C++14标准中定义了广义捕获，所谓广义捕获实际上是两种捕获方式，第一种称为简单捕获，这种捕获就是我们在前文中提到的捕获方法，即[identifier]、[&identifier]以及[thisis]等。第二种叫作初始化捕获，这种捕获方式是在C++14标准中引入的，它解决了简单捕获的一

个重要问题，即只能捕获lambda表达式定义上下文的变量，而无法捕获表达式结果以及自定义捕获变量名，比如：

```txt
int main()   
{ int  $\mathrm{x} = 5$  auto foo  $= [\mathrm{x} = \mathrm{x} + 1]$  {return x;};   
1
```

以上在C++14标准之前是无法编译通过的，因为C++11标准只支持简单捕获。而C++14标准对这样的捕获进行了支持，在这段代码里捕获列表是一个赋值表达式，不过这个赋值表达式有点特殊，因为它通过等号跨越了两个作用域。等号左边的变量x存在于lambda表达式的作用域，而等号右边x存在于main函数的作用域。如果读者觉得两个x的写法有些绕，我们还可以采用更清晰的写法：

```c
int main()   
{ int  $\mathrm{x} = 5$  auto foo  $= [r = x + 1]$  {return r;};
```

很明显这里的变量r只存在于lambda表达式，如果此时在lambda表达式函数体里使用变量x，则会出现编译错误。初始化捕获在某些场景下是非常实用的，这里举两个例子，第一个场景是使用移动操作减少代码运行的开销，例如：

```cpp
include <string>   
int main()   
{ std::string  $\mathbf{x} =$  "hello c++ "; auto foo  $=$  [x  $=$  std::move(x)]{ return x + "world"; };   
1
```

上面这段代码使用std::move对捕获列表变量x进行初始化，这样避免了简单捕获的复制对象操作，代码运行效率得到了提升。

第二个场景是在异步调用时复制this对象，防止lambda表达式被调用时因原始this对象被析构造成未定义的行为，比如：

```cpp
include<iostream>   
#include <future>   
class Work   
{ private: int value; public: Work():value(42){} std::future<int> spawn() { return std::async  $\left[\equiv \right]$  () -> int{return value;}）； }； std::future<int> foo() { Work tmp; return tmp.spawn(); } int main() { std::future<int> f  $=$  foo(); f.wait(); std::cout<<"f.get()  $=$  "<<f.get()<<std::endl; 1
```

输出结果如下:

```txt
f.get() = 32766
```

这里我们期待f.get()返回的结果是42，而实际上返回了32766，这就是一个未定义的行为，它造成了程序的计算错误，甚至有可能让程序崩溃。为了解决这个问题，我们引入初始化捕获的特性，将对象复制到lambda表达式内，让我们简单修改一下spawn函数：

```cpp
class Work   
{ private: int value; public: Work(）：value(42）{} std::future<int> spawn() { return std::async([=，tmp  $\equiv$  \*this]（）->int{return tmp.value;}）; } };
```

以上代码使用初始化捕获，将\*this复制到tmp对象中，然后在函数体内返回tmp对象的value。由于整个对象通过复制的方式传递到lambda表达式内，因此即使this所指的对象析构了也不会影响lambda表达式的计算。编译运行修改后的代码，程序正确地输出f.get() = 42。

