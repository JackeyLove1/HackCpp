# 35.2 形参包展开

虽然上一节已经简单介绍了可变参数模板的基本语法，但是读者应该已经注意到，节中的例子并没有实际用途，无论是函数模板foo还是类模板bar，它们的主体都是空的。实际上，它们都缺少了一个最关键的环节，那就是形参包展开，简称包展开。只有结合了包展开，才能发挥变参模板的能力。需要注意的是，包展开并不是在所有情况下都能够进行的，允许包展开的场景包括以下几种。

1. 表达式列表。  
2. 初始化列表。

3. 基类描述。  
4. 成员初始化列表。  
5. 函数参数列表。  
6. 模板参数列表。  
7. 动态异常列表（C++17已经不再使用）。  
8. lambda表达式捕获列表。  
9. Sizeof...运算符。  
10. 对其运算符。  
11. 属性列表。

虽然这里列出的场景比较多，但是因为大多数是比较常见的场景，所以理解起来应该不会有什么难度。让我们通过几个例子来说明包展开的具体用法：

```cpp
include<iostream>   
template<class T, class U>   
T baz(T t, U u)   
{ std::cout << t << "" << u << std::endl; return t;   
}   
template<class ...Args>   
void foo(Args ...args) {}   
template<class ...Args>
```

```cpp
class bar {   
public: bar(Args ...args) { foo baz (&args, args) ...); } ;   
int main() { bar<int, double, unsigned int> b(1, 5.0, 8); }
```

在上面的代码中，baz是一个普通的函数模板，它将实参通过std::cout输出到控制台上。foo是一个可变参数的函数模板，不过这个函数什么也不做。在main函数中，模板bar实例化了一个bar<int, double, unsigned int>类型并且构造了对象b，在它的构造函数里对形参包进行了展开，其中baz(&args, args)...是包展开，而baz(&args, args)就是模式，也可以理解为包展开的方法。所以这段代码相当于：

```javascript
class bar {   
public: bar(int a1, double a2, unsigned int a3) { foo(baz(&a1, a1), baz(&a2, a2), baz(&a3, a3)); } };
```

为了让读者更加清晰地了解编译器对这段代码的处理，下面展示了GCC生成的GIMPLE中间代码的关键部分：

```txt
main ()   
{ ... struct bar b; bar<int, double, unsigned int>::bar (&b, 1, 5.0e+0, 8);
```

```txt
...   
}   
bar<int, double, unsigned int>::bar(struct bar * const this, int args#0, double args#1, unsigned int args#2) { args_2.0_1 = args#2; _2 = baz<unsigned int*, unsigned int> (&args#2, args_2.0_1); args_1.1_3 = args#1; _4 = baz<double*, double> (&args#1, args_1.1_3); args_0.2_5 = args#0; _6 = baz<int*, int> (&args#0, args_0.2_5); foo<int*, double*, unsigned int*> (_6, _4, _2); } baz<unsigned int*, unsigned int> (unsigned int * t, unsigned int u) { ... } baz<double*, double> (double * t, double u) { ... } baz<int*, int> (int * t, int u) { ... }
```

可以看到，在bar的构造函数中分别调用了3个不同的baz函数，然后将它们的计算结果作为参数传入foo函数中。接着，稍微修改一下这个例子：

```cpp
template<class ...T> int baz(T ...t) {
    return 0;
} template<class ...Args> void foo(Args ...args) {}
template<class ...Args> class bar {
public:
    bar(Args ...args)
```

```txt
{ foo baz(&args...）+args...）;   
}   
}；   
int main() { bar<int, double, unsigned int> b(1,5.0,8);
```

在上面这段代码中形参包又是怎么解包的？要理解这个解包过程，需要将其分为两个部分：第一个部分是对函数模板 baz (&args...) 的解包，其中 &args... 是包展开，&args 是模式，这部分会被展开为 baz (&a1, &a2, &a3)；第二部分是对 foo(baz (&args...) + args...) 的解包，由于 baz (&args...) 已经被解包，因此现在相当于解包的是 foo(baz (&a1, &a2, &a3) + args...)，其中 baz (&a1, &a2, &a3) + args... 是包展开，baz (&a1, &a2, &a3) + args 是模式，最后的结果为 foo(baz (&a1, &a2, &a3) + a1, baz (&a1, &a2, &a3) + a2, baz (&a1, &a2, &a3) + a3)。

在我们刚刚看到的这些例子中包展开的模式都还算是比较常规的，而实际上模式还可以更加灵活，例如：

```cpp
include<iostream> int add(int a, int b) { return a + b; }; int sub(int a, int b) { return a - b; }; template<class ...Args> void foo(Args (*...args) (int, int)) { int tmp[] = {(std::cout << args(7, 11) << std::endl, 0) ...}; }
```

```c
int main()   
{ foo(add, sub);   
}
```

这个例子比之前看到的都要复杂一些，首先函数模板foo的形参包不再是简单的Args...args，而是Args (\*..args) (int, int)，从形式上看这个形参包解包后将是零个或者多个函数指针。为了让编译器能自动推导出所有函数的调用，在函数模板foo的函数体里使用了一个小技巧。函数体内定义了一个int类型的数组tmp，并且借用了逗号表达式的特性，在括号中用逗号分隔的表达式会以从左往右的顺序执行，最后返回最右表达式的结果。在这个过程中 std::cout << args(7, 11) << std::endl得到了执行。(std::cout << args(7, 11) << std::endl, 0)...是一个包展开，而(std::cout << args(7, 11) << std::endl, 0)是包展开的模式。

我们已经见识了很多函数模板中包展开的例子，但是这些并不是包展开的全部，接下来让我们了解一下在类的继承中形参包以及包展开是怎么使用的：

```txt
include<iostream>   
template<class ...Args>   
class derived : publicArgs...   
{   
public: derived(constArgs&...args) :Args(args)....{}   
};   
class base1   
public:
```

```cpp
base1(){}   
base1(const base1&） { std::cout << "copy ctor base1" << std::endl; 1   
class base2   
{   
public: base2(){ base2(const base2&） { std::cout<<"copy ctor base2"<<std::endl; }；   
int main()   
{ base1b1; base2b2; derived<base1，base2> d(b1，b2);
```

在上面的代码中，derived是可变参数的类模板，有趣的地方是它将形参包作为自己的基类并且在其构造函数的初始化列表中对函数形参包进行了解包，其中Args(args)...是包展开，Args(args)是模式。

到此为止读者应该对形参包和包展开有了一定的理解，现在是时候介绍另一种可变参数模板了，这种可变参数模板拥有一个模板形参包，请注意这里并没有输入或者打印错误，确实是模板形参包。之所以在前面没有提到这类可变参数模板，主要是因为它看起来过于复杂：

```txt
template<class class ...> class ...Args> class bar : publicArgs<int, double>... {
public:
    bar(constArgs<int, double>& ...args) :Args<int, double>(args) ...
```

```txt
{ }   
} ;   
template<class ...Args> class baz1 {};   
template<class ...Args> class baz2 {};   
int main() { baz1<int, double> a1; baz2<int, double> a2; bar baz1, baz2 > b(a1, a2); }
```

可以看到类模板bar的模板形参是一个模板形参包，也就是说其形参包是可以接受零个或者多个模板的模板形参。在这个例子中，bar baz1, baz2>接受了两个类模板baz1和baz2。不过模板缺少模板实参是无法实例化的，所以bar实际上继承的不是baz1和baz2两个模板，而是它们的实例baz1<int, double>和baz2<int, double>。还有一个有趣的地方，template<class...> class...Args>似乎存在两个形参包，但事实并非如此。因为最里面的template<class...>只说明模板形参是一个变参模板，它不能在bar中被展开。

但是这并不意味着两个形参包不能同时存在于同一个模式中，要做到这一点，只要满足包展开后的长度相同即可，让我们看一看提案文档中的经典例子：

```txt
template<class...> struct Tuple {};
template<class T1, class T2> struct Pair {};
template<class ...Args1>
struct zip {
    template<class ...Args2>
```

```cpp
struct with {
    typedef Tuple<Args1,Args2>...> type;
};
} ;
int main()
{
    zip<short, int>::with<unsigned short, unsigned>::type t1; //编译成功
    zip<short>::with<unsigned short, unsigned>::type t2; //编译失败，形参
        //包长度不同
}
```

在上面的例子中，可变参数模板zip的形参包Args1和with的形参包Args2同时出现在模式Pair<Args1，Args2>中，如果要对Pair<Args1，Args2>...进行解包，就要求Args1和Args2的长度相同。编译器能够成功编译t1，t1的类型为Tuple<Pair<short, unsigned short>，Pair<int，unsigned>>，但是编译器在编译t2时会提示编译失败，因为Args1形参包中只有一个实参，而Args2中有两个实参，它们的长度不同。

现在回头看一看这些例子，我们会发现例子里包展开的场景基本上涵盖了常用的几种，包括表达式、初始化列表、基类描述、成员初始化列表、函数形参列表和模板形参列表等。在剩下没有涉及的几种场景中，还有一种可能会偶尔用到，那就是lambda表达式的捕获列表：

```txt
template<class ...Args> void foo(Args ...args) {}
template<class ...Args>
class bar {}
```

```txt
public:   
bar(Args ...args) { auto lm  $=$  [args ...]{ foo(&args...）; } lm();   
}   
};   
int main()   
{ bar<int, double> b2(5, 8.11);
```

在以上代码的lambda表达式lm的捕获列表里，args...是一个包展开，而args是模式。比较有趣的是，除了捕获列表里的包展开，在lambda表达式的函数体内foo(&args...）还有一个包展开，而这里的包展开是&args...，模式为&args。接下来看一个实际生产中可能会用到的例子：

```txt
template<class F, class...Args> auto delay.invoke(F f,Args...args) {
    return [f, args...]( ) -> endl(typeauto) {
        return std::invoke(f, args...);
    };
}
```

上面这段代码实现了一个delay.invoke，目的是将函数对象和参数打包到一个lambda表达式中，等到需要的时候直接调用lambda表达式实例，而无须关心参数如何传递。

最后值得强调一下的是函数模板推导的匹配顺序：在推导的形参同时满足定参函数模板和可变参数函数模板的时候，编译器将优先选择定参函数模板，因为它比可变参数函数模板更加精确，比如：

```txt
include<iostream>
```

```cpp
template<class...Args> void foo(Args... args) {
    std::cout << "foo(Args... args)" << std::endl;
}
template<class T1, class...Args> void foo(T1 a1,Args...args)
{
    std::cout << "foo(T1 a1,Args...args)" << std::endl;
}
template<class T1, class T2> void foo(T1 a1, T2 a2)
{
    std::cout << "foo(T1 a1, T2 a2)" << std::endl;
}
int main()
{
    foo();
    foo(1,2,3);
    foo(1,2);
}
```

上面的代码编译运行的结果是:

```txt
foo(Args... args)  
foo(T1 a1,Args...args)  
foo(T1 a1,T2 a2)
```

可以看到，当foo()没有任何实参的时候，编译器使用foo(Args...args)来匹配，因为只有它支持零参数的情况。当foo(1,2,3)有3个实参的时候，编译器不再使用foo(Args...args)来匹配，虽然它能够匹配3个实参，但是它不如foo(T1 a1,Args...args)精确，所以编译器采用了foo(T1 a1,Args...args)来匹配3个参数。foo(1,2)有两个参数，编译器再次抛弃了foo(T1 a1,Args...args)，因为这时候有更加精确的定参函数模板foo(T1 a1,T2 a2)。

