# 35.8 lambda表达式初始化捕获的包展开

读者应该还记得，我们在介绍lambda表达式使用可变参数模板时列出了这样一个例子：

```txt
template<class F, class...Args> auto delay.invoke(F f,Args...args) {
    return [f, args...]( ) -> endl(typeauto) {
        return std::invoke(f, args...);
    };
}
```

当时留下了一个问题没有解决，那就是按值捕获的性能问题。假设该delay.invoke传递的实参都是复杂的数据结构且数据量很大，那么这种按值捕获显然不是一个理想的解决方案。当然了，引用捕获更加不对，在delay.invoke的使用场景下很容易造成未定义的结果。那么我们该怎么办？其实有一个办法，它需要结合初始化捕获和移动语义，让我们将代码修改为：

```r
template<class F, class...Args> auto delay.invoke(F f,Args...args) {
    return[f = std::move(f), tup = std::make_tuple(std::move(args)...)]()
}
```

```cpp
->decltypeauto){ return std::apply(f,tup); 1
```

上面的代码首先使用了std::make_tuple和std::move将参数打包到std::tuple中，这个过程使用移动语义消除了对象的复制；接下来为了方便地展开std::tuple中的参数，需要将std::invoke修改为std::apply。虽然在这个例子中性能问题解决了，但事情还没完，尤其是当我们需要用lambda表达式调用确定的函数时，例如：

```txt
template<class...Args> auto delay.invoke_foo(Args...args) {
    return [args...]() -> endl(args auto) {
        return foo(args...);
    };
}
```

如果还是按照刚刚的办法使用std::tuple打包参数，那么代码会变得难以理解：

```erlang
template<class...Args> auto delay.invoke_foo(Args...args) {
    return [tup = std::make_tuple(std::move(args) ...)]() -> 
    return std::apply([[](auto const&...args) -> endl(typeauto) {
        return foo(args...);
    }, tup);
};
```

幸运的是，在C++20标准中我们有了更好的解决方案，标准支持 lambda表达式初始化捕获的包展开。以上代码可以修改为：

```javascript
template<class...Args> auto delay.invoke Foo(Args...args) {
    return [...args=std::move(args)]() -> endl(typeauto) {
        return foo(args...);
    };
}
```

上面的代码变得非常简洁！需要注意的是，捕获列表中...的位置在args之前，这一点和简单的捕获列表是有区别的。

回过头来看最初的示例代码，在C++20标准环境下我们可以将其修改为：

```cpp
template<class F, class...Args> auto delay.invoke(F f,Args...args) {
    return[f = std::move(f), ...args = std::move(args)]() -> 
    return std::invoke(f, args...s);
};
```

可以看出在省略了std::tuple以后代码也变得清晰了不少。

