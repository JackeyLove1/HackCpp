# 35.1 可变参数模板的概念和语法

可变参数模板是C++11标准引入的一种新特性，顾名思义就是类模板或者函数模板的形参个数是可变的。作为一个模板元编程的爱好者，刚看到这个特性的时候是非常激动的，因为这个特性能很大程度上加强模板的能力。举两个例子，熟悉C++标准库的读者肯定知道std::bind1st和std::bind2nd两个函数模板，两个函数能够绑定一个对象到函数或者函数对象，不过它们有一个很大的限制——只能绑定一个对象。为了解决这个问题，C++标准委员会在2005年的C++技术报告中(tr1)提出了新的函数模板std::bind，该函数可以将多个对象绑定到函数或者函数对象上，不过由于缺乏可变参数模板的支持，这里所谓的多个也是有限制的，比如在boost中最多是9个，后来GCC和Visual Studio C++的标准库沿用了这个设定。无独有偶，这份技术报告中还提出了std::tuple类型，该类型能够存储多种类型的对象，当然这里的多种类型的数量同样有限制，比如在boost中这个数量最多为10，后来GCC和Visual Studio C++的标准库也沿用了这个设定。可以看出这两个函数模板和类模板对于可变参数都有很强烈的需

求，于是在C++11标准支持可变参数模板以后，std::bind和std::tuple就被改写为可以接受任意多个模板形参的版本了。

```txt
template<class ...Args> void foo(Args ...args) {}
template<class ...Args> class bar {
public:
    bar(Args ...args) {
        foo(args...);
    }
};
```

在上面的代码中class ...Args是类型模板形参包，它可以接受零个或者多个类型的模板实参。Args ...args叫作函数形参包，它出现在函数的形参列表中，可以接受零个或者多个函数实参。而args...是形参包展开，通常简称包展开。它将形参包展开为零个或者多个模式的列表，这个过程称为解包。这里所谓的模式是实参展开的方法，形参包的名称必须出现在这个方法中作为实参展开的依据，最简单的情况为解包后就是实参本身。

以上这些语法概念看起来可能会有点复杂。不过没关系，结合下面的例子后读者会发现这些语法实际上非常自然：

```cpp
template<class ...Args> void foo(Args ...args) {}
int main()
{
    unsigned int x = 8;
    foo(); // foo()
    foo(1); // foo<int>(int)
    foo(1, 11.7); // foo<int,double>(int,double)
    foo(1, 11.7, x); // foo<int,double,unsigned int>
```

```txt
(int,double,unsigned int) }
```

以上是一个变参函数模板，它可以接受任意多个实参，编译器会根据实参的类型和个数推导出形参包的内容。另外，C++11标准中变参类模板虽然不能通过推导得出形参包的具体内容，但是我们可以直接指定它：

```txt
template<class ...Args> class bar {};
int main()
{
    bar<> b1;
    bar<int> b2;
    bar<int, double> b3;
    bar<int, double, unsigned int> b4;
}
```

需要注意的是，无论是模板形参包还是函数形参包都可以与普通形参结合，但是对于结合的顺序有一些特殊要求。

在类模板中，模板形参包必须是模板形参列表的最后一个形参：

```txt
template<class ...Args, class T> class bar {}; 
bar<int, double, unsigned int> b1; //编译失败，形参包并非最后一个 
template<class T, class ...Args> class baz {}; 
baz<int, double, unsigned int> b1; //编译成功
```

但是对于函数模板而言，模板形参包不必出现在最后，只要保证后续的形参类型能够通过实参推导或者具有默认参数即可，例如：

```txt
template<class ...Args, class T, class U = double> void foo(T, U,Args ...args) {}
```

```txt
foo(1, 2, 11.7); // 编译成功
```

虽然以上介绍的都是类型模板形参，但是实际上非类型模板形参也可以作为形参包，而且相对于类型形参包，非类型形参包则更加直观：

```txt
template<int ...Args> void fool() {}; template<int ...Args> class bar1 {}; int main()
{
    fool<1, 2, 5, 7, 11>(());
    bar1<1, 5, 8> b;
}
```

