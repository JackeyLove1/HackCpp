# 35.4 可变参数模板的递归计算

在C++11标准中，要对可变参数模板形参包的包展开进行逐个计算需要用到递归的方法，比如下面的求和函数：

```cpp
include<iostream>   
template<class T>   
T sum(T arg)   
{ return arg;   
}   
template<class T1, class...Args>   
auto sum(T1 arg1,Args...args)   
{ return arg1 + sum(args...);   
}   
int main()   
{ std::cout << sum(1,5.0,11.7) << std::endl;   
}
```

在上面的代码中，当传入函数模板sum的实参数量等于1时，编译器会选择调用T sum(T arg)，该函数什么也没有做，只是返回实参本身。当传入的实参数量大于1时，编译器会选择调用auto sum(T1 arg1,Args...args)，注意，这里使用C++14的特性将auto作为返回类型的占位符，把返回类型的推导交给编译器。这个函数将除了第一个形参的其他形参作为实参递归调用了sum函数，然后将其结果与第一个形参求和。最终编译器生成的结果应该和下面的伪代码类似：

```txt
sum(double arg)   
{ return arg;   
}   
sum(double arg0, double args1)   
{
```

```cpp
return arg0 + sum(args1);   
}   
sum(int arg1, double args1, double args2) { return arg1 + sum(args1, args2); }   
int main() { std::cout << sum(1, 5.0, 11.7) << std::endl;
```

