# 6.1 左值和右值

左值和右值的概念早在C++98的时候就已经出现了，从最简单的字面理解，无非是表达式等号左边的值为左值，而表达式右边的值为右值，比如：

```txt
int x = 1;  
int y = 3;  
int z = x + y;
```

以上面的代码为例，x是左值，1是右值；y是左值，3是右值；z是左值， $\mathrm{x} + \mathrm{y}$ 的结果是右值。用表达式等号左右的标准区分左值和右值虽然在一些场景下确实能得到正确结果，但是还是过于简单，有些情况下是无法准确区分左值和右值的，比如：

```txt
int a = 1;  
int b = a;
```

按照表达式等号左右的区分方式，在第一行代码中a是左值，1是右值；在第二行代码中b是左值，而a是右值。这里出现了矛盾，在第一行代码中我们判断a是一个左值，它却在第二行变成了右值，很明

显这不是我们想要的结果，要准确地区分左值和右值还是应该理解其内在含义。

在C++中所谓的左值一般是指一个指向特定内存的具有名称的值（具名对象），它有一个相对稳定的内存地址，并且有一段较长的生命周期。而右值则是不指向稳定内存地址的匿名值（不具名对象），它的生命周期很短，通常是暂时性的。基于这一特征，我们可以用取地址符&来判断左值和右值，能取到内存地址的值为左值，否则为右值。还是以上面的代码为例，因为&a和&b都是符合语法规则的，所以a和b都是左值，而&1在GCC中会给出“lvalue required as unary‘&’ operand”错误信息以提示程序员&运算符需要的是一个左值。

上面的代码在左右值的判断上比较简单，但是并非所有的情况都是如此，下面这些情况左值和右值的判断可能是违反直觉的，例如：

```c
int x = 1;   
int get_val() { return x;   
}   
void set_val(int val) { x = val;   
}   
int main() { x++; ++x; int y = get_val(); set_val(6);   
}
```

在上面的代码中， $\mathrm{x}++$  和  $++\mathrm{x}$  虽然都是自增操作，但是却分为不同的左右值。其中  $\mathrm{x}++$  是右值，因为在后置  $++$  操作中编译器首先会生成一份  $\mathrm{x}$  值的临时复制，然后才对  $\mathrm{x}$  递增，最后返回临时复制内容。而  $++\mathrm{x}$  则不同，它是直接对  $\mathrm{x}$  递增后马上返回其自身，所以  $++\mathrm{x}$  是一个左值。如果对它们实施取地址操作，就会发现  $++\mathrm{x}$  的取地址操作可以编译成功，而对  $\mathrm{x}++$  取地址则会报错。但是从直觉上来说， $\& \mathrm{x}++$  看起来更像是会编译成功的一方：

```txt
int  $\star p = \& x + + ;$  //编译失败  
int  $\star q = \& + + x;$  //编译成功
```

接着来看上一份代码中的get_val函数，该函数返回了一个全局变量x，虽然很明显变量x是一个左值，但是它经过函数返回以后变成了一个右值。原因和x++类似，在函数返回的时候编译器并不会返回x本身，而是返回x的临时复制，所以int * p = &get_val();也会编译失败。对于set_val函数，该函数接受一个参数并且将参数的值赋值到x中。在main函数中set_val(6);实参6是一个右值，但是进入函数之后形参val却变成了一个左值，我们可以对val使用取地址符，并且不会引起任何问题：

```lisp
void set_val(int val)  
{  
    int *p = &val;  
    x = val;  
}
```

最后需要强调的是，通常字面量都是一个右值，除字符串字面量以外：

```txt
int  $\mathbf{x} = 1$    
set_val(6);   
auto  $p =$  &"hello world";
```

这一点非常容易被忽略，因为经验告诉我们上面的代码中前两行的1和6都是右值，因为不存在&1和&6的语法，这会让我们想当然地认为"hello world"也是一个右值，毕竟"&"hello world"的语法也很少看到。但是这段代码是可以编译成功的，其实原因仔细想来也很简单，编译器会将字符串字面量存储到程序的数据段中，程序加载的时候也会为其开辟内存空间，所以我们可以使用取地址符&来获取字符串字面量的内存地址。

