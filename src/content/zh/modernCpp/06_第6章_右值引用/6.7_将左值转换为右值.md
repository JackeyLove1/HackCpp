# 6.7 将左值转换为右值

在6.3节提到过右值引用只能绑定一个右值，如果尝试绑定，左值会导致编译错误：

```txt
int  $\mathrm{i} = 0$  int&&k  $= \mathrm{i}$  //编译失败
```

不过，如果想完成将右值引用绑定到左值这个“壮举”还是有办法的。在C++11标准中可以在不创建临时值的情况下显式地将左值通过static_cast转换为将亡值，通过值类别的内容我们知道将亡值属

于右值，所以可以被右值引用绑定。值得注意的是，由于转换的并不是右值，因此它依然有着和转换之前相同的生命周期和内存地址，例如：

```cpp
int i = 0;  
int &&k = static_cast<int&&>(i); //编译成功
```

读者在这里应该会有疑问，既然这个转换既不改变生命周期也不改变内存地址，那它有什么存在的意义呢？实际上它的最大作用是让左值使用移动语义，还是以BigMemoryPool为例：

```txt
BigMemoryPool my_pool1;   
BigMemoryPool my_pool2  $=$  my_pool1;   
BigMemoryPool my_pool3  $=$  static cast<BigMemoryPool &&>(my_pool1);
```

在这段代码中，my_pool1是一个BigMemoryPool类型的对象，也是一个左值，所以用它去构造my_pool2的时候调用的是复制构造函数。为了让编译器调用移动构造函数构造my_pool3，这里使用了static_cast<BigMemoryPool &&>(my_pool1)将my_pool1强制转换为右值（也是将亡值，为了叙述思路的连贯性后面不再强调）。由于调用了移动构造函数，my_pool1失去了自己的内存数据，后面的代码也不能对my_pool1进行操作了。

现在问题又来了，这样单纯地将一个左值数据转换到另外一个左值似乎并没有什么意义。在这个例子中的确如此，这样的转换不仅没有意义，而且如果有程序员在移动构造之后的代码中再次使用my_pool1还会引发未定义的行为。正确的使用场景是在一个右值被

转换为左值后需要再次转换为右值，最典型的例子是一个右值作为实参传递到函数中。我们在讨论左值和右值的时候曾经提到过，无论一个函数的实参是左值还是右值，其形参都是一个左值，即使这个形参看上去是一个右值引用，例如：

```cpp
void move_pool(BigMemoryPool &&pool)   
{ std::cout << "call move_pool" << std::endl; BigMemoryPool my_pool(pool);   
}   
int main()   
{ move_pool(make_pool());   
}
```

编译运行以上代码输出结果如下：

```txt
copy big memory pool.  
move big memory pool.  
call move_pool  
copy big memory pool.
```

在上面的代码中，move_pool函数的实参是make_pool函数返回的临时对象，也是一个右值，move_pool的形参是一个右值引用，但是在使用形参pool构造my_pool的时候还是会调用复制构造函数而非移动构造函数。为了让my_pool调用移动构造函数进行构造，需要将形参pool强制转换为右值：

```cpp
void move_pool(BigMemoryPool &&pool)   
{ std::cout << "call move_pool" << std::endl; BigMemoryPool my_pool(static cast<BigMemoryPool&&>(pool));   
}
```

请注意，在这个场景下强制转换为右值就没有任何问题了，因为move_pool函数的实参是make_pool返回的临时对象，当函数调用结束后临时对象就会被销毁，所以转移其内存数据不会存在任何问题。

在C++11的标准库中还提供了一个函数模板std::move帮助我们将左值转换为右值，这个函数内部也是用static_cast做类型转换。只不过由于它是使用模板实现的函数，因此会根据传参类型自动推导返回类型，省去了指定转换类型的代码。另一方面从移动语义上来说，使用std::move函数的描述更加准确。所以建议读者使用std::move将左值转换为右值而非自己使用static_cast转换，例如：

```cpp
void move_pool(BigMemoryPool &&pool)   
{ std::cout << "call move_pool" << std::endl; BigMemoryPool my_pool(std::move(pool));   
}
```

