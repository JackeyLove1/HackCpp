# 6.9 完美转发

6.8节介绍了万能引用的语法和推导规则，但没有提到它的用途。现在是时候讨论这个问题了，万能引用最典型的用途被称为完美转发。在介绍完美转发之前，我们先看一个常规的转发函数模板：

```cpp
include<iostream> #include<string> template<class T> void show_type(T t)
```

```cpp
{ std::cout << typeid(t).name() << std::endl;   
}   
template<class T> void normal_forwarding(T t) { show_type(t);   
}   
int main() { std::string s = "hello world"; normal_forwarding(s);   
}
```

在上面的代码中，函数normal_forwarding是一个常规的转发函数模板，它可以完成字符串的转发任务。但是它的效率却令人堪忧。因为normal_forwarding按值转发，也就是说std::string在转发过程中会额外发生一次临时对象的复制。其中一个解决办法是将void normal_forwarding(T t)替换为void normal_forwarding(T &t)，这样就能避免临时对象的复制。不过这样会带来另外一个问题，如果传递过来的是一个右值，则该代码无法通过编译，例如：

```cpp
std::string get_string()
{
    return "hi world";
}
```

当然，我们还可以将void normal_forwarding(T &t)替换为void normal_forwarding (const T &t)来解决这个问题，因为常量左值引用是可以引用右值的。但是我们也知道，虽然常量左

值引用在这个场景下可以“完美”地转发字符串，但是如果在后续的函数中需要修改该字符串，则会编译错误。所以这些方法都不能称得上是完美转发。

万能引用的出现改变了这个尴尬的局面。上文提到过，对于万能引用的形参来说，如果实参是给左值，则形参被推导为左值引用；反之如果实参是一个右值，则形参被推导为右值引用，所以下面的代码无论传递的是左值还是右值都可以被转发，而且不会发生多余的临时复制：

```cpp
include<iostream> #include<string> template<class T> void show_type(T t) { std::cout << typeid(t).name() << std::endl; } template<class T> void perfect_forwarding(T &&t) { show_type(static_cast<T&&>(t)); } std::string get_string() { return "hi world"; } int main() { std::string s = "hello world"; perfect_backward(s); perfect_backward(get_string()); }
```

如果已经理解了引用折叠规则，那么上面的代码就很容易理解了。唯一可能需要注意的是show_type(static_cast<T&&>(t));中的类型转换，之所以这里需要用到类型转换，是因为作为形参的t是左值。为了让转发将左右值的属性也带到目标函数中，这里需要进行类型转换。当实参是一个左值时，T被推导为std::string&，于是static_cast<T&&>被推导为static_cast<std::string&&>，传递到show_type函数时继续保持着左值引用的属性；当实参是一个右值时，T被推导为std::string，于是static_cast<T&&>被推导为static_cast<std::string&&>，所以传递到show_type函数时保持了右值引用的属性。

和移动语义的情况一样，显式使用static cast类型转换进行转发不是一个便捷的方法。在C++11的标准库中提供了一个std::forward函数模板，在函数内部也是使用static cast进行类型转换，只不过使用std::forward转发语义会表达得更加清晰，std::forward函数模板的使用方法也很简单：

```cpp
template<class T> void perfect_forwarding(T && t) {
    show_type(std::forward<T>(t));
}
```

请注意std::move和std::forward的区别，其中std::move一定会将实参转换为一个右值引用，并且使用std::move不需要指定

模板实参，模板实参是由函数调用推导出来的。而std::forward会根据左值和右值的实际情况进行转发，在使用的时候需要指定模板实参。

