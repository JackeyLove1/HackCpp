# 6.5 移动语义

仔细分析6.4节代码中3次复制构造函数的调用，不难发现第二次和第三次的复制构造是影响性能的主要原因。在这个过程中都有临时对象参与进来，而临时对象本身只是做数据的复制。如果有的办法能将临时对象的内存直接转移到my_pool对象中，不就能消除内存复制对性能的消耗吗？好消息是在C++11标准中引入了移动语义，它可以帮助我们将临时对象的内存移动到my_pool对象中，以避免内存数据的复制。让我们简单修改一下BigMemoryPool类代码：

```cpp
class BigMemoryPool {   
public: static const int PoolSize = 4096; BigMemoryPool(  $\mathbf{\rho}$  :pool_(new char[PoolSize]){} ~BigMemoryPool() { if (pool_ != nullptr) { delete[] pool_; }   
}   
BigMemoryPool(BigMemoryPool&& other) { std::cout << "move big memory pool." << std::endl; pool_  $=$  other.pool_; other.pool_  $=$  nullptr;   
}   
BigMemoryPool(const BigMemoryPool& other) : pool_(new char[PoolSize]) { std::cout << "copy big memory pool." << std::endl; memcpy(pool_, other.pool_, PoolSize);   
}   
private: char *pool_;
```

在上面的代码中增加了一个类BigMemoryPool的构造函数BigMemoryPool (BigMemoryPool&& other)，它的形参是一个右值引用类型，称为移动构造函数。这个名称很容易让人联想到复制构造函数，那么就让我们先了解一下它们的区别。

从构造函数的名称和它们的参数可以很明显地发现其中的区别，对于复制构造函数而言形参是一个左值引用，也就是说函数的实参必须是一个具名的左值，在复制构造函数中往往进行的是深复制，即在不能破坏实参对象的前提下复制目标对象。而移动构造函数恰恰相反，它接受的是一个右值，其核心思想是通过转移实参对象的数据以达成构造目标对象的目的，也就是说实参对象是会被修改的。

进一步来说类BigMemoryPool的移动构造函数，在函数中没有了复制构造中的内存复制，取而代之的是简单的指针替换操作。它将实参对象的pool_赋值到当前对象，然后置空实参对象以保证实参对象析构的时候不会影响这片内存的生命周期。

编译运行这段代码，其输出结果如下：

```txt
copy big memory pool.  
move big memory pool.  
move big memory pool.
```

可以看到后面两次的构造函数变成了移动构造函数，因为这两次操作中源对象都是右值（临时对象），对于右值编译器会优先选择使用移动构造函数去构造目标对象。当移动构造函数不存在的时候才会

退而求其次地使用复制构造函数。在移动构造函数中使用了指针转移的方式构造目标对象，所以整个程序的运行效率得到大幅提升。

为了验证效率的提升，我们可以将上面的代码重复运行100万次，然后输出运行时间。请注意，在做实验前需要将构造函数中的打印输出语句删除，否则会影响实验数据：

```cpp
include <chrono>   
int main()   
{ auto start  $=$  std::chrono::high_resolution_clock::now(); for (int i  $= 0$  .i<1000000;  $\mathrm{i + + }$  { BigMemoryPool my_pool  $=$  make_pool(); } auto end  $=$  std::chrono::high_resolution_clock::now(); std::chrono::duration<double>diff  $=$  end - start; std::cout<< "Time to call make_pool:" << diff.count()<<"s"   
<<std::endl;   
}
```

以上代码在我的机器上运行结果是0.206474s，如果将移动构造函数删除，运行结果是0.47077s，可见使用移动构造函数将性能提升了1倍多。

除移动构造函数能实现移动语义以外，移动赋值运算符函数也能完成移动操作，继续以BigMemoryPool为例，在这个类中添加移动赋值运算符函数：

```cpp
class BigMemoryPool {   
public: ... BigMemoryPool& operator=(BigMemoryPool&& other) { std::cout << "move operator=）big memory pool." << std::endl;
```

```javascript
if (pool_ != nullptr) { delete[] pool_; } pool_ = other.pool_; other.pool_ = nullptr; return *this; } private: char *pool_; }; int main() { BigMemoryPool my_pool; my_pool = make_pool(); }
```

这段代码编译运行的结果是：

```txt
copy big memory pool.   
move big memory pool.   
move (operator  $\equiv$  )big memory pool.
```

可以看到赋值操作my_pool = make_pool()调用了移动赋值运算符函数，这里的规则和构造函数一样，即编译器对于赋值源对象是右值的情况会优先调用移动赋值运算符函数，如果该函数不存在，则调用复制赋值运算符函数。

最后有两点需要说明一下。

1. 同复制构造函数一样，编译器在一些条件下会生成一份移动构造函数，这些条件包括：没有任何的复制函数，包括复制构造函数和复制赋值函数；没有任何的移动函数，包括移动构造函数和移动赋值函数；也没有析构函数。虽然这些条件严苛得让人有些不太愉快，但

是我们也不必对生成的移动构造函数有太多期待，因为编译器生成的移动构造函数和复制构造函数并没有什么区别。

2. 虽然使用移动语义在性能上有很大收益，但是却也有一些风险，这些风险来自异常。试想一下，在一个移动构造函数中，如果当一个对象的资源移动到另一个对象时发生了异常，也就是说对象的一部分发生了转移而另一部分没有，这就会造成源对象和目标对象都不完整的情况发生，这种情况的后果是无法预测的。所以在编写移动语义的函数时建议确保函数不会抛出异常，与此同时，如果无法保证移动构造函数不会抛出异常，可以使用noexcept说明符限制该函数。这样当函数抛出异常的时候，程序不会再继续执行而是调用std::terminate中止执行以免造成其他不良影响。

