# 6.3 右值引用

顾名思义，右值引用是一种引用右值且只能引用右值的方法。在语法方面右值引用可以对比左值引用，在左值引用声明中，需要在类型后添加&，而右值引用则是在类型后添加&&，例如：

```latex
int  $\mathrm{i} = 0$  int&j  $= \dot{\mathbf{i}}$  //左值引用 int&&k  $= 11$  //右值引用
```

在上面的代码中，k是一个右值引用，如果试图用k引用变量i，则会引起编译错误。右值引用的特点之一是可以延长右值的生命周期，这个对于字面量11可能看不出效果，那么请看下面的例子：

```cpp
include<iostream>   
class X{   
public: X() { std::cout << "X cctor" << std::endl; } X(const X&x) { std::cout << "X copy cctor" << std::endl; } ~X() { std::cout << "Xdotor" << std::endl; } void show() { std::cout << "show X" << std::endl; }   
}；   
Xmake_x() { X x1; return x1;   
}   
int main() { X &&x2 = make_x();
```

```css
x2.show(); }
```

在理解这段代码之前，让我们想一下如果将x &&x2 = make_x()这句代码替换为x x2 = make_x()会发生几次构造。在没有进行任何优化的情况下应该是3次构造，首先make_x函数中x1会默认构造一次，然后return x1会使用复制构造产生临时对象，接着X x2 = make_x()会使用复制构造将临时对象复制到x2，最后临时对象被销毁。

以上流程在使用了右值引用以后发生了微妙的变化，让我们编译运行这段代码。请注意，用GCC编译以上代码需要加上命令行参数-fno-eltide-constructors用于关闭函数返回值优化（RVO）。因为GCC的RVO优化会减少复制构造函数的调用，不利于语言特性实验：

```txt
X c t or X copy c t o r X d t o r show X X d t o r
```

从运行结果可以看出上面的代码只发生了两次构造。第一次是make_x函数中x1的默认构造，第二次是return x1引发的复制构造。不同的是，由于x2是一个右值引用，引用的对象是函数make_x返回的临时对象，因此该临时对象的生命周期得到延长，所以我们可以在X &&x2 = make_x()语句结束后继续调用show函数而不会发生任何问题。对性能敏感的读者应该注意到了，延长临时对象生命周期

期并不是这里右值引用的最终目标，其真实目标应该是减少对象复制，提升程序性能。

