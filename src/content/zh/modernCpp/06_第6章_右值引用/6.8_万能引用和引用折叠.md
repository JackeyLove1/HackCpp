# 6.8 万能引用和引用折叠

6.2节提到过常量左值引用既可以引用左值又可以引用右值，是一个几乎万能的引用，但可惜的是由于其常量性，导致它的使用范围受到一些限制。其实在C++11中确实存在着一个被称为“万能”的引用，它看似是一个右值引用，但其实有着很大区别，请看下面的代码：

```txt
void foo(int &&i）{//i为右值引用 template<class T> void bar(T&&t）{//t为万能引用 int get_val(){return5;}
```

```txt
int &&x = get_val(); // x为右值引用  
auto &&y = get_val(); // y为万能引用
```

在上面的代码中，函数foo的形参i和变量x是右值引用，而函数模板的形参t和变量y则是万能引用。我们知道右值引用只能绑定一个右值，但是万能引用既可以绑定左值也可以绑定右值，甚至const和volatile的值都可以绑定，例如：

```txt
int i = 42;  
const int j = 11;  
bar(i);  
bar(j);  
bar(get_val());  
auto &&x = i;  
auto &&y = j;  
auto &&z = get_val();
```

看到这里读者应该已经发现了其中的奥秘。所谓的万能引用是因为发生了类型推导，在T&&和auto&&的初始化过程中都会发生类型的推导，如果已经有一个确定的类型，比如int &&，则是右值引用。在这个推导过程中，初始化的源对象如果是一个左值，则目标对象会推导出左值引用；反之如果源对象是一个右值，则会推导出右值引用，不过无论如何都会是一个引用类型。

万能引用能如此灵活地引用对象，实际上是因为在C++11中添加了一套引用叠加推导的规则——引用折叠。在这套规则中规定了在不同的引用类型互相作用的情况下应该如何推导出最终类型，如表6-1所示。

▼表6-1

<table><tr><td>类模板型</td><td>T实际类型</td><td>最终类型</td></tr><tr><td>T&amp;</td><td>R</td><td>R&amp;</td></tr><tr><td>T&amp;</td><td>R&amp;</td><td>R&amp;</td></tr><tr><td>T&amp;</td><td>R&amp;&amp;</td><td>R&amp;</td></tr><tr><td>T&amp;&amp;</td><td>R</td><td>R&amp;&amp;</td></tr><tr><td>T&amp;&amp;</td><td>R&amp;</td><td>R&amp;</td></tr><tr><td>T&amp;&amp;</td><td>R&amp;&amp;</td><td>R&amp;&amp;</td></tr></table>

上面的表格显示了引用折叠的推导规则，可以看出在整个推导过程中，只要有左值引用参与进来，最后推导的结果就是一个左值引用。只有实际类型是一个非引用类型或者右值引用类型时，最后推导出来的才是一个右值引用。那么这个规则是如何在万能引用中体现的呢？让我们以函数模板bar为例看一下具体的推导过程。

在bar(i);中i是一个左值，所以T的推导类型结果是int&，根据引用折叠规则int&&的最终推导类型为int&，于是bar函数的形参是一个左值引用。而在bar(get_val())；中get_val返回的是一

个右值，所以T的推导类型为非引用类型int，于是最终的推导类型是int&&，bar函数的形参成为一个右值引用。

值得一提的是，万能引用的形式必须是T&&或者auto&&，也就是说它们必须在初始化的时候被直接推导出来，如果在推导中出现中间过程，则不是一个万能引用，例如：

```rust
include <vector> template<class T> void foo(std::vector<T> &&t）{} int main() { std::vector<int> v{1,2,3}； foo(v); //编译错误
```

在上面的代码中，foo(v)无法编译通过，因为foo的形参t并不是一个万能引用，而是一个右值引用。因为foo的形参类型是

std::vector<T>&而不是T&&，所以编译器无法将其看作一个万能引用处理。

