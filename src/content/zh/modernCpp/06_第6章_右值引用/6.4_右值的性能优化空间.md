# 6.4 右值的性能优化空间

通过6.3节的介绍我们知道了很多情况下右值都存储在临时对象中，当右值被使用之后程序会马上销毁对象并释放内存。这个过程可能会引发一个性能问题，例如：

```cpp
include<iostream>   
class BigMemoryPool{   
public: static const int PoolSize  $=$  4096; BigMemoryPool(）：pool_(new char[PoolSize]){} ~BigMemoryPool() { if (pool_！  $=$  nullptr）{ delete[] pool_; }   
} BigMemoryPool(const BigMemoryPool& other) : pool_(new char[PoolSize]) { std::cout << "copy big memory pool." << std::endl; memcpy(pool_,other.pool_,PoolSize);   
}   
private: char \*pool_;   
};   
BigMemoryPool get_pool(const BigMemoryPool& pool) { return pool;   
}   
BigMemoryPool make_pool() { BigMemoryPool pool; return get_pool(pool);
```

```txt
}   
int main() { BigMemoryPool my_pool  $\equiv$  make_pool(); }
```

以上代码同样需要加上编译参数-fno-(-(constructors，编译运行程序会在屏幕上输出字符串：

```txt
copy big memory pool.  
copy big memory pool.  
copy big memory pool.
```

可以看到BigMemoryPool my_pool = make_pool(); 调用了3次复制构造函数。

1. get_pool返回的BigMemoryPool临时对象调用复制构造函数复制了pool对象。  
2. make_pool返回的BigMemoryPool临时对象调用复制构造函数复制了get_pool返回的临时对象。  
3. main函数中my_pool调用其复制构造函数复制make_pool返回的临时对象。

该代码从正确性上看毫无问题，但是从运行性能的角度上看却还有巨大的优化空间。在这里每发生一次复制构造都会复制整整4KB的数据，如果数据量更大一些，比如4MB或者400MB，那么将对程序性能造成很大影响。

