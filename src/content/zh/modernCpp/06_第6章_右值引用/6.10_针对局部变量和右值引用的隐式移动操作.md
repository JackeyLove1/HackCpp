# 6.10 针对局部变量和右值引用的隐式移动操作

在对旧程序代码升级新编译环境之后，我们可能会发现程序运行的效率提高了，这里的原因一定少不了新标准的编译器在某些情况下将隐式复制修改为隐式移动。虽然这些是编译器“偷偷”完成的，但是我们不能因为运行效率提高就忽略其中的缘由，所以接下来我们要弄清楚这些隐式移动是怎么发生的：

```cpp
include<iostream>   
struct X{ X()  $=$  default; X(constX&）  $=$  default; X(X&&){ std::cout<<"movector"; }   
}；   
Xf(Xx）{ return x;   
}   
int main(){ Xr  $=$  f(X{});
```

这段代码很容易理解，函数f直接返回调用者传进来的实参x，在main函数中使用r接收f函数的返回值。关键问题是，这个赋值操作

究竟是如何进行的。从代码上看，将r赋值为x应该是一个复制，对于旧时的标准这是没错的。但是对于支持移动语义的新标准，这个地方会隐式地采用移动构造函数来完成数据的交换。编译运行以上代码最终会显示move actor字符串。

除此之外，对于局部变量也有相似的规则，只不过大多数时候编译器会采用更加高效的返回值优化代替移动操作，这里我们稍微修改一点f函数：

```txt
Xf（{ Xx; return x; } int main(）{ Xr  $=$  f(); 1
```

请注意，编译以上代码的时候需要使用-fno-(-(constructors选项用于关闭返回值优化。然后运行编译好的程序，会发现X r = f();同样调用的是移动构造函数。

在C++20标准中，隐式移动操作针对右值引用和throw的情况进行了扩展，例如：

```cpp
include<iostream>   
#include<string>   
struct X{ X()  $=$  default; X(constX&）  $=$  default; X(X&&){ std::cout<<"move"; 1
```

```javascript
}；   
Xf(X&&x）{ return x; } int main() { Xr  $=$  f(X{}）; 1
```

以上代码使用C++20之前的标准编译是不会调用任何移动构造函数的。原因前面也解释过，因为函数f的形参x是一个左值，对于左值要调用复制构造函数。要实现移动语义，需要将return x;修改为return std::move(x);。显然这里是有优化空间的，C++20标准规定在这种情况下可以隐式采用移动语义完成赋值。具体规则如下。

可隐式移动的对象必须是一个非易失或一个右值引用的非易失自动存储对象，在以下情况下可以使用移动代替复制。

1. return或者co_return语句中的返回对象是函数或者 lambda表达式中的对象或形参。  
2. throw语句中抛出的对象是函数或try代码块中的对象。

实际上throw调用移动构造的情况和return差不多，我们只需要将上面的代码稍作修改即可：

```javascript
void f() { X x; throw x; } int main() { try { f();
```

```txt
} catch (...) { }
```

可以看到函数f不再有返回值，它通过throw抛出x，main函数用try-catch捕获f抛出的x。这个捕获调用的就是移动构造函数。

