# 8.1 使用默认初始化

在C++11以前，对非静态数据成员初始化需要用到初始化列表，当类的数据成员和构造函数较多时，编写构造函数会是一个令人头痛的问题：

```cpp
class X {   
public: X(  $\mathbf{\rho}$  a_0)，b_(0.），c_("hello world"){} X(int a):a_(a)，b_(0.），c_("hello world"){} X(double b):a_(0)，b_(b)，c_("hello world"){} X(const std::string&c)：a_(0)，b_(0.），c_(c){}   
private: int a_; double b_; std::string c_;   
};
```

在上面的代码中，类x有4个构造函数，为了在构造的时候初始化非静态数据成员，它们的初始化列表有一些冗余代码，而造成的后果是维护困难且容易出错。为了解决这种问题，C++11标准提出了新的初始化方法，即在声明非静态数据成员的同时直接对其使用=或者{}（见第9章）初始化。在此之前只有类型为整型或者枚举类型的常量静态数据成员才有这种声明默认初始化的待遇：

```cpp
class X {
public:
    X() {}
    X(int a) : a_(a) {}
    X(double b) : b_(b) {}
    X(const std::string &c) : c_(c) {}
private:
    int a_ = 0;
    double b_ {0.};
    std::string c_ { "hello world" };
};
```

以上代码使用了非静态数据成员默认初始化的方法，可以看到这种初始化的方式更加清晰合理，每个构造函数只需要专注于特殊成员的初始化，而其他的数据成员则默认使用声明时初始化的值。比如X(const std::string c)这个构造函数，它只需要关心数据成员c_的初始化而不必初始化a_和b_。在初始化的优先级上有这样的规则，初始化列表对数据成员的初始化总是优先于声明时默认初始化。

最后来看一看非静态数据成员在声明时默认初始化需要注意的两个问题。

1. 不要使用括号 ( ) 对非静态数据成员进行初始化，因为这样会造成解析问题，所以会编译错误。  
2. 不要用auto来声明和初始化非静态数据成员，虽然这一点看起来合理，但是C++并不允许这么做。

```txt
struct X {
    int a(5); // 编译错误，不能使用()进行默认初始化
    auto b = 8; // 编译错误，不能使用auto声明和初始化非静态数据成员
};
```

