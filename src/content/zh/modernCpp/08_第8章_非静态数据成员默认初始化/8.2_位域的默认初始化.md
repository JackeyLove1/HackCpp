# 8.2 位域的默认初始化

在C++11标准提出非静态数据成员默认初始化方法之后，C++20标准又对该特性做了进一步扩充。在C++20中我们可以对数据成员的位域进行默认初始化了，例如：

```txt
struct S {
    int y: 8 = 11;
    int z: 4 {7};
};
```

在上面的代码中，int数据的低8位被初始化为11，紧跟它的高4位被初始化为7。

位域的默认初始化语法很简单，但是也有一个需要注意的地方。当表示位域的常量表达式是一个条件表达式时我们就需要警惕了，例如：

```txt
int a;   
struct S2{ int y: true ? 8 : a = 42; int z : 1 || new int {0};   
}；
```

请注意，这段代码中并不存在默认初始化，因为最大化识别标识符的解析规则让  $= 42$  和  $\{0\}$  不可能存在于解析的顶层。于是以上代码会被认为是：

```c
int a;   
struct S2{ int y:(true?8:a=42); int z:(1||new int{0});   
};
```

所以我们可以通过使用括号明确代码被解析的优先级来解决这个问题：

```c
int a;   
struct S2{ int y:(true?8:a）=42; int z:(1||new int){0}；   
};
```

通过以上方法就可以对s2::y和s2::z进行默认初始化了。

