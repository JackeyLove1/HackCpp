# 26.1 定义非常量静态成员变量的问题

在C++17标准之前，定义类的非常量静态成员变量是一件让人头痛的事情，因为变量的声明和定义必须分开进行，比如：

```cpp
include<iostream> #include<string> class X { public: static std::string text; }; std::string X::text{ "hello" }; int main() { X::text  $+ =$  "world"; std::cout << X::text << std::endl; }
```

在这里static std::string text是静态成员变量的声明，std::string X::text{ "hello" }是静态成员变量的定义和初始化。为了保证代码能够顺利地编译，我们必须保证静态成员变量的定义有且只有一份，稍有不慎就会引发错误，比较常见的错误是为了方便将静态成员变量的定义放在头文件中：

```txt
#ifndef X_H
#define X_H
class X{
```

```autohotkey
public: static std::string text;   
};   
std::string X::text{ "hello" }; #endif
```

将上面的代码包含到多个CPP文件中会引发一个链接错误，因为include是单纯的宏替换，所以会存在多份x::text的定义导致链接失败。对于一些字面量类型，比如整型、浮点类型等，这种情况有所缓解，至少对于它们而言常量静态成员变量是可以一边声明一边定义的：

```cpp
include<iostream>   
#include<string>   
class X{   
public: static const int num{5};   
}；   
int main()   
{ std::cout<<X::num<<std::endl;   
}
```

不过有得有失，虽然常量性能让它们方便地声明和定义，但却丢失了修改变量的能力。对于std::string这种非字面量类型，这种方法是无能为力的。

