# 2.2 嵌套命名空间的简化语法

有时候打开一个嵌套命名空间可能只是为了向前声明某个类或者函数，但是却需要编写冗长的嵌套代码，加入一些无谓的缩进，这很难让人接受。幸运的是，C++17标准允许使用一种更简洁的形式描述嵌套命名空间，例如：

```cpp
namespace A::B::C{ int foo() { return 5; }
```

以上代码等同于：

```txt
namespace A { namespace B { namespace C { int foo() { return 5; } } } }
```

很显然前者是一种更简洁的定义嵌套命名空间的方法。除简洁之外，它也更加符合我们已有的语法习惯，比如嵌套类：

```cpp
std::vector<int>::iterator it;
```

实际上这份语法规则的提案早在2003年的时候就已经提出，只不过到C++17才被正式引入标准。另外有些遗憾的是，在C++17标准中没有办法简洁地定义内联命名空间，这个问题直到C++20标准才得以解决。在C++20中，我们可以这样定义内联命名空间：

```cpp
namespace A::B::inline C{ int foo(){return5;}   
//或者   
namespaceA::inlineB::C{ int foo(){return5;}
```

它们分别等同于:

```cpp
namespace A::B{ inline namespace C{ int foo(){ return 5; } }   
}   
namespace A{ inline namespace B{ namespace C{ int foo(){ return 5; } } }   
}
```

请注意，inline可以出现在除第一个namespace之外的任意namespace之前。

