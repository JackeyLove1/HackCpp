# 34.10 不推荐使用volatile的情况（C++20）

volatile是一个非常著名的关键字，用于表达易失性。它能够让编译器不要对代码做过多的优化，保证数据的加载和存储操作被多次执行，即使编译器知道这种操作是无用的，也无法对其进行优化。事实上，在现代的计算机环境中，volatile限定符的意义已经不大了。首先我们必须知道，该限定符并不能保证数据的同步，无法保证内存操作不被中断，它的存在不能代替原子操作。其次，虽然volatile操作的顺序不能相对于其他volatile操作改变，但是可以相对于非volatile操作改变。更进一步来说，即使从C++编译代码的层面上保证了操作执行的顺序，但是对于现代CPU而言这种操作执行顺序也是无法保证的。

因为volatile限定符现实意义的减少以及部分程序员对此理解的偏差，C++20标准在部分情况中不推荐volatile的使用，这些情况包括以下几种。

1. 不推荐算术类型的后缀++和--表达式以及前缀++和--表达式使用volatile限定符：

```matlab
volatile int d = 5;  
d++;  
--d;
```

2. 不推荐非类型左操作数的赋值使用volatile限定符:

```lisp
// E1 op= E2  
volatile int d = 5;  
d += 2;  
d *= 3;
```

3. 不推荐函数形参和返回类型使用volatile限定符:

```c
volatile int f() { return 1; }  
int g(volatile int v) { return v; }
```

4. 不推荐结构化绑定使用volatile限定符:

```c
struct X {
    int a;
    short b;
};  
X x{11, 7};
volatile auto [a, b] = x;
```

以上4种情况在C++20标准的编译环境中编译都会给出'volatile'- qualified type is deprecated的警告信息。

34.11 不推荐在下标表达式中使用逗号运算符  $(\mathrm{C} + + 20)$

对于逗号运算符我们再熟悉不过了，它可以让多个表达式按照从左往右的顺序进行计算，整体的结果为系列中最后一个表达式的值，例如：

```txt
int a[] { 1,2,3 };  
int x = 1, y = 2;  
std::cout << a[x, y];
```

在上面的代码中，std::cout << a[x, y]；等同于std::cout << a[y]；，最后输出结果是3。不过从C++20标准开始，std::cout << a[x, y]；这句代码会被编译器提出警告，因为标准已经不推荐在下标表达式中使用逗号运算符了。该规则的提案文档明确地表示，希望array[x, y]这种表达方式能用在矩阵、视图、几何实体、图形API中。而对于老代码的维护者或者依旧想在下标表达式中使用逗号运算符的读者，可以在下标表达式外加上小括号来消除警告：

```rust
std::cout << a[(x, y)];
```

