# 34.5 支持new表达式推导数组长度（C++20）

一直以来， $\mathrm{C}++$ 在声明数组的时候都支持通过初始化时的元素个数推导数组长度，比如：

```javascript
int x[] { 1, 2, 3 }; char s[] {"hello world"};
```

这种声明数组的方式非常方便，特别是对于字符串数组而言，将计算数组所需长度的任务交给编译器，省去了我们挨个数字符检查的烦恼。但遗憾的是，这个特性并不完整，因为在用new表达式声明数组的时候无法把推导数组长度的任务交给编译器，所以下面的代码就无法成功编译了：

```javascript
int \*x = new int[] { 1, 2, 3 }; char \*s = new char[] { "hello world" };
```

好在C++20标准解决了以上问题。提案文档中强调在数组声明时根据初始化元素个数推导数组长度的特性应该是一致的，所以用以上方式声明数组理应是一个合法的语法规则。需要注意的是，到目前为止支持这一特性的编译器只有CLang，GCC和MSVC都是无法编译上面的代码的。

# 34.6 允许数组转换为未知范围的数组  $(C++20)$

在C++20标准中允许数组转换为未知范围的数组，例如：

```javascript
void f(int(&)[]) { int arr[1]; int main()
```

```javascript
f(arr); int(&r)[]  $=$  arr;
```

以上代码在C++20标准下可以正常编译通过。对于重载函数的情况，编译器依旧会选择更为精准匹配的函数：

```cpp
void f(int(&)[])   
{ std::cout << "call f(int(&)[])";   
}   
void f(int(&)[1])   
{ std::cout << "call f(int(&)[1])";   
} int arr[1];   
int main()   
{ f(arr);   
}
```

在上面的代码中，void f(int(&)[1])明显更匹配int arr[1];，所以输出结果为call f(int(&)[1])。需要注意的是，到目前为止只有GCC能够支持该特性。

# 34.7 在delete运算符函数中析构对象

# (C++20)

我们知道，通常情况下delete一个对象，编译器会先调用该对象的析构函数，之后才会调用delete运算符删除内存，例如：

```txt
include <new> struct X{ X（）{}
```

```cpp
$\sim \mathrm{X}(1)$  { std::cout << "call dtor" << std::endl; } void* operator new(size_t s) { return ::operator new(s); } void operator delete(void* ptr) { std::cout << "call delete" << std::endl; ::operator delete(ptr); } }；   
 $\mathrm{x}^{\star}\mathrm{x} =$  new X;   
delete x;
```

以上代码的输出结果必然是:

```txt
call dtor  
call delete
```

在C++20标准以前，这个析构和释放内存的操作完全由编译器控制，我们无法将其分解开来。但是从C++20标准开始，这个过程可以由我们控制了，而且实现方法也非常简单：

```cpp
struct X {
    X() {}
    ~X()
    {
        std::cout << "call dtor" << std::endl;
    }
    void* operator new(size_t s)
    {
        return ::operator new(s);
    }
    void operator delete(X* ptr, std::destroying_delete_t)
    {
        std::cout << "call delete" << std::endl;
        ::operator delete(ptr);
```

```txt
}；
```

请注意在上面的代码中，delete运算符发生的两个变化：第一个参数类型由void *修改为x *；增加了一个类型为std::destroying_delete_t的形参，且我们并不会用到它。编译器会识别到delete运算符形参的变化，然后由我们去控制对象的析构。比如在上面的代码中，我们没有调用析构函数，于是输出的结果如下：

```txt
call delete
```

在这种情况下，我们需要自己调用析构函数：

```cpp
void operator delete(X\*ptr，std::destroying_delete_t)   
{ ptr->\~X(); std::cout<<"call delete"<<std::endl; ::operator delete(ptr);   
}
```

