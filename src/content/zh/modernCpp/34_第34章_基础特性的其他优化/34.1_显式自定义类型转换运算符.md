# 34.1 显式自定义类型转换运算符（C++11）

$\mathrm{C} + +$  是支持自定义类型转换运算符的，通过自定义转换运算符可以对原本没有关系的两个类型进行转换，可以说为类型转换提供了不少方便。不过一直以来  $\mathrm{C} + +$  专家对自定义类型转换都保持谨慎的态度，其原因是自定义类型转换可能让程序员更容易写出与实际期待不符的代码，而编译器无法给出有效的提示，请观察以下代码：

```cpp
include<iostream> #include <vector> template<class T> class SomeStorage{ public: SomeStorage()  $=$  default; SomeStorage(std::initializer_list<T> l):data_(l){}; operator bool(){return !data_.empty();} private: std::vector<T> data_;   
}; int main() { SomeStorage(float>s1{1.,2.,3.}； SomeStorage<int>s2{1,2,3}； std::cout<<std::boolalpha; std::cout<<"s1  $\equiv$  s2:"<<(s1  $\equiv$  s2）<<std::endl; std::cout<<"s1+s2："<<(s1+s2）<<std::endl; }
```

以上代码的编译运行结果如下：

```txt
s1 == s2 : true  
s1 + s2 : 2
```

SomeStorage 是一个用于存储某类型数据的类模板。比如 SomeStorage <int> 用于存放整型数据，SomeStorage <float> 用于存放浮点数据。正常逻辑下这两个类的实例 s1 和 s2 是不能相等的，但是编译运行代码后发现 s1 == s2 的输出为 true。另外，这两个不相关的类居然还可以做加法运算，返回结果为 2，乍看起来完全没有道理。事实上，这里忽略了自定义类型转换运算符 operator bool() 的影响。在 s1 和 s2 比较和相加的过程中，编译器会对它们做隐式的自定义类型转换以符合比较和相加的条件。由于这两个对象都不为空，因此它们的返回值都为 true，s1 == s2 的运算结果自然也为 true，而求和运算会将 bool 转换为 int，于是输出运算结果为 2。可见，自定义类型转换运算符有时候就是这么不尽如人意。

另外，类型转换问题不止存在于自定义类型转换运算符中，构造函数中也同样有问题，例如：

```cpp
include<iostream>   
#include<string.h>   
class SomeString{   
public: SomeString(const char \*p) : str_(strdup(p)){} SomeString(int alloc_size): str_((char \*)mallocalloc_size)){ } ~SomeString(){ free(str_）; }   
private: char\*str; friend void PrintStr(const SomeString& str);   
}；
```

```cpp
void PrintStr(const SomeString& str)   
{ std::cout << str.str_<< std::endl;   
}   
int main()   
{ PrintStr("hello world"); PrintStr(58); //代码写错，却编译成功
```

SomeString类重载了两个构造函数，其中

SomeString(const char * p) 接受一个字符串作为参数并且将字符串复制到对象中，SomeString(int alloc_size) 接受一个整数用于分配字符串内存。函数PrintStr的意图是打印

SomeString的字符串。PrintStr("hello world")编译成功是符合预期的，因为字符串会隐式构造SomeString对象。奇怪的是PrintStr(58)这个函数的调用，很明显这不是程序员写PrintStr函数的意图，真正的意图可能是PrintStr("58")，但由于粗心漏掉了引号。问题来了，编译器面对这样的代码不会给出任何错误或者警告提示。因为编译器会将58作为参数通过SomeString(intalloc_size)构造函数构造成SomeString对象。

当然了， $\mathrm{C}++$  已经考虑到了构造函数面临的这种问题，我们可以使用explicit说明符将构造函数声明为显式，这样隐式的构造无法通过编译：

```cpp
class SomeString { public: SomeString(const char \* p) : str_(_strdup(p)) {} explicit SomeString(int alloc_size) : str_((char
```

```c
\*)mallocalloc_size){} ~SomeString(）{free(str_）; } private: char \*str_; friend void PrintStr(const SomeString& str);   
};   
int main() { PrintStr("hello world"); PrintStr(58)； //编译失败 PrintStr(SomeString(58));   
1
```

以上代码用explicit说明符声明了SomeString(int alloc_size)，这样一来通过整数构造对象必须用显式的方式，所以PrintStr(58)会编译失败。

借鉴显式构造函数的成功经验，C++11标准将explicit引入自定义类型转换中，称为显式自定义类型转换。语法上和显式构造函数如出一辙，只需在自定义类型转换运算符的函数前添加explicit说明符，例如：

```cpp
include<iostream>   
#include <vector>   
template<class T>   
class SomeStorage{   
public: SomeStorage()  $=$  default; SomeStorage(std::initializer_list<T>1):data_(l){} explicit operator bool() const {return !data_.empty(); } private: std::vector<T> data_;   
};   
int main(){ SomeStorage<float>s1{1.,2.,3.}； SomeStorage<int>s2{1,2,3}；
```

```cpp
std::cout << std::boolalpha;  
std::cout << "s1 == s2 : " << (s1 == s2) << std::endl; //编译失败  
std::cout << "s1 + s2 : " << (s1 + s2) << std::endl; //编译失败  
std::cout << "s1 : " << static_cast bool>(s1) << std::endl;  
std::cout << "s2 : " << static_cast bool>(s2) << std::endl;  
if (s1) {  
    std::cout << "s1 is not empty" << std::endl;  
}
```

以上代码给operator bool()添加了explicit说明符，将自定义类型转换运算符声明为显式的。于是，在编译s1 == s2和s1 + s2的时候我们收到了两条错误信息，因为现在已经无法隐式地调用自定义类型转换运算符函数了，而显式地转换static_cast <bool>(s1)和static_cast bool>(s2)则可以编译成功。在这份代码中我们还发现了另外一个有趣的地方，if语句内的s1可以成功地调用显式自定义转换函数将其转换为bool类型而不会引发编译错误，这似乎和显式自定义类型转换运算符有些矛盾。实际上，这个“矛盾”恰好是C++11标准所允许的。

为了做进一步解释，这里需要引入布尔转换，顾名思义就是将其他类型转换为bool。对于布尔转换，C++11标准为其准备了一些特殊规则以减少代码冗余：在某些期待上下文为bool类型的语境中，可以隐式执行布尔转换，即使这个转换被声明为显式。这些语境包括以下几种。

if、while、for的控制表达式。

内建逻辑运算符!、&&和||的操作数。

条件运算符?:的首个操作数。

static_assert声明中的bool常量表达式。

noexcept说明符中的表达式。

以上语境对类型进行布尔转换是非常自然的，并不会产生其他不良的影响，而且会让代码更加简练，容易理解。

最后需要说明的是，新标准库也充分利用了显式自定义类型转换特性，比如std::unique_ptr定义了显式bool类型转换运算符来指示智能指针的内部指针是否为空，std::ifstream定义了显式bool类型转换运算符来指示是否成功打开了目标文件等。

# 34.2 关于std::lander()（C++17）

std::l杀菌()是C++17标准库中新引入的函数，虽然本书并不打算介绍标准库中新增的内容，但是对于std::l杀菌()还是有必要说明一下的，因为它想要解决的是C++语言的一个核心问题。让我们通过标准文档中的例子看一看这个问题到底是什么？

```txt
struct X { const int n; }
union U{X x; float f;}
```

请注意上面的代码片段中，结构体x的数据成员n是一个const int类型。接下来聚合初始化联合类型U：

```javascript
U u = {{1}};
```

现在const int类型数据成员n被初始化为1，由于n的常量性，编译器可以总是认为u.x.n为1。接下来我们使用replace new的方法重写初始化这块内存区域：

```txt
X \*p = new (&u.x) X {2};
```

新创建的p->n的值为2。现在问题来了，请读者想一想u.x.n的值应该是多少？如果只是从内存的角度来看，毫无疑问这里的结果是2，但是事情往往没那么简单，由于u.x.n是一个常量且初始化为1，因此编译器有理由认为u.x.n是无法被修改的，通过一些优化后u.x.n的结果有可能为1。实际上在标准看来，这个结果是未定义的。在经过replace new的操作后，我们不能直接使用u.x.n，只能通过p来访问n。

具体来说，C++标准规定：如果新的对象在已被某个对象占用的内存上进行构建，那么原始对象的指针、引用以及对象名都会自动转向新的对象，除非对象是一个常量类型或对象中有常量数据成员或者引用类型。简单来说就是，如果数据结构x的数据成员n不是一个常量类型，那么u.x.n的结果一定是2。但是由于常量性的存在，从语法规则来说x已经不具备将原始对象的指针、引用以及对象名自动转向新

对象的条件，因此结果是未定义的，要访问n就必须通过新对象的指针p。实际上，这并不是一个新的语法规则，不过好像大多数人对此不太了解。

标准库引入std::lander()就是为了了解决上述问题，标准文档的例子中：

```txt
| assert(*std::洗衣机(&u.x.n) == 2);
```

它是一个有定义的行为，而且获取n的值也保证为2。怎么理解std::l杀菌()呢？在我看来不妨从字面意思理解，l杀菌在英文中有清洗和刷洗的意思。而在这里不妨理解为洗内存，它的目的是防止编译器追踪到数据的来源以阻止编译器对数据的优化。最后要说一句，如果读者阅读std::l杀菌的代码可能会感到惊讶，因为这个函数什么也没做，类似于：

```txt
template<typename T> constexpr T* launder(T* p) noexcept {
    return p;
}
```

没错，到目前为止这个函数确实什么也没做。Botond Ballo曾在2016年芬兰奥卢的C++标准委员会会议报告中写到过关于std::洗衣机()的体会。

# 34.3 返回值优化（ $\mathrm{C}++11 \sim \mathrm{C}++17$ ）

返回值优化是C++中的一种编译优化技术，它允许编译器将函数返回的对象直接构造到它们本来要存储的变量空间中而不产生临时对象。严格来说返回值优化分为RVO（Return Value Optimization）和NRVO（Named Return Value Optimization），不过在优化方法上的区别并不大，一般来说当返回语句的操作数为临时对象时，我们称之为RVO；而当返回语句的操作数为具名对象时，我们称之为NRVO。在C++ 11标准中，这种优化技术被称为复制消除（copy elision）。如果使用GCC作为编译器，则这项优化技术是默认开启的，取消优化需要额外的编译参数“-fno-(-(constructors)”。

让我们从下面的例子开始对返回值优化技术进行探索：

```cpp
include<iostream>   
class X{   
public: X() { std::cout << "X cctor" << std::endl; } X(const X&x) { std::cout << "X copy cctor" << std::endl; } ~X() { std::cout << "Xdotor" << std::endl; }   
}；   
Xmake_x()   
{ xx1; return x1;   
}   
int main()   
{ Xx2  $\equiv$  make_x();
```

可以看到函数make_x()返回了对象x1并赋值到x2上，理论上说这其中必定需要经过两次复制构造函数，第一次是x1复制到临时对

象，第二次是临时对象复制到x2。现在让我们用GCC编译并且运行这份代码，会输出结果：

```txt
Xctor X dtor
```

令人吃惊的是，整个过程一次复制构造都没有调用，这就是NRVO的效果。如果这里将make_x函数改为：

```txt
X make_x()
{
return X();
}
```

也会收到同样的效果，只不过优化技术名称从NRVO变成了RVO。

接下来在编译命令行中添加开关“-fno-(-(constructors)”，然后再次编译运行该代码，这时的输出结果如下：

```txt
X c t o r  
X copy c t o r  
X d t o r  
X copy c t o r  
X d t o r  
X d t o r
```

这才是我们刚刚预想的结果，一个默认构造函数和两个复制构造函数的调用。从结果可以看出返回值优化的效果特别理想，整整减少了两次复制构造和析构，这对于比较复杂或者占用内存很大的对象来说将是很重要的优化。

但是请别高兴得太早，实际上返回值优化是很容易失效的，例如：

```cpp
include<iostream>   
#include <ctime>   
class X{   
public: X() { std::cout << "X cctor" << std::endl; } X(const X&x) { std::cout << "X copy cctor" << std::endl; } ~X() { std::cout << "Xdotor" << std::endl; }   
}；   
Xmake_x()   
{ X x1，x2; if(std::time(nullptr)  $\% 50 = = 0$  ）{ return x1; } else{ return x2; }   
}   
int main()   
{ X x3  $=$  make_x();
```

现在make_x()函数不确定会返回哪个对象了，如果继续在GCC中添加“-fno-(-(constructors)”开关进行编译，则运行时依然会出现两次复制构造函数：

```txt
X ctor  
X ctor  
X copy ctor  
X dtor  
X dtor  
X copy ctor  
X dtor  
X dtor
```

若删除“-fno-(-(constructors)”开关是否会消除复制构造函数呢？答案是否定的，这时只能消除一次复制构造：

```txt
X cctor X cctor X copy cctor X dtor X dtor X dtor
```

原因其实很容易想到，由于以上代码中究竟由x1还是x2复制到x3是无法在编译期决定的，因此编译器无法在默认构造阶段就对x3进行构造，它需要分别将x1和x2构造后，根据运行时的结果将x1或者x2复制构造到x3，在这个过程中返回值优化技术也尽其所能地将中间的临时对象优化掉了，所以这里只会看到一次复制构造函数的调用。

为了让读者更清晰地了解这部分的过程，我们让GCC生成中间代码GIMPLE，然后对比其中的区别。

不带“-fno-eligible-constructors”的中间代码：

```txt
make_x()
{
struct X x1 [value-expr: *<retval)];
X::X (<retval]);
try
{
return <retval};
}
catch
{
X::~X (<retval]);
}
}
```

```javascript
{ int D.39995; { struct X x2; try {  $\mathrm{x2} =$  make_x(); [return slot optimization] try { } finally { X::~X (&x2); } } finally { x2  $=$  {CLOBBER}; } D.39995  $= 0$  return D.39995;
```

带“-fno-(-(constructors)”的中间代码：

```txt
make_x()
{
struct X x1;
try
{
X::X (&x1);
try
{
X::X (<retrval>, &x1);
return <retrval};
}
finally
{
X::~X (&x1);
}
}
finally
```

```txt
$\begin{array}{l}\mathrm{x1} = \{\mathrm{CLOBBER}\} ;\\ \end{array}$    
}   
...   
main ()   
{ struct X D.36509; int D.40184; { struct X x2; try { D.36509  $=$  make_x(); [return slot optimization] try { try { X::X (&x2, &D.36509); } finally { try { X::~X (&D.36509); } catch { X::~X (&x2); } } } finally { D.36509  $=$  {CLOBBER}; } try { } finally { X::~X (&x2); } }finally { x2  $=$  {CLOBBER}; }
```

```javascript
} D.40184  $= 0$  returnD.40184;
```

读者看出其中的区别了吗？

1. make_x函数中前者直接使用调用者的返回值构造x::x(<reval>);，而后者使用x1构造x::x (&x1);，在构造结束之后再复制到返回值x::x (<reval>, &x1);。  
2. 在main函数中前者在make_x后没有任何复制动作，因为这时x2已经构建完成，而后者先调用D.36509 = make_x();将返回值复制到临时对象，然后再通过X::X (&x2, &D.36509);复制到x2。

另外值得注意的是，虽然返回值优化技术可以省略创建临时对象和复制构造的过程，但是C++11标准规定复制构造函数必须是存在且可访问的，否则程序是不符合语法规则的，例如：

```cpp
include<iostream>   
class X{   
public: X() { std::cout << "X cctor" << std::endl; } \~X() { std::cout << "Xdctor" << std::endl; }   
private: X(const X&x) { std::cout << "X copy cctor" << std::endl; }   
}；   
Xmake_x() { return X();   
}   
int main()   
{
```

```javascript
Xx2  $=$  make_x();
```

在上面的代码中，我们将类x的复制构造函数设置为私有。根据返回值优化的要求，复制构造函数必须是可访问的，所以上面的代码在C++11的编译环境下将会导致编译错误。

C++14标准对返回值优化做了进一步的规定，规定中明确了对于常量表达式和常量初始化而言，编译器应该保证RVO，但是禁止NRVO。

在C++17标准中提到了确保复制消除的新特性，它从另一个角度出发对C++进行了性能优化，而且也能达到RVO的效果。该特性指出，在传递临时对象或者从函数返回临时对象的情况下，编译器应该省略对象的复制和移动构造函数，即使这些复制和移动构造还有一些额外的作用，最终还是直接将对象构造到目标的存储变量上，从而避免临时对象的产生。标准还强调，这里的复制和移动构造函数甚至可以是不存在或者不可访问的。

以上描述可以分为两个部分理解，首先对于临时对象强制省略对象的复制和移动构造函数，这一点实际上和RVO一样，只是对编译器提出了硬性要求。其次，也是最引人注意的一点，它允许复制和移动构造函数是不存在和不可访问的。在上面的例子中我们已经看到，返回值优化对于这一点是不允许的，现在我们不妨将上面代码的编译环境切换到C++17，读者一定会惊喜地发现代码编译成功了。另外，我们甚至可以更激进一些，显式删除复制构造函数：

```javascript
X(const X&x) = delete;
```

同样会发现，这份代码依然能正确地编译运行。这一点带来的最大好处是，所有类型都能使用工厂函数，即使该类型没有复制或者移动构造函数，例如：

```cpp
include <atomic>   
template<class T, class Arg>   
T create(Arg&& arg)   
{ return T(std::forward<Arg>(arg));   
}   
int main()   
{ std::atomic<int> x = create<std::atomic<int>>>(11);   
}
```

请注意上面的代码，由于std::atomic的复制构造函数被显式删除了，同时编译器也不会提供默认的移动构造函数，因此在C++17之前是无法编译成功的。而在C++17的标准下则不存在这个问题，代码能够顺利地编译运行。

最后提醒读者一点，返回值优化虽然能够帮助我们减少返回对象的复制，但是作为程序员还是应该尽量减少对这些优化的依赖，因为不同的编译器对其的支持可能是不同的。面对传递对象的需求，我们可以尽量通过传递引用参数的方式完成，不要忘了C++11中支持的移动语义，它也能在一定程度上代替返回值优化的工作。

