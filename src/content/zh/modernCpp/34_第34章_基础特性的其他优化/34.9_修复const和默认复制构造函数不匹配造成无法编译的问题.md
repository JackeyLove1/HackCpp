# 34.9 修复const和默认复制构造函数不匹配造成无法编译的问题（C++20）

考虑这样一个类或者结构体，它编写复制构造函数的时候没有使用const：

```txt
struct MyApp {
    MyApp() = default;
    MyApp(MyType&) {}
};
```

```txt
template <typename T> struct Wrapper {
    Wrapper() = default;
    Wrapper(const Wrapper&) = default;
    T t;
};
```

Wrapper的复制构造函数的形参是const版本而其成员MyType不是，这种不匹配在C++17和以前的标准中是不被允许的。但仔细想想，这样的规定并不合理，因为代码并没有试图去调用复制构造函数。在C++20标准中修正了这一点，如果不发生复制动作，这样的写法是可以通过编译的。需要注意的是，就目前的编译器情况来看MSVC和GCC都对C++17标准做了优化，也就是说以上代码无论在

C++17还是C++20标准上都可以编译通过，只有CLang严格遵照标准，在C++17的环境下会报错。当然：

```txt
Wrapper<MyType> var1;  
Wrapper<MyType> var2(var1);
```

这样的写法是无论如何都会编译失败的。

