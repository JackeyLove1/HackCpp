# 4.5 decltype(auto)

在C++14标准中出现了decltype和auto两个关键字的结合体：decltype (auto)。它的作用简单来说，就是告诉编译器用decltype的推导表达式规则来推导auto。另外需要注意的是，decltype (auto) 必须单独声明，也就是它不能结合指针、引用以及cv限定符。看完下面的例子，读者就会有所体会：

```cpp
int i;  
int&& f();  
auto x1a = i; // x1a推导类型为int  
decltypeauto) x1d = i; // x1d推导类型为int  
auto x2a = (i); // x2a推导类型为int  
decltype( auto ) x2d = (i); // x2d推导类型为int&  
auto x3a = f(); // x3a推导类型为int  
decltype( auto ) x3d = f(); // x3d推导类型为int&&  
auto x4a = { 1, 2 }; // x4a推导类型为  
std::initializer_list<int>  
decltype( auto ) x4d = { 1, 2 }; //编译失败，{1，2}不是表达式  
auto *x5a = &i; // x5a推导类型为int*  
decltype( auto ) *x5d = &i; //编译失败，decltype( auto)必须单独声  
明
```

观察上面的代码可以发现，auto和decltype (auto) 的用法几乎相同，只是在推导规则上遵循decltype而已。比如 (i) 在auto规

则的作用下，x2a的类型被推导为int，而x2d的类型被推导为

int&。另外，由于decltype(auto)必须单独声明，因此x5d无法

通过编译。

接下来让我们看一看decltype (auto)是如何发挥作用的。还记得decltype不可被auto代替的例子吗？return_ref想返回一个引用类型，但是如果直接使用auto，则一定会返回一个值类型。这让我们不得不采用返回类型后置的方式声明返回类型。

现在有了decltype(auto)组合，我们可以进一步简化代码，消除返回类型后置的语法，例如：

```c
template<class T>  
decltype auto) return_ref(T& t)  
{  
    return t;  
}  
int x1 = 0;  
static_assert( std::is_reference_v<decltype_return_ref(x1))> //编译成功
```

