# 4.2 使用decltype说明符

为了用统一方法解决上述问题，C++11标准引入了decltype说明符，使用decltype说明符可以获取对象或者表达式的类型，其语法与typeof类似：

```cpp
int x1 = 0;  
decltype(x1) x2 = 0;  
std::cout << typeid(x2).name() << std::endl; // x2的类型为int  
double x3 = 0;  
decltype(x1 + x3) x4 = x1 + x3;  
std::cout << typeid(x4).name() << std::endl; // x1+x3的类型为double  
decltype({1, 2}) x5; //编译失败，{1, 2}不是表达式
```

以上代码展示了decltype的一般用法，代码中分别获取变量x1和表达式x1+x3的类型并且声明该类型的变量。但是decltype的使用场景还远远不止于此。还记得在第3章中讨论过auto不能在非静态成员变量中使用吗？decltype却是可以的：

```txt
struct S1 {
    int x1;
    double x2;
    double x3;
    double x4;
};
```

比如，在函数的形参列表中使用：

```c
int x1 = 0;  
decltype(x1) sum(decltype(x1) a1, decltype(a1) a2)  
{  
    return a1 + a2;  
}  
auto x2 = sum(5, 10);
```

看到这里，读者应该会质疑decltype是否有实际用途，因为到目前为止我们看到的无非是一些画蛇添足的用法，直接声明变量类型

或者使用auto占位符要简单得多。确实如此，上面的代码并没有展示decltype的独特之处，只是描述其基本功能。

为了更好地讨论decltype的优势，需要用到函数返回类型后置（见第5章）的例子：

```txt
auto sum(int a1, int a2) -> int  
{  
    return a1 + a2;  
}
```

以上代码以C++11为标准，该标准中auto作为占位符并不能使编译器对函数返回类型进行推导，必须使用返回类型后置的形式指定返回类型。如果接下来想泛化这个函数，让其支持各种类型运算应该怎么办？由于形参不能声明为auto，因此我们需要用到函数模板：

```txt
template<class T> T sum(T a1, T a2) {
    return a1 + a2;
}
```

代码看上去很好，但是并不能适应所有情况，因为调用者如果传递不同类型的实参，则无法编译通过：

```javascript
auto x2 = sum(5, 10.5); // 编译失败，无法确定T的类型
```

既然如此，我们只能编写一个更加灵活的函数模板：

```txt
template<class R, class T1, class T2> R sum(T1 a1, T2 a2)
```

```lua
return a1 + a2;   
}   
auto x3 = sum<double>(5, 10.5);
```

不错，这样好像可以满足我们泛化sum函数的要求了。但美中不足的是我们必须为函数模板指定返回值类型。为了让编译期完成所有的类型推导工作，我们决定继续优化函数模板：

```cpp
template<class T1, class T2> auto sum(T1 a1, T2 a2) ->cdecl(a1 + a2) {
    return a1 + a2;
} auto x4 = sum(5, 10.5);
```

decltype终于登场了，可以看到它完美地解决了之前需要指定返回类型的问题。解释一下这段代码，auto是返回类型的占位符，参数类型分别是T1和T2，我们利用decltype说明符能推断表达式的类型特性，在函数尾部对auto的类型进行说明，如此一来，在实例化sum函数的时候，编译器就能够知道sum的返回类型了。

上述用法只推荐在C++11标准的编译环境中使用，因为C++14标准已经支持对auto声明的返回类型进行推导了，所以以上代码可以简化为：

```txt
template<class T1, class T2> auto sum(T1 a1, T2 a2) {
    return a1 + a2;
} auto x5 = sum(5, 10.5);
```

讲到这里，读者肯定有疑问了，在C++14中decltype的作用又被auto代替了。是否从C++14标准以后decltype就没有用武之地了呢？并不是这样的，auto作为返回类型的占位符还存在一些问题，请看下面的例子：

```cpp
template<class T> auto return_ref(T& t) {
    return t;
}
int x1 = 0;
static_assert(
    std::is.reference_v<decltype_return_ref(x1))>/编译错误，返回值不为引用类型
);
```

在上面的代码中，我们期望return_ref返回的是一个T的引用类型，但是如果编译此段代码，则必然会编译失败，因为auto被推导为值类型，这就是第3章所讲的auto推导规则2。如果想正确地返回引用类型，则需要用到decltype说明符，例如：

```cpp
template<class T> auto return_ref(T& t) ->cdecl(t)
{
    return t;
}
int x1 = 0;
static_assert(
    std::is.reference_v<decltype_return_ref(x1))> // 编译成功
);
```

以上两段代码几乎相同，只是在return_ref函数的尾部用decltype(t)声明了返回类型，但是代码却可以顺利地通过编译。

为了弄清楚编译成功的原因，我们需要讨论decltype的推导规则。

