# 4.4 cv限定符的推导

通常情况下，decltype(e)所推导的类型会同步e的cv限定符，比如：

```txt
const int i = 0;  
decltype(i); //decltype(i)推导类型为const int
```

但是还有其他情况，当e是未加括号的成员变量时，父对象表达式的cv限定符会被忽略，不能同步到推导结果：

```txt
struct A {
    double x;
};
const A* a = new A();
decltype(a->x); // decltype(a->x) 推导类型为double，const属性被忽略
```

在上面的代码中，a被声明为const类型，如果想在代码中改变a中x的值，则肯定会编译失败。但是decltype(a->x)却得到了一个没有const属性的double类型。当然，如果我们给a->x加上括号，则情况会有所不同：

```sql
struct A{ double x;
```

```cpp
};  
const A* a = new A();  
decltype((a->x)); //decltype((a->x))推导类型为const double&
```

总的来说，当e是加括号的数据成员时，父对象表达式的cv限定符会同步到推断结果。

