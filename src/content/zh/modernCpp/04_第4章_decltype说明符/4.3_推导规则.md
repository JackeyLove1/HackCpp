# 4.3 推导规则

decltype(e)（其中e的类型为T）的推导规则有5条。

1. 如果e是一个未加括号的标识符表达式（结构化绑定除外）或者未加括号的类成员访问，则decltype(e)推断出的类型是e的类型T。如果并不存在这样的类型，或者e是一组重载函数，则无法进行推导。  
2. 如果  $e$  是一个函数调用或者仿函数调用，那么decltype(e)推断出的类型是其返回值的类型。  
3. 如果e是一个类型为T的左值，则decltype(e)是T&。  
4. 如果e是一个类型为T的将亡值，则decltype(e)是T&&。  
5. 除去以上情况，则decltype(e)是T。

根据这5条规则，我们来看一看C++标准文档给的几个例子：

```txt
const int&& foo();  
int i;  
struct A {double x;};  
const  $\mathrm{A}^{\star}\mathrm{a} =$  new A();  
decltype(foo()); //decltype(foo())推导类型为const int&&  
decltype(i); //decltype(i)推导类型为int
```

```cpp
decltype(a->x); // decltype(a->x) 推导类型为double
decltype((a->x)); // decltype((a->x)) 推导类型为const double&
```

在上面的代码中，decltype(foo())满足规则2和规则4，foo函数的返回类型是const int&&，所以推导结果也为const int&&；decltype(i)和decltype(a->x)很简单，满足规则1，所以其类型为int和double；最后一句代码，由于decltype((a->x))推导的是一个带括号的表达式(a->x)，因此规则1不再适用，但很明显a->x是一个左值，又因为a带有const限定符，所以其类型被推导为const double&。

如果读者已经理解了decltype的推导规则，不妨尝试推导下列代码中decltype的推导结果：

```c
int i;  
int *j;  
int n[10];  
const int&& foo();  
decltype(static_cast<short>(i)); //decltype(static_cast<short>(i))推导类 //型为short  
decltype(j); //decltype(j)推导类型为int*  
decltype(n); //decltype(n)推导类型为int[10]  
decltype(foo); //decltype(foo)推导类型为int const && (void)  
struct A {  
    int operator() () { return 0; }  
};  
A a;  
decltype(a()); //decltype(a())推导类型为int
```

最后让我们看几个更为复杂的例子:

```cpp
int i;  
int *j;  
int n[10];  
decltype(i=0); //decltype(i=0)推导类型为int&  
decltype(0,i); //decltype(0,i)推导类型为int&  
decltype(i,0); //decltype(i,0)推导类型为int  
decltype(n[5]); //decltype(n[5])推导类型为int&  
decltype(*j); //decltype(*j)推导类型为int&  
decltype(static_cast<int&&>(i)); //decltype(static_cast<int&&>(i))推导类  
//型为int&&  
//decltype(i++)推导类型为int  
//decltype(++i)推导类型为int&  
//decltype("hello world"); //decltype("hello world")推导类型为  
//const char(&)[12]
```

让我们来看一看上面代码中的例子都是怎么推导出来的。

1. 可以确认以上例子中的表达式都不是标识符表达式，这样就排除了规则1。  
2.  $i = 0$  和  $0, i$  表达式都返回左值  $i$ , 所以推导类型为 int&。  
3. i, 0 表达式返回 0 , 所以推导类型为 int。  
4. n[5]返回的是数组n中的第6个元素，也是左值，所以推导类型为int&。  
5. *j很明显也是一个左值，所以推导类型也为int&。  
6. static cast<int&&>(i) 被转换为一个将亡值类型，所以其推导类型为int&&。

7. i++和++i分别返回右值和左值，所以推导类型分别为int和int&。  
8. hello world是一个常量数组的左值，其推导类型为const char(&) [12]。

