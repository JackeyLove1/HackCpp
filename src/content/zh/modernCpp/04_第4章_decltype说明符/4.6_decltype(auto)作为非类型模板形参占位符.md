# 4.6 decltype(auto)作为非类型模板形参占位符

与auto一样，在C++17标准中decltype (auto)也能作为非类型模板形参的占位符，其推导规则和上面介绍的保持一致，例如：

```cpp
include<iostream> template<decltypeauto）N> voidf() { std::cout<<N<<std::endl;
```

```txt
}   
static const int x = 11;   
static int y = 7;   
int main()   
{ f<x>(); // N为const int类型 f<(x)>(); // N为const int&类型 f<y>(); //编译错误 f<(y)>(); //N为int&类型
```

在上面的代码中，x的类型为const int，所以f<x>( )推导出N为const int类型，这里和auto作为占位符的结果是一样的；

$\mathrm{f} < (\mathrm{x}) > ()$  则不同，推导出的N为const int&类型，符合

decltype (auto) 的推导规则。另外，f<y>( )会导致编译出错，因为y不是一个常量，所以编译器无法对函数模板进行实例化。而

f  $<  \left( \begin{array}{l}\mathrm{y} \end{array} \right) >$  () 则没有这种问题，因为(y)被推断为了引用类型，恰好对于静态对象而言内存地址是固定的，所以可以顺利地通过编译，最终N被推导为int&类型。

