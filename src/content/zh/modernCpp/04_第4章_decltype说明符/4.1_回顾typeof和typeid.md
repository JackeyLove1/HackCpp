# 4.1 回顾typeof和typeid

在C++11标准发布以前，GCC的扩展提供了一个名为typeof的运算符。通过该运算符可以获取操作数的具体类型。这让使用GCC的程序员在很早之前就具有了对对象类型进行推导的能力，例如：

```txt
int  $a = 0$  ·  
typeof(a)  $\texttt{b} = 5;$
```

由于typeof并非C++标准，因此就不再深入介绍了。关于typeof更多具体的用法可以参考GCC的相关文档。

除使用GCC提供的typeof运算符获取对象类型以外，C++标准还提供了一个typeid运算符来获取与目标操作数类型有关的信息。获取的类型信息会包含在一个类型为std::type_info的对象里。我们可以调用成员函数name获取其类型名，例如：

```cpp
int x1 = 0;  
double x2 = 5.5;  
std::cout << typeid(x1).name() << std::endl;  
std::cout << typeid(x1 + x2).name() << std::endl;  
std::cout << typeid(int).name() << std::endl;
```

值得注意的是，成员函数name返回的类型名在C++标准中并没有明确的规范，所以输出的类型名会因编译器而异。比如，MSVC会输出一个符合程序员阅读习惯的名称，而GCC则会输出一个它自定义的名称。另外，还有3点也需要注意。

1. typeid的返回值是一个左值，且其生命周期一直被扩展到程序生命周期结束。  
2. typeid返回的std::type_info删除了复制构造函数，若想保存std::type_info，只能获取其引用或者指针，例如：

```cpp
auto t1 = typeid(int); //编译失败，没有复制构造函数无法编译  
auto &t2 = typeid(int); //编译成功，t2推导为const std::type_info&  
auto t3 =typeid(int); //编译成功，t3推导为const std::type_info*
```

3. typeid的返回值总是忽略类型的 cv 限定符，也就是 typeid(const T) == typeid(T)。

虽然typeof可以获取类型信息并帮助我们判断类型之间的关系，但遗憾的是，它并不能像typeof那样在编译期就确定对象类型。

