# 31.1 GCC的属性语法

GCC从2.9.3版本开始支持GCC手册的属性语法，后来一些编译器为了兼容以GCC为基础编写的代码也纷纷支持了GCC的属性语法。GCC的属性语法如下：

```txt
_attribute_((attribute-list))
```

请注意，GCC添加了一个扩展关键字__attribute__，这个关键字前后都有双下画线并且紧跟着两对括号，用如此烦琐的语法作为说明符的目的一方面是防止入侵C++标准，另一方面是避免和现有代码发生冲突。GCC的属性语法十分灵活，它能够用于结构体、类、联合类型、枚举类型、变量或者函数。比如前面介绍的设置对齐字节长度就是GCC的属性语法：

```cpp
include<iostream>   
#define PRINT ALIGNN(c,v) \ std::cout  $<  <   \text{巧}$  alignof(" #c "）  $= \text{串}$ $<  <   \text{巧}$  alignof(c）\  $\ll$  ",alignof(" #v")  $= \text{串}$ $<  <   \text{巧}$  alignof(v）  $<  <   \text{巧}$  std::endl __attribute_((aligned(16))) class X { int i; } a; class __attribute_((aligned(16)))X1 { int i; } a1; class X2 { int i; } __attribute_((aligned(16))) a2; class X3 { int i; } a3 __attribute_((aligned(16));
```

```txt
int main()   
{ PRINT ALIGN(X，a); PRINT ALIGN(X1，a1); PRINT ALIGN(X2，a2); PRINT ALIGN(X3，a3);
```

以上代码的输出结果如下：

```txt
alignof(X) = 4, alignof(a) = 16
alignof(X1) = 16, alignof(a1) = 16
alignof(X2) = 16, alignof(a2) = 16
alignof(X3) = 4, alignof(a3) = 16
```

可以看出，根据__attribute__(aligned(16))所在语句位置的不同，对类和对象的作用是不同的。首先，放置在用户定义类型开始处的属性是声明类型的变量，而非类型本身，所以

_attribute_((aligned(16))) class X { int i; } a; 中对象a的对齐字节长度为16字节，而类x的对齐字节长度为默认的4字节。然后，放置在class关键字或者整个类声明之后的属性声明的是类型本身，一旦类型的对齐字节长度确定下来，其对象的对齐字节长度也就确定了下来，所以在

```txt
class_attribute_((aligned(16)))X1{inti;} a1;和classX2{inti；}__attribute_((aligned
```

(16)) a2; 中类x1、x2以及对象a1、a2的对齐字节长度都是16字节。最后，放置在声明对象之后的属性声明的是对象本身，所以class x3 { int i; } a3 __attribute__(aligned  
(16))；中对象a3的对齐字节长度为16字节，而类x3的对齐字节长度为默认的4字节。实际上属性描述的范围非常广，除了刚刚提到的类

和对象以外，对联合类型、函数等都可以进行声明，它还有属性覆盖和组合的规则，有兴趣的读者可以阅读GCC手册中关于属性的内容，这里就不再展开介绍了。

