# 31.4 使用using打开属性的命名空间

上文提到过，为了防止不同编译器厂商在扩展属性的时候发生冲突，标准属性的语法支持了命名空间，举个例子（这个例子请使用GCC9.1或者以上的版本编译）：

```txt
[[gpu::always_inline]] [[gpu::hot]] [[gpu::const]] [[nodiscard]] inline int f();
```

或者

```txt
[[gpu::always_inline,gpu::hot,gnu::const,nodiscard]] inline int f();
```

在这个例子中，GCC命名空间虽然保护了其属性不会受到其他属性的影响，但是为了声明这些属性，程序员不得不重复指示命名空间，这造成了代码冗余。C++17标准对命名空间属性声明做了优化，它引入了using关键字打开属性命名空间，随后即可直接使用命名空间的属性从而减少代码冗余，其语法如下：

```json
[[using attribute-namespace:attribute-list]]
```

其中attribute-namespace是命名空间的名称，attribute-list是命名空间内的属性，它们直接使用冒号分隔，多属性之间使用逗号分隔。现在让我们进一步改写函数f的属性：

```txt
[[using gmail: always_inline, hot, const]] [[nodiscard]] inline int f();
```

在这个版本中我们将属性分为了两块，一块是标准属性

nodiscard，另一块是带有GCC命名空间的扩展属性

always_inline、hot和const。可以看到使用新的语法不仅消除了命名空间的冗余问题，而且很好地对属性进行了分类，让属性的修改和阅读都变得更加方便了。C++17标准还规定，编译器应该忽略任何无法识别的属性。

