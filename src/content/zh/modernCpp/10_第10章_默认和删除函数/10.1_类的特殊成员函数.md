# 10.1 类的特殊成员函数

在定义一个类的时候，我们可能会省略类的构造函数，因为  $\mathrm{C}++$  标准规定，在没有自定义构造函数的情况下，编译器会为类添加默认的构造函数。像这样有特殊待遇的成员函数一共有6个（ $\mathrm{C}++11$  以前是4个），具体如下。

1. 默认构造函数。  
2. 析构函数。  
3. 复制构造函数。  
4. 复制赋值运算符函数。  
5. 移动构造函数（C++11新增）。  
6. 移动赋值运算符函数（C++11新增）。

添加默认特殊成员函数的这条特性非常实用，它让程序员可以有更多精力关注类本身的功能而不必为了某些语法特性而分心，同时也避免了让程序员编写重复的代码，比如：

```cpp
include <string>   
#include <vector>   
class City { std::string name; std::vector<std::string> street_name;   
}；   
int main()   
{ City a，b;  $\mathrm{a} = \mathrm{b}$  ·
```

在上面的代码中，我们虽然没有为City类添加复制赋值运算符函数City:: operator = (const City &, 但是编译器仍然可以成功编译代码，并且在运行过程中正确地调用std::string和std::vector<std::string>的复制赋值运算符函数。假如编译器没有提供这条特性，我们就不得不在编写类的时候添加以下代码：

```cpp
City& City::operator=(const City & other)   
{ name  $=$  other.name; street_name  $\equiv$  other_street_name; return \*this;   
}
```

很明显，编写这段代码除了满足语法的需求以外没有其他意义，很庆幸可以把这件事情交给编译器去处理。不过还不能高兴得太早，因为该特性的存在也给我们带来了一些麻烦。

1. 声明任何构造函数都会抑制默认构造函数的添加。  
2. 一旦用自定义构造函数代替默认构造函数，类就将转变为非平凡类型。

3. 没有明确的办法彻底禁止特殊成员函数的生成（C++11之前）。

下面来详细地解析这些问题，还是以City类为例，我们给它添加一个构造函数：

```cpp
include <string>   
#include <vector>   
class City{ std::string name; std::vector<std::string>street_name; public: City(const char \*n) :name(n){} }； int main() { City a("wuhan"); City b; //编译失败，自定义构造函数抑制了默认构造函数  $b = a$  1
```

以上代码由于添加了构造函数City(const char *n)，导致编译器不再为类提供默认构造函数，因此在声明对象b的时候出现编译错误，为了解决这个问题我们不得不添加一个无参数的构造函数：

```cpp
class City {
    std::string name;
    std::vector<std::string> street_name;
public:
    City(const char *n) : name(n) {}
    City() {}
}；
```

可以看到这段代码新添加的构造函数什么也没做，但却必须定义。乍看虽然做了一些多此一举的工作，但是毕竟也能让程序重新编

译和运行，问题得到了解决。真的是这样吗？事实上，我们又不知不觉地陷入另一个麻烦中，请看下面的代码：

```cpp
class Trivial   
{ int i;   
public: Trivial(int n) : i(n), j(n) {} Trivial() {} int j;   
};   
int main()   
{ Trivial a(5); Trivial b;  $\mathtt{b} = \mathtt{a}$  std::cout << "std::is_trivial_v<Trivial> : " << std::is_trivial_v<Trivial> << std::endl;
```

上面的代码中有两个动作会将Trivial类的类型从一个平凡类型转变为非平凡类型。第一是定义了一个构造函数Trivial(int n)，它导致编译器抑制添加默认构造函数，于是Trivial类转变为非平凡类型。第二是定义了一个无参数的构造函数，同样可以让Trivial类转变为非平凡类型。

最后一个问题大家肯定也都遇到过，举例来说，有时候我们需要编写一个禁止复制操作的类，但是过去C++标准并没有提供这样的能力。聪明的程序员通过将复制构造函数和复制赋值运算符函数声明为private并且不提供函数实现的方式，间接地达成目的。为了使用方便，boost库也提供了noncopyable类辅助我们完成禁止复制的需求。

不过就如前面的问题一样，虽然能间接地完成禁止复制的需求，但是这样的实现方法并不完美。比如，友元就能够在编译阶段破坏类对复制的禁止。这里可能会有读者反驳，虽然友元能够访问私有的复制构造函数，但是别忘了，我们并没有实现这个函数，也就是说程序最后仍然无法运行。没错，程序最后会在链接阶段报错，原因是找不到复制构造函数的实现。但是这个报错显然来得有些晚，试想一下，如果面临的是一个巨大的项目，有不计其数的源文件需要编译，那么编译过程将非常耗时。如果某个错误需要等到编译结束以后的链接阶段才能确定，那么修改错误的时间代价将会非常高，所以我们还是更希望能在编译阶段就找到错误。

还有一个典型的例子，禁止重载函数的某些版本，考虑下面的例子：

```txt
class Base {
    void foo(long &);
public:
        void foo(int) {}
};
int main()
{
    Base b;
    long l = 5;
    b.foo(8);
    b.foo(1); //编译错误
}
```

由于将成员函数foo(long &)声明为私有访问并且没有提供代码实现，因此在调用b.foo(1)的时候会编译出错。这样看来它跟我们之前讨论的例子没有什么实际区别，再进一步讨论，假设现在我们

需要继承Base类，并且实现子类的foo函数；另外，还想沿用基类Base的foo函数，于是这里使用using说明符将Base的foo成员函数引入子类，代码如下：

```cpp
class Base {
    void foo(long &);
public:
        void foo(int) {}
};
class Derived : public Base {
public:
    using Base::foo;
    void foo(const char *) {}
};
int main()
{
Derived d;
d.foo("hello");
d.foo(5);
}
```

上面这段代码看上去合情合理，而实际上却无法通过编译。因为using说明符无法将基类的私有成员函数引入子类当中，即使这里我们将代码d.foo(5)删除，即不再调用基类的函数，编译器也是不会让这段代码编译成功的。

