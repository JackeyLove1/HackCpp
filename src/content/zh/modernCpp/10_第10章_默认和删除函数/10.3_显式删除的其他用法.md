# 10.3 显式删除的其他用法

显式删除不仅适用于类的成员函数，对于普通函数同样有效。只不过相对于应用于成员函数，应用于普通函数的意义就不大了：

```c
void foo()  $=$  delete;   
static void bar()  $=$  delete;   
int main()
```

```javascript
{ bar(); //编译失败，函数已经被显式删除 foo(); //编译失败，函数已经被显式删除
```

另外，显式删除还可以用于类的new运算符和类析构函数。显式删除特定类的new运算符可以阻止该类在堆上动态创建对象，换句话说它可以限制类的使用者只能通过自动变量、静态变量或者全局变量的方式创建对象，例如：

```cpp
struct type
{
    void * operator new(std::size_t) = delete;
};
type global_var;
int main()
{
    static type static_var;
    type auto_var;
    type *var_ptr = new type; //编译失败，该类的new已被删除
```

显式删除类的析构函数在某种程度上和删除new运算符的目的正好相反，它阻止类通过自动变量、静态变量或者全局变量的方式创建对象，但是却可以通过new运算符创建对象。原因是删除析构函数后，类无法进行析构。所以像自动变量、静态变量或者全局变量这种会隐式调用析构函数的对象就无法创建了，当然了，通过new运算符创建的对象也无法通过delete销毁，例如：

```txt
struct type {
    ~type() = delete;
}；
type global_var; //编译失败，析构函数被删除无法隐式调用
```

```txt
int main()  
{  
    static type static_var; //编译失败，析构函数被删除无法隐式调用  
    type auto_var; //编译失败，析构函数被删除无法隐式调用  
    type *var_ptr = new_type;  
    delete var_ptr; //编译失败，析构函数被删除无法显式调用  
}
```

通过上面的代码可以看出，只有new创建对象会成功，其他创建和销毁操作都会失败，所以这样的用法并不多见，大部分情况可能在单例模式中出现。

