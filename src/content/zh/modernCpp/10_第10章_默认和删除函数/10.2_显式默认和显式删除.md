# 10.2 显式默认和显式删除

为了解决以上种种问题，C++11标准提供了一种方法能够简单有效又精确地控制默认特殊成员函数的添加和删除，我们将这种方法叫作显式默认和显式删除。显式默认和显式删除的语法非常简单，只需

要在声明函数的尾部添加=default和=delete，它们分别指示编译器添加特殊函数的默认版本以及删除指定的函数：

```cpp
struct type
{
    type() = default;
    virtual ~type() = delete;
    type(const type &);
}
type::type(const type &) = default;
```

以上代码显式地添加了默认构造和复制构造函数，同时也删除了析构函数。请注意，=default可以添加到类内部函数声明，也可以添加到类外部。这里默认构造函数的=default就是添加在类内部，而复制构造函数的=default则是添加在类外部。提供这种能力的意义在于，它可以让我们在不修改头文件里函数声明的情况下，改变函数内部的行为，例如：

```cpp
// type.h   
struct type { type(); int x;   
};   
// type1.cpp   
type::type()  $=$  default;   
// type2.cpp   
type::type()  $\{x = 3;\}$
```

=delete与=default不同，它必须添加在类内部的函数声明中，如果将其添加到类外部，那么会引发编译错误。

通过使用  $=$  default，我们可以很容易地解决之前提到的前两个问题，请观察以下代码：

```cpp
class NonTrivial   
{ int i;   
public: NonTrivial(int n) : i(n), j(n) {} NonTrivial() {} int j;   
};   
class Trivial   
{ int i;   
public: Trivial(int n) : i(n), j(n) {} Trivial() = default; int j;   
};   
int main()   
{ Trivial a(5); Trivial b;  $\mathrm{b} = \mathrm{a}$  std::cout << "std::is_trivial_v<Trivial> : " << std::is_trivial_v<Trivial> << std::endl; std::cout << "std::is_trivial_v<NonTrivial> : " << std::is_trivial_v<NonTrivial> << std::endl; }
```

注意，我们只是将构造函数NonTrivial() {} 替换为显式默认构造函数Trivial() = default，类就从非平凡类型恢复到平凡类型了。这样一来，既让编译器为类提供了默认构造函数，又保持了类本身的性质，可以说完美解决了之前的问题。

另外，针对禁止调用某些函数的问题，我们可以使用  $=$  delete来删除特定函数，相对于使用private限制函数访问，使用  $=$

delete更加彻底，它从编译层面上抑制了函数的生成，所以无论调用者是什么身份（包括类的成员函数），都无法调用被删除的函数。进一步来说，由于必须在函数声明中使用= delete来删除函数，因此编译器可以在第一时间发现有代码错误地调用被删除的函数并且显示错误报告，这种快速报告错误的能力也是我们需要的，来看下面的代码：

```txt
class NonCopyable   
{   
public: NonCopyable()  $=$  default; //显式添加默认构造函数 NonCopyable(constNonCopyable&）  $=$  delete; //显式删除复制构造函数 NonCopyable& operator  $\equiv$  (constNonCopyable&）  $=$  delete; //显式删除复制赋值 //运算符函数}；   
int main(){ NonCopyablea，b; a  $=$  b; //编译失败，复制赋值运算符已被删除
```

以上代码删除了类NonCopyable的复制构造函数和复制赋值运算符函数，这样就禁止了该类对象相互之间的复制操作。请注意，由于显式地删除了复制构造函数，导致默认情况下编译器也不再自动添加默认构造函数，因此我们必须显式地让编译器添加默认构造函数，否则会导致编译失败。

最后，让我们用  $=$  delete来解决禁止重载函数的继承问题，这里只需要对基类Base稍作修改即可：

```cpp
class Base { //void foo(long &);   
public: void foo(long &)  $=$  delete; //删除foo(long &)函数 void foo(int）{}   
};   
class Derived : public Base{   
public: using Base::foo; void foo(const char \*) {}   
}；   
int main()   
{ Derived d; d.foo("hello"); d.foo(5);   
}
```

请注意，上面对代码做了两处修改。第一是将foo(long &)函数从private移动到public，第二是显式删除该函数。如果只是显式删除了函数，却没有将函数移动到public，那么编译还是会出错的。

