# 10.4 explicit和=delete

在类的构造函数上同时使用explicit和  $\equiv$  delete是一个不明智的做法，它常常会造成代码行为混乱难以理解，应尽量避免这样做。下面这个例子就是反面教材：

```c
struct type
{
    type(long long) {}
    explicit type(long) = delete;
};
void foo(type) {}
int main()
{
    foo(type(58));
    foo(58);
}
```

读者可以在这里思考一下，上面哪句代码无法通过编译。答案是 foo(type(58))会造成编译失败，原因是type(58)显式调用了构造函数，但是explicit type(long)却被删除了。foo(58)可以

通过编译，因为编译器会选择type(long long)来构造对象。虽然原因解释得很清楚，但是建议还是不要这么使用，因为这样除了让人难以理解外，没有实际作用。

