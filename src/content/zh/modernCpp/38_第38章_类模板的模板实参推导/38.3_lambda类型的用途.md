# 38.3 lambda类型的用途

请读者思考一个问题，要将一个lambda表达式作为数据成员存储在某个对象中，应该如何编写这种类的代码？在C++17以前，大部分人想出的解决方案应该差不多是这样的：

```txt
include<iostream> template<class T> struct LambdaWarp
```

```cpp
{ LambdaWarp(T t) : func(t) {} template<class ...Args> void operator() (Args&& ...arg) { func(std::forward<Args>(arg)...); } T func;   
}; int main() { auto l = [] (int a, int b) { std::cout << a + b << std::endl; }; LambdaWarp<stdioType(l)> x(l); x(11, 7);
```

在这份代码中，最关键的步骤是使用decltype获取lambda表达式1的类型，只有通过这种方法才能准确地实例化类模板。在C++支持了类模板的模板实参推导以后，上面的代码可以进行一些优化：

```cpp
include<iostream>   
template<class T>   
struct LambdaWarp   
{ LambdaWarp(T t) : func(t) {} template<class ...Args> void operator() (Args&& ...arg) { func(std::forward<Args>(arg)...); } T func;   
} ;   
int main() { LambdaWarp x([] (int a, int b) { std::cout << a + b << std::endl; }）; x(11，7);   
}
```

上面的代码不再显式指定lambda表达式类型，而是让编译器通过初始化构造自动推导出lambda表达式类型，简化了代码的同时也更加符合lambda表达式的使用习惯。

