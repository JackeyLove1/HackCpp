# 38.1 通过初始化构造推导类模板的模板实参

在C++17标准之前，实例化类模板必须显式指定模板实参，例如：

```cpp
std::tuple<int, double, const char*> v{5, 11.7, "hello world"};
```

可以看到这种写法十分冗长，幸运的是，由于函数模板可以通过函数的实参列表推导出模板实参，因此出现了std::make_pair和std::make_tuple这类函数，结合auto关键字，上面的代码可以简化为：

```txt
auto v = std::make tuple(5, 11.7, "hello world");
```

虽然这种方法在一定程度上解决了问题，但是很明显在std::tuple的初始化阶段，编译器有条件通过v{5，11.7，"hello world"}初始化列表中的实参推导出std::tuple的模板实参，这样就不必引入函数模板std::make_tuple了。

C++17标准支持了类模板的模板实参推导，上面的代码可以进一步简化为：

```javascript
std::tuple v{5,11.7,"hello world"};
```

实例化类模板也不再需要显式地指定每个模板实参，编译器可以通过对象的初始化构造推导出缺失的模板实参。典型的使用例子还包括：

```cpp
std::_mutex mx;   
std::lock_guard lg{mx};   
std::complex c{3.5};   
std::vector v{5,7,9};   
auto v1 = new std::vector{1,3,5};
```

在上面的代码中， $1g$  的类型被推导为

std::lock_guard<std::_mutex>, c和v的类型分别被推导为std::complex<double>和std::vector<int>。当然了，使用new表达式也能触发类模板的实参推导。除了以类型为模板形参的类模板，实参推导对非类型形参的类模板同样适用，下面的例子就是通过初始化，同时推导出类型模板实参char和非类型模板实参6的：

```cpp
include<iostream>   
template<class T, std::size_t N>   
struct MyCountOf { MyCountOf(T(&)[N]){} std::size_t value  $=$  N;   
}；   
int main() { MyCountOf c("hello"); std::cout<<c.value<<std::endl;   
}
```

对于非类型模板形参为auto占位符的情况也是支持推导的：

```cpp
template<class T, auto N> struct X {
    X(T(&)[N]) {}
};
int main()
{
    X x("hello");
}
```

需要注意的是，不同于函数模板，类模板的模板实参是不允许部分推导的。比如：

```txt
template<class T1, class T2> void foo(T1, T2) {}
int main()
{
    foo<int>(5, 6.8);
}
```

上面这段代码可以编译成功，虽然函数模板实例化的时候只显式指定了一个模板实参T1，但是由于模板实参T2可以通过函数实参列表推导，因此并不会影响编译器的正常工作，最终编译器正确将函数模板实例化为foo<int, double>(int, double)。但是这在类模板上是行不通的：

```cpp
template<class T1, class T2> struct foo
{
    foo(T1, T2) {}
};
int main()
{
    foo v1(5, 6.8);
    foo<> v2(5, 6.8);
    foo<int> v3(5, 6.8);
}
```

```txt
foo<int, double> v4(5, 6.8); // 编译成功
```

在上面的代码中，v1和v4可以顺利通过编译，其中v1符合类模板实参的推导要求，而v4则显式指定了模板实参。v2和v3就没那么幸运了，它们都没有完整地指定模板实参，这是编译器不能接受的。

