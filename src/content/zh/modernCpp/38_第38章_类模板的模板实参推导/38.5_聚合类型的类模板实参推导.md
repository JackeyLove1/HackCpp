# 38.5 聚合类型的类模板实参推导

除了上一节提到的别名模板，C++20标准还规定聚合类型也可以进行类模板的实参推导。例如：

```txt
template<class T> struct S {
    T x;
    T y;
};
```

编译器会根据初始化列表推导出模板实参，在上面的代码中，s1{1，2}；推导出的模板实参均为int类型，符合单一模板参数T，所以可以顺利编译。相反，s2{1，2u}；由于初始化列表的两个元素推导出了不同的类型int和unsigned int，无法满足确定的模板参数T，因此编译失败。

除了以上简单的聚合类型，嵌套聚合类型也可以进行类模板实参推导，例如：

```cpp
template<class T, class U> struct X {
    S<T> s;
    U u;
    T t;
};
```

```txt
Xx{1，2}，3u，4}；
```

请注意，在上面的代码中模板形参T并不是被{1，2}推导出来的，而是被初始化列表中最后一个元素4推导而来，S<T> s;不参与到模板实参的推导中。另外，如果显示指定S<T>的模板实参，则初始化列表的子括号可以忽略，例如：

```txt
template<class T, class U> struct X {
    S<int> s;
    U u;
    T t;
};
```

以上这部分特性到目前为止只在GCC中实现。

C++20标准还规定聚合类型中的数组也可以是推导对象，不过这部分特性至今还没有编译器实现，这里我们看一下提案文档的例子即可：

```cpp
template<class T, std::size_t N> struct A {
    T array[N];
};
A a{ {1, 2, 3} };
template<typename T> struct B {
    T array[2];
};
B b = {0, 1};
```

在上面的代码中，类模板A需要推导数组类型和数组大小，根据初始化列表array被推导为int array[3]，注意，这里初始化列表中的子括号是必须存在的。而对于类模板B而言，数组大小是确定的，编译器只需要推导数组类型，这时候可以省略初始化列表中的子括号。

