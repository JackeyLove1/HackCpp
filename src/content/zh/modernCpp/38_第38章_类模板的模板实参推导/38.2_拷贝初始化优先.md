# 38.2 拷贝初始化优先

在类模板的模板实参推导过程中往往会出现这样两难的场景：

```txt
std::vector v1{ 1,3,5 };   
std::vector v2{ v1 };   
std::tuple t1{ 5,6.8,"hello" };   
std::tuple t2{ t1 };
```

```cpp
这里读者不妨猜测一下v2和t2的类型。v2是std::vector<int>类型还是std::vector<std::vector<int>>类型，t2是std::tuple<int，double，const char  $\ast >$  类型还是std::tuple<std::tuple<int，double，const char  $\ast >$  类型？实际上，正如本节的标题所言，这里会优先解释为拷贝初始化。更明确地说，v2的类型为std::vector<int>，t2的类型为std::tuple<int，double，const char  $\ast >$  。
```

同理，下面的类模板也都会被实例化为std::vector<int>类型：

```txt
std::vector v3(v1); std::vector v4 = {v1}; auto v5 = std::vector{v1};
```

请读者注意，使用列表初始化的时候，当且仅当初始化列表中只有一个与目标类模板相同的元素才会触发拷贝初始化，在其他情况下都会创建一个新的类型，比如：

```cpp
std::vector v1{ 1,3,5};   
std::vector v3{v1,v1};   
std::tuple t1{5,6.8,"hello"};   
std::tuple t3{t1,t1};
```

其中v3的类型为std::vector<std::vector<int>>，t3的类型为std::tuple<std::tuple<int，double，const char\*>，std::tuple<int，double，const char\*\*>>。最后值得一提的是，虽然C++17标准的编译器现在一致表现为优先拷贝初始化，但是真正在标准中明确的是C++20。该语法补充是在2017年7月提出的，可惜那时候C++17标准已经发布了。

