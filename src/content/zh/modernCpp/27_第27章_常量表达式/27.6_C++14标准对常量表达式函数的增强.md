# 27.6 C++14标准对常量表达式函数的增强

$\mathrm{C} + + 11$  标准对常量表达式函数的要求可以说是非常的严格，这一点影响该特性的实用性。幸好这个问题在  $\mathrm{C} + + 14$  中得到了非常巨大的改善，  $\mathrm{C} + + 14$  标准对常量表达式函数的改进如下。

1. 函数体允许声明变量，除了没有初始化、static和 thread_local变量。

2. 函数允许出现if和switch语句，不能使用go语句。  
3. 函数允许所有的循环语句，包括for、while、do-while。  
4. 函数可以修改生命周期和常量表达式相同的对象。  
5. 函数的返回值可以声明为void。  
6. constexpr声明的成员函数不再具有const属性。

因为这些改进的发布，在C++11中无法成功编译的常量表达式函数，在C++14中可以编译成功了：

```txt
constexpr int abs(int x)   
{ if  $(\mathbf{x} > 0)$  { return x; } else { return -x; }   
}   
constexpr int sum(int x)   
{ int result  $= 0$  while  $(\mathrm{x} > 0)$  { result  $+ = \mathrm{x - - }$  1 return result;   
}   
char buffer1[sum(5)]  $= \{0\}$  char buffer2[abs(-5)]  $= \{0\}$
```

以上代码中的abs和sum函数相比于前面使用条件表达式和递归方法实现的函数更加容易阅读和理解了。看到这里读者是否会有一些

兴奋，但是别急，后面还有好戏：

```txt
constexpr int next(int x) { return ++x; char buffer next(5) = {0};
```

这里我们惊喜地发现，原来由于  $++\mathrm{x}$  不是常量表达式，因此无法编译通过的问题也消失了，这就是基于第4点规则。需要强调的是，对于常量表达式函数的增强同样也会影响常量表达式构造函数：

```cpp
include<iostream>   
class X{   
public: constexpr X(）：x1(5）{} constexpr X(int i)：x1(0) { if  $(\mathrm{i} > 0)$  { x1  $= 5$  1 } else{ x1  $= 8$  1 } } constexprvoid set(inti) { x1  $=$  i; } constexprint get()const { return x1;   
} private: int x1;   
};   
constexprXmake_x()   
{ Xx; x.set(42); return x;
```

```cpp
}   
int main()   
{ constexpr X x1(-1); constexpr X x2  $=$  make_x(); constexpr int a1  $=$  x1.get(); constexpr int a2  $=$  x2.get(); std::cout<<a1<<std::endl; std::cout<<a2<<std::endl;
```

请注意，main函数里的4个变量x1、x2、a1和a2都有constexpr声明，也就是说它们都是编译期必须确定的值。有了这个前提条件，我们再来分析这段代码的神奇之处。首先对于常量表达式构造函数，我们发现可以在其函数体内使用if语句并且对x1进行赋值操作了。可以看到返回类型为void的set函数也被声明为constexpr了，这也意味着该函数能够运用在constexpr声明的函数体内，make_x函数就是利用了这个特性。根据规则4和规则6，set函数也能成功地修改x1的值了。让我们来看一看GCC生成的中间代码：

```txt
main ()   
{ int D.39319; const struct X x1; const struct X x2; const int a1; const int a2; try {  $\mathrm{x1.x1} = 8;$ $\mathrm{x2.x1} = 42;$  a1  $= 8$  . a2  $= 42$
```

```cpp
1=std::basic_ostream<char>::operator<< (&cout,8); std::basic_ostream<char>::operator<< (_1,endl); 2=std::basic_ostream<char>::operator<< (&cout,42); std::basic_ostream<char>::operator<< (_2,endl);   
} finally { x1  $=$  {CLOBBER}; x2  $=$  {CLOBBER}; }   
} D.39319  $= 0$  return D.39319;
```

从上面的中间代码可以清楚地看到，编译器直接给x1.x1、x2.x1、a1、a2进行了赋值，并没有运行时的计算操作。

最后需要指出的是，C++14标准除了在常量表达式函数特性方面做了增强，也在标准库方面做了增强，包括<complex>、<chrono>、<array>、<initializer_list>、<utility>和<Tuple>。对于标准库的增强细节这里就不做介绍了，大家可以直接参阅STL源代码。

