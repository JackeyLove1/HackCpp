# 27.7 constexpr lambdas表达式

从C++17开始，lambda表达式在条件允许的情况下都会隐式声明为constexpr。这里所说的条件，即是上一节中提到的常量表达式函数的规则，本节里就不再重复论述。结合lambda的这个新特性，先看一个简单的例子：

```typescript
constexpr int foo() {
```

```c
return [](){ return 58;}();   
}   
auto get_size  $=$  [] (int i){ return i \*2;}; char buffer1[foo()]  $=$  {0}; char buffer2[get_size(5)]  $=$  {0};
```

可以看到，以上代码定义的是一个“普通”的lambda表达式，但是在C++17标准中，这些“普通”的lambda表达式却可以用在常量表达式函数和数组长度中，可见该lambda表达式的结果在编译阶段已经计算出来了。实际上这里的[] (int i) { return i * 2; }相当于：

```txt
class GetSize {   
public: constexpr int operator() (int i) const { return i \* 2; }   
}；
```

当lambda表达式不满足constexpr的条件时，lambda表达式也不会出现编译错误，它会作为运行时lambda表达式存在：

```c
// 情况1  
int i = 5;  
auto get_size =[](int i) { return i * 2; };  
char buffer1[get_size(i)] = {0}; //编译失败，get_size需要运行时调用  
int a1 = get_size(i);  
//情况2  
auto get_count = []; {static int x = 5; return x;}  
};  
int a2 = get_count();
```

以上代码中情况1和常量表达式函数相同，get_size可能会退化为运行时lambda表达式对象。当这种情况发生的时候，get_size的

返回值不再具有作为数组长度的能力，但是运行时调用get_size对象还是没有问题的。GCC在这种情况下依然能够在编译阶段求出get_size的值，MSVC和CLang则不行。对于情况2，由于static变量的存在，lambda表达式对象get_count不可能在编译期运算，因此它最终会在运行时计算。

值得注意的是，我们也可以强制要求lambda表达式是一个常量表达式，用constexpr去声明它即可。这样做的好处是可以检查lambda表达式是否有可能是一个常量表达式，如果不能则会编译报错，例如：

```c
auto get_size = [] (int i) constexpr -> int { return i * 2; };  
char buffer2[get_size(5)] = { 0 };  
auto get_count = []; constexpr -> int {  
    static int x = 5; // 编译失败，x是一个static变量  
    return x;  
};  
int a2 = get_count();
```

