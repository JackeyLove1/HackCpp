# 27.8 constexpr的内联属性

在C++17标准中，constexpr声明静态成员变量时，也被赋予了该变量的内联属性，例如：

```cpp
class X {
public:
    static constexpr int num{5};
};
```

以上代码在C++17中等同于:

```javascript
class X { public: inline static constexpr int num{5}; };
```

那么问题来了，自C++11标准推行以来static constexpr int num{5}这种用法就一直存在了，那么同样的代码在C++11和C++17中究竟又有什么区别呢？

```cpp
class X {
public:
    static constexpr int num{5};
};
```

代码中，num是只有声明没有定义的，虽然我们可以通过std::cout << X::num << std::endl输出其结果，但这实际上是编译器的一个小把戏，它将x::num直接替换为了5。如果将输出语句修改为std::cout << &X::num << std::endl，那么链接器会明确报告x::num缺少定义。但是从C++17开始情况发生了变化，static constexpr int num{5}既是声明也是定义，所以在C++17标准中std::cout << &X::num << std::endl可以顺利编译链接，并且输出正确的结果。值得注意的是，对于编译器而言为X::num产生定义并不是必需的，如果代码只是引用了x::num的值，那么编译器完全可以使用直接替换为值的技巧。只有当代码中引用到变量指针的时候，编译器才会为其生成定义。

