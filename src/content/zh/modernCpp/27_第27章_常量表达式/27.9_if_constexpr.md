# 27.9 if constexpr

if constexpr是C++17标准提出的一个非常有用的特性，可以用于编写紧凑的模板代码，让代码能够根据编译时的条件进行实例化。这里有两点需要特别注意。

1. if constexpr的条件必须是编译期能确定结果的常量表达式。  
2. 条件结果一旦确定，编译器将只编译符合条件的代码块。

由此可见，该特性只有在使用模板的时候才具有实际意义，若是用在普通函数上，效果会非常尴尬，比如：

```cpp
void check1(int i)  
{  
    if constexpr (i > 0) { // 编译失败，不是常量表达式  
        std::cout << "i > 0" << std::endl;  
    }  
    else {  
        std::cout << "i <= 0" << std::endl;  
    }  
}  
void check2()  
{  
    if constexpr (sizeof(int) > sizeof(char)) {  
        std::cout << "sizeof(int) > sizeof(char)" << std::endl;  
    }  
    else {  
        std::cout << "sizeof(int) <= sizeof(char)" << std::endl;  
    }  
}
```

对于函数check1，由于if constexpr的条件不是一个常量表达式，因此无法编译通过。而对于函数check2，这里的代码最后会被编译器省略为：

```cpp
void check2()
{
    std::cout << "sizeof(int) > sizeof(char)" << std::endl;
}
```

但是当if constexpr运用于模板时，情况将非常不同。来看下面的例子：

```cpp
include<iostream>   
template<class  $\mathbf{T}>$  bool is_same_value(T a,T b) { return a  $= =$  b;   
}   
template<> bool is_same_value<double>(double a,double b) { if (std::abs(a-b)<0.0001){ return true; } else{ return false; }   
}   
int main() { double  $\mathrm{x} = 0.1 + 0.1 + 0.1 - 0.3$  std::cout<<std::boolalpha; std::cout<<"is_same_value(5,5）:"<<is_same_value(5,5）<< std::endl; std::cout<<"x  $= = 0.0$  ：""<<  $(\mathrm{x} = = 0.)$  <std::endl; std::cout<<"is_same_value(x,0.):""<<is_same_value(x,0.) << std::endl;   
}
```

计算结果如下:

```txt
is_same_value(5, 5) : true  
x == 0.0 : false  
is_same_value(x, 0.) : true
```

我们知道浮点数的比较和整数是不同的，通常情况下它们的差小于某个阈值就认为两个浮点数相等。我们把is_same_value写成函数模板，并且对double类型进行特化。这里如果使用if constexpr表达式，代码会简化很多而且更加容易理解，让我们看一看看简化后的代码：

```cpp
include <typetraits> template<class T> bool is_same_value(T a, T b) { if constexpr (std::is_same<T, double>::value) { if (std::abs(a - b) < 0.0001) { return true; } else { return false; } } else { return a == b; } }
```

在上面这段代码中，直接使用if constexpr判断模板参数是否为double，如果条件成立，则使用double的比较方式；否则使用普通的比较方式，代码变得简单明了。再次强调，这里的选择是编译期做出的，一旦确定了条件，那么就只有被选择的代码块才会被编译；另外的代码块则会被忽略。说到这里，需要提醒读者注意这样一种陷阱：

```cpp
include<iostream>   
#include <typetraits>   
template<class T> auto minus(T a, T b)   
{ if constexpr (std::is_same<T, double> ::value) { if (std::abs(a - b) < 0.0001) { return 0.;
```

```cpp
} else{ return a-b; } 1 else{ return static cast<int>(a-b);   
}   
int main()   
{ std::cout<<minus(5.6，5.11）<<std::endl; std::cout<<minus(5.60002，5.600011）<<std::endl; std::cout<<minus(6，5）<<std::endl;
```

以上是一个带精度限制的减法函数，当参数类型为double且计算结果小于0.0001的时候，我们就可以认为计算结果为0。当参数类型为整型时，则不用对精度做任何限制。上面的代码编译运行没有任何问题，因为编译器根据不同的类型选择不同的分支进行编译。但是如果修改一下上面的代码，结果可能就很难预料了：

```cpp
template<class T> auto minus(T a, T b) {
    if constexpr(std::is_same<T, double>::value) {
        if (std::abs(a - b) < 0.0001) {
            return 0.;
        }
    else {
        return a - b;
    }
}
```

上面的代码删除了else关键词而直接将else代码块提取出来，不过根据以往运行时if的经验，它并不会影响代码运行的逻辑。遗憾的是，这种写法有可能导致编译失败，因为它可能会导致函数有多个不

同的返回类型。当实参为整型时一切正常，编译器会忽略if的代码块，直接编译return static cast<int>(a - b)，这样返回类型只有int一种。但是当实参类型为double的时候，情况发生了变化。if的代码块会被正常地编译，代码块内部的返回结果类型为double，而代码块外部的return static cast<int>(a - b)同样会照常编译，这次的返回类型为int。编译器遇到了两个不同的返回类型，只能报错。

和运行时if的另一个不同点：if constexpr不支持短路规则。这在程序编写时往往也能成为一个陷阱：

```cpp
include<iostream>   
#include <string>   
#include <type_traits>   
template<class T> auto any2i(T t)   
{ if constexpr (std::is_same<T, std::string>::value && T::npos == -1) { return atoi(t.c_str()); } else { return t; }   
}   
int main()   
{ std::cout << any2i(std::string("6")) << std::endl; std::cout << any2i(6) << std::endl; }
```

上面的代码很好理解，函数模板any2i的实参如果是一个std::string，那么它肯定满足std::is_same<T, std::string>::value && T::npos == -1的条件，所以编译

器会编译if分支的代码。如果实参类型是一个int，那么

std::is_same<T, std::string>::value会返回false，根据短路规则，if代码块不会被编译，而是编译else代码块的内容。一切看起来是那么简单直接，但是编译过后会发现，代码std::cout<< any2i(std::string("6")) << std::endl顺利地编译成功，std::cout<< any2i(6) << std::endl则会编译失败，因为if constexpr不支持短路规则。当函数实参为int时，

```txt
std::is_same<T, std::string>::value和T::npos == -1
```

都会被编译，由于int::npos显然是一个非法的表达式，因此会造成编译失败。这里正确的写法是通过嵌套if constexpr来替换上面的操作：

```cpp
template<class T> auto any2i(T t) {
    if constexpr(std::is_like<T, std::string>::value) {
        if constexpr(T::npos == -1) {
            return atoi(t.c_str());
        }
    }
    else {
        return t;
    }
}
```

