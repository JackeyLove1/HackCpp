# 27.15 使用constinit检查常量初始化

在C++中有一种典型的错误叫作“Static Initialization Order Fiasco”，指的是因为静态初始化顺序错误导致的问题。因为这种错误往往发生在main函数之前，所以比较难以排查。举一个典型的例子，假设有两个静态对象x和y分别存在于两个不同的源文件中。其中一个对象x的构造函数依赖于对象y。没错，就是这样，现在我们有50%的可能性会出错，因为我们没有办法控制哪个对象先构造。如果对象x在y之前构造，那么就会引发一个未定义的结果。为了避免这种问题

的发生，我们通常希望使用常量初始化程序去初始化静态变量。不幸的是，常量初始化的规则很复杂，需要一种方法帮助我们完成检查工作，当不符合常量初始化程序的时候可以在编译阶段报错。于是在C++20标准中引入了新的constinit说明符。

正如上文所描述的constinit说明符主要用于具有静态存储持续时间的变量声明上，它要求变量具有常量初始化程序。首先，constinit说明符作用的对象是必须具有静态存储持续时间的，比如：

```txt
constinit int x = 11; //编译成功，全局变量具有静态存储持续  
int main() {  
    constinit static int y = 42; //编译成功，静态变量具有静态存储持续  
    constinit int z = 7; //编译失败，局部变量是动态分配的  
}
```

其次，constinit要求变量具有常量初始化程序：

```txt
const char* f() { return "hello"; }  
const expr const char* g() { return "cpp"; }  
constinit const char* str1 = f(); // 编译错误，f()不是一个常量初始化程序  
constinit const char* str2 = g(); // 编译成功
```

constinit还能用于非初始化声明，以告知编译器 thread_local变量已被初始化：

```txt
extern thread_local constinit int x;  
int f() { return x; }
```

最后值得一提的是，虽然constinit说明符一直在强调常量初始化，但是初始化的对象并不要求具有常量属性。

