# 27.16 判断常量求值环境

std::is_constant評估的是C++20新加入标准库的函数，它用于检查当前表达式是否是一个常量求值环境，如果在一个明显常量求值的表达式中，则返回true；否则返回false。该函数包含在<typetraits>头文件中，虽然看上去像是一个标准库实现的函数，但实际上调用的是编译器内置函数：

```javascript
constexpr inline bool is_constant評uated() noexcept{ return __builtin_is_constant評uated(); }
```

该函数通常会用于代码优化中，比如在确定为常量求值的环境时，使用constexpr能够接受的算法，让数值在编译阶段就得出结果。而对于其他环境则采用运行时计算结果的方法。提案文档中提供了一个很好的例子：

```cpp
include <math>   
#include <type_traits>   
constexpr double power(double b, int x) { if (std::is_constant評uated() && x >= 0) { double r = 1.0, p = b; unsigned u = (unsigned)x; while  $(\mathrm{u}! = 0)$  { if(u&1)r  $\star =$  p; u  $= 2$  . p  $\star =$  p; } return r;
```

```cpp
} else { return std::pow(b, (double)x); }   
}   
int main()   
{ constexpr double kilo  $=$  power(10.0, 3); //常量求值 int n = 3; double mucho  $=$  power(10.0, n); //非常量求值 return 0;   
}
```

在上面的代码中，power函数根据

std::is_constant評估ated()和x >= 0的结果选择不同的实现方式。其中，kilo = power(10.0, 3); 是一个常量求值，所以 std::is_constant評估ated() && x >= 0返回true，编译器在编译阶段求出结果。反之，much = power(10.0, n)则需要调用std::pow在运行时求值。让我们通过中间代码看一看编译器具体做了什么：

```javascript
main()   
{ int D.25691; { const double kilo; int n; double mucho; kilo  $= 1$  .0e+3; //直接赋值 n  $= 3$  ; mucho  $=$  power (1.0e+1，n）；//运行时计算 D.25691  $= 0$  return D.25691; } D.25691  $= 0$  return D.25691;
```

```lisp
power (double b, int x)   
{ bool retval.0; bool iftmp.1; double D.25706; { 1  $=$  std::is_constant評uated(); if  $(1! = 0)$  goto  $<  <   D.25697>$  else goto  $<  <   D.25695>$  .  $<  <   D.25697>$  if  $\mathrm{(x > = 0)}$  goto  $<  <   D.25698>$  ; else goto  $<  <   D.25695>$  ..  $<  <   D.25698>$  : iftmp.1  $= 1$  . goto  $<  <   D.25696>$  .  $<  <   D.25695>$  : iftmp.1  $= 0$  ..  $<  <   D.25696>$  : retval.0  $=$  iftmp.1; if (retval.0 != 0) goto  $<  <   D.25699>$  ; else goto  $<  <   D.25700>$  ..  $<  <   D.25699>$  .. { // ... 这里省略power函数的相关算法，虽然算法生成代码了，但是并没有调用到 return D.25706; } <D.25700>: _3 = (double) x; D.25706 = pow (b,_3); return D.25706; }   
}   
std::is_constant評uated ()   
{ bool D.25708; try { D.25708  $= 0$  . return D.25708; } catch { <<eh.must_notthrow (terminate)>>> }
```

观察上面的中间代码，首先让我们注意到的就是main函数中kilo和mucho赋值形式的不同。正如我们刚才讨论的那样，对于kilo的结果编译器在编译期已经计算完成，所以这里是直接为 $1.0e + 3$  ，而对于mucho则需要调用std::power函数。接着，我们可以观察std::is_constant評uated()这个函数的实现，很明显编译器让它直接返回0（也就是false），在代码中实现的power函数虽然有std::is_constant評uated()结果为true时的算法实现，但是却永远不会被调用。因为当std::is_constant評uated()为true时，编译器计算了函数结果；反之函数会交给std::power计算结果。

在了解了std::is_constant評估ated()的用途之后，我们还需要弄清楚何为明显常量求值。只有弄清楚这个概念，才可能合理运用std::is_constant評估ated()函数。明显常量求值在标准文档中列举了下面几个类别。

1. 常量表达式，这个类别包括很多种情况，比如数组长度、case表达式、非类型模板实参等。  
2. if constexpr语句中的条件。  
3. constexpr变量的初始化程序。  
4. 立即函数调用。

5. 约束概念表达式。  
6. 可在常量表达式中使用或具有常量初始化的变量初始化程序。

下面我们通过几个标准文档中的例子来体会以上规则：

```cpp
template bool> struct X {};
X<std::is_constant評估ated() > x; // 非类型模板实参，函数返回true，最终类型为
// X<true>
int y;
const expr int f() {
    const int n = std::is_constant評估ated() ? 13 : 17; // n是13
    int m = std::is_constant評估ated() ? 13 : 17; // m可能是13或者17，取决
        // 于函数环境
char arr[n] = {}; // char[13]
    return m + sizeof(arr);
}
int p = f(); // m是13；p结果如下26
int q = p + f(); // m是17；q结果如下56
```

上面的代码中需要解释的是int p = f();和int q = p + f();的区别，对于前者，std::is_constant評uated() == true时p一定是一个恒定值，它是明显常量求值，所以p的结果是26。相反，std::is_constant評uated() == true时，q的结果会依赖p，所以明显常量求值的结论显然不成立，需要采用std::is_constant評uated() == false的方案，于是f()函数中的m为17，最终q的求值结果是56。另外，如果这里的p初始化改变为const int p = f();，那么f()函数中的m为13，q的求值结果也会改变为52。

最后需要注意的是，如果当判断是否为明显常量求值时存在多个条件，那么编译器会试探std::is_constant評估ated()两种情况求值，比如：

```cpp
int y;  
const int a = std::is_constant評估() ? y : 1; // 函数返回 false, a运行时 // 初始化为1  
const int b = std::is_constant評估() ? 2 : y; // 函数返回 true, b编译时 // 初始化为2
```

当对a求值时，编译器试探std::is_constant評uated() == true的情况，发现y会改变a的值，所以最后选择std::is_constant評uated() == false；当对b求值时，编译器同样试探std::is_constant評uated() == true的情况，发现b的结果恒定为2，于是直接在编译时完成初始化。

