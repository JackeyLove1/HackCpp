# 27.2 constexpr值

constexpr值即常量表达式值，是一个用constexpr说明符声明的变量或者数据成员，它要求该值必须在编译期计算。另外，常量表达式值必须被常量表达式初始化。定义常量表达式值的方法非常简单，例如：

```txt
constexpr int x = 42;  
char buffer[x] = {0};
```

以上代码定义了一个常量表达式值x，并将其初始化为42，然后用x作为数组长度定义了数组buffer。从这段代码来看，constexpr和const是没有区别的，我们将关键字替换为const同样能达到目的：

```txt
const int x = 42;  
char buffer[x] = {0};
```

从结果来看确实如此，在使用常量表达式初始化的情况下constexpr和const拥有相同的作用。但是const并没有确保编译期常量的特性，所以在下面的代码中，它们会有不同的表现：

```javascript
int x1 = 42;  
const int x2 = x1; //定义和初始化成功  
char buffer[x2] = {0}; //编译失败，x2无法作为数组长度
```

在上面这段代码中，虽然x2初始化编译成功，但是编译器并不一定把它作为一个编译期需要确定的值，所以在声明buffer的时候会编译错误。注意，这里我说的是不一定，因为并没有人规定编译期应该怎么处理这种情况。比如在GCC中，这段代码可以编译成功，但是

MSVC和CLang则会编译失败。如果把const替换为constexpr，会有不同的情况发生：

```javascript
int x1 = 42;  
constexpr int x2 = x1; //编译失败，x2无法用x1初始化  
char buffer[x2] = {0};
```

修改后，编译器编译第二句代码的时候就会报错，因为常量表达式值必须由常量表达式初始化，而x1并不是常量，明确地违反了constexpr的规则，编译器自然就会报错。可以看出，constexpr是一个加强版的const，它不仅要求常量表达式是常量，并且要求是一个编译阶段就能够确定其值的常量。

