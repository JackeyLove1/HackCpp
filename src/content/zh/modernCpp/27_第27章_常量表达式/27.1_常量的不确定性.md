# 27.1 常量的不确定性

在C++11标准以前，我们没有一种方法能够有效地要求一个变量或者函数在编译阶段就计算出结果。由于无法确保在编译阶段得出结果，导致很多看起来合理的代码却引来编译错误。这些场景主要集中在需要编译阶段就确定的值语法中，比如case语句、数组长度、枚举成员的值以及非类型的模板参数。让我们先看一看这些场景的代码：

```cpp
const int index0 = 0;  
#define index1 1  
// case语句  
switch (args)  
{  
    case index0: std::cout << "index0" << std::endl; break;  
    case index1: std::cout << "index1" << std::endl; break;  
    default: std::cout << "none" << std::endl;  
}  
const int x_size = 5 + 8;  
#define y_size 6 + 7  
// 数组长度  
char buffer[x_size][y_size] = {0};  
// 枚举成员  
enum {  
    enum_index0 = index0, 
    enum_index1 = index1,
```

```cpp
};   
std::tuple<int, char> tp = std::make_tuple(4, '3'); //非类型的模板参数 int x1 = std::get(index0>(tp); char x2 = std::get(index1>(tp);
```

在上面的代码中，const定义的常量和宏都能在要求编译阶段确定值的语句中使用。其中宏在编译之前的预处理阶段就被替换为定义的文字。而对于const定义的常量，上面这种情况下编译器能在编译阶段确定它们的值，并在case语句以及数组长度等语句中使用。让人遗憾的是上面这些方法并不可靠。首先，C++程序员应该尽量少使用宏，因为预处理器对于宏只是简单的字符替换，完全没有类型检查，而且宏使用不当出现的错误难以排查。其次，对const定义的常量可能是一个运行时常量，这种情况下是无法在case语句以及数组长度等语句中使用的。让我们稍微修改一下上面的代码：

```c
int get_index0()
{
    return 0;
}
int get_index1()
{
    return 1;
}
int get_x_size()
{
    return 5 + 8;
}
int get_y_size()
{
    return 6 + 7;
}
const int index0 = get_index0();
#define index1 get_index1()
```

```cpp
switch (args)   
{   
case index0: std::cout << "index0" << std::endl; break;   
case index1: std::cout << "index1" << std::endl; break;   
default: std::cout << "none" << std::endl;   
}   
const int x_size = get_x_size();   
#define y_size get_y_size() char buffer[x_size][y_size] = { 0 };   
enum { enum_index0 = index0, enum_index1 = index1, };   
std::tuple<int, char> tp = std::make_tuple(4, '3'); int x1 = std::get(index0>(tp); char x2 = std::get(index1>(tp);
```

我们这里做的修改仅仅是将宏定义为一个函数调用以及用一个函数将const变量进行初始化，但是编译这段代码时会发现已经无法通过编译了。因为，无论是宏定义的函数调用，还是通过函数返回值初始化const变量都是在运行时确定的。

像上面这种尴尬的情况不仅可能出现在我们的代码中，实际上标准库中也有这样的情况，其中<limits>就是一个典型的例子。在C语言中存在头文件<limits.h>，在这个头文件中用宏定义了各种整型类型的最大值和最小值，比如：

```txt
define UCHAR_MAX 0xff // unsigned char类型的最大值
```

我们可以用这些宏代替数字，让代码有更好的可读性。这其中就包括要求编译阶段必须确定值的语句，例如定义一个数组：

```txt
char buffer[UCHAR_MAX] = {0};
```

代码编译起来没有任何障碍。但是正如上文中提到的，C++程序员应该尽量避开宏。标准库为我们提供了一个<limits>，使用它同样能获得unsigned char类型的最大值：

```autohotkey
std::numeric限度<unsigned char>::max()
```

但是，如果想用它来声明数组的大小是无法编译成功的：

```cpp
char buffer[std::numeric限度<unsigned char>::max()] = {0};
```

原因和之前讨论过的一样，

std::numeric限度<unsigned char>::max()函数的返回值必须在运行时计算。

为了解决以上常量无法确定的问题，C++标准委员会决定在 C++11标准中定义一个新的关键字constexpr，它能够有效地定义常量表达式，并且达到类型安全、可移植、方便库和嵌入式系统开发的目的。

