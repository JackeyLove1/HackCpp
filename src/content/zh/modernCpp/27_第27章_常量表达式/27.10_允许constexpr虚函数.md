# 27.10 允许constexpr虚函数

在C++20标准之前，虚函数是不允许声明为constexpr的。看似有道理的规则其实并不合理，因为虚函数很多时候可能是无状态的，

这种情况下它是有条件作为常量表达式被优化的，比如下面这个函数：

```txt
struct X {
    virtual int f() const { return 1; }
};  
int main() {
    X x;
    int i = x.f();
}
```

上面的代码会先执行x::f函数，然后将结果赋值给i，它的GIMPLE中间的代码如下：

```cpp
main()   
{ int D.2137; { struct X x; int i; try { 1  $=$  &ZTV1X  $+16$  . x._vptr.X  $= \underline{1}$  . i  $=$  X::f (&x); //注意此处赋值 } finally { x  $=$  {CLOBBER}； } } D.2137  $= 0$  return D.2137;   
}   
X::f(const struct X \* const this) { int D.2139; D.2139  $= 1$
```

```txt
return D.2139;
```

观察上面的两份代码，虽然x::f是一个虚函数，但是它非常适合作为常量表达式进行优化。这样一来，int i = x.f();可以被优化为int i = 1;，减少一次函数的调用过程。可惜在C++17标准中不允许我们这么做，直到C++20标准明确允许在常量表达式中使用虚函数，所以上面的代码可以修改为：

```txt
struct X {
    constexpr virtual int f() const{ return 1; }
};  
int main() {
    constexpr X x;
    int i = x.f();
}
```

它的中间代码也会优化为:

```txt
main()   
{ int D.2138; { const struct X x; int i; try {  $\begin{array}{rl} & 1 = \& \mathrm{ZTV1X} + 16;\\ & \mathrm{x\_vptr.X} = \mathrm{\_1};\\ & \mathrm{i} = 1;\quad / / \end{array}$  注意此处赋值 } finally {  $\mathbf{x} = \{\mathrm{CLOBBER}\} ;$  1   
D.2138  $= 0$
```

```txt
return D.2138;
```

从中间代码中可以看到，i被直接赋值为1，在此之前并没有调用X::f函数。另外值得一提的是，constexpr的虚函数在继承重写上并没有其他特殊的要求，constexpr的虚函数可以覆盖重写普通虚函数，普通虚函数也可以覆盖重写constexpr的虚函数，例如：

```c
struct X1 {
    virtual int f() const = 0;
}
struct X2: public X1 {
    constexpr virtual int f() const { return 2; }
}
struct X3: public X2 {
    virtual int f() const { return 3; }
}
struct X4: public X3 {
    constexpr virtual int f() const { return 4; }
}
constexpr int (X1:*pf()) const = &X1::f;
constexpr X2 x2;
static_assert(x2.f() == 2);
static_assert((x2.*pf()) == 2);
constexpr X1 const& r2 = x2;
static_assert(r2.f() == 2);
static_assert((r2.*pf()) == 2);
constexpr X1 const* p2 = &x2;
static_assert(p2->f() == 2);
static_assert((p2->*pf()) == 2);
constexpr X4 x4;
static_assert(x4.f() == 4);
```

```c
static_assert( (x4.*pf)() == 4 ); constexpr X1 const& r4 = x4; static_assert( r4.f() == 4 ); static_assert( (r4.*pf)() == 4 ); constexpr X1 const* p4 = &x4; static_assert(p4->f() == 4); static_assert((p4->*pf)(= 4);
```

最后要说明的是，我在验证这条规则时，GCC无论在C++17还是C++20标准中都可以顺利编译通过，而CLang在C++17中会给出constexpr无法用于虚函数的错误提示。

