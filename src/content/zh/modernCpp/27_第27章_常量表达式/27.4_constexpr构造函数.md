# 27.4 constexpr构造函数

constexpr可以声明基础类型从而获得常量表达式值，除此之外constexpr还能够声明用户自定义类型，例如：

```javascript
struct X {
    int x1;
};  
const expr X x = { 1 };
char buffer[x.x1] = { 0 };
```

以上代码自定义了一个结构体x，并且使用constexpr声明和初始化了变量x。到目前为止一切顺利，不过有时候我们并不希望成员变量被暴露出来，于是修改了x的结构：

```javascript
class X {
public:
    X() : x1(5) {}
    int get() const {
        return x1;
    }
private:
    int x1;
};  
constexpr X x; //编译失败，x不是字面类型
char buffer[x.get()] = {0}; //编译失败，x.get()无法在编译阶段计算
```

经过修改的代码不能通过编译了，因为constexpr说明符不能用来声明这样的自定义类型。解决上述问题的方法很简单，只需要用constexpr声明x类的构造函数，也就是声明一个常量表达式构造函数，当然这个构造函数也有一些规则需要遵循。

1. 构造函数必须用constexpr声明。  
2. 构造函数初始化列表中必须是常量表达式。  
3. 构造函数的函数体必须为空（这一点基于构造函数没有返回值，所以不存在return expr）。

根据以上规则让我们改写类x:

```txt
class X {
public:
    constexpr X() : x1(5) {}
    constexpr X(int i) : x1(i) {}
    constexpr int get() const
    {
        return x1;
    }
}
```

```txt
private: int x1;   
};   
constexpr X x;   
char buffer[x.get()] = {0};
```

上面这段代码只是简单地给构造函数和get函数添加了constexpr说明符就可以编译成功，因为它们本身都符合常量表达式构造函数和常量表达式函数的要求，我们称这样的类为字面量类类型（literal class type）。其实代码中constexpr int get() const的const有点多余，因为在C++11中，constexpr会自动给函数带上const属性。请注意，常量表达式构造函数拥有和常量表达式函数相同的退化特性，当它的实参不是常量表达式的时候，构造函数可以退化为普通构造函数，当然，这么做的前提是类型的声明对象不能为常量表达式值：

```txt
int i = 8;  
constexpr X x(i); //编译失败，不能使用constexpr声明  
X y(i); //编译成功
```

由于i不是一个常量，因此x的常量表达式构造函数退化为普通构造函数，这时对象x不能用constexpr声明，否则编译失败。

最后需要强调的是，使用constexpr声明自定义类型的变量，必须确保这个自定义类型的析构函数是平凡的，否则也是无法通过编译的。平凡析构函数必须满足下面3个条件。

1. 自定义类型中不能有用户自定义的析构函数。

2. 析构函数不能是虚函数。  
3. 基类和成员的析构函数必须都是平凡的。

