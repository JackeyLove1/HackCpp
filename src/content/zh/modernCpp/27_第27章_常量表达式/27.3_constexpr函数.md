# 27.3 constexpr函数

constexpr不仅能用来定义常量表达式值，还能定义一个常量表达式函数，即constexpr函数，常量表达式函数的返回值可以在编译阶段就计算出来。不过在定义常量表示函数的时候，我们会遇到更多的约束规则（在C++14和后续的标准中对这些规则有所放宽）。

1. 函数必须返回一个值，所以它的返回值类型不能是void。  
2. 函数体必须只有一条语句：return expr，其中expr必须也是一个常量表达式。如果函数有形参，则将形参替换到expr中后，expr仍然必须是一个常量表达式。  
3. 函数使用之前必须有定义。

4. 函数必须用constexpr声明。

让我们来看一看下面这个例子：

```c
constexpr int max_unsigned_char()
{
return 0xff;
}
constexpr int square(int x)
{
return x * x;
}
constexpr int abs(int x)
{
return x > 0 ? x : -x;
}
int main()
{
char buffer1[max_unsigned_char()] = { 0 };
char buffer2[square(5)] = { 0 };
char buffer3[abs(-8)] = { 0 };
}
```

上面的代码定义了3个常量表达式函数，由于它们的返回值能够在编译期计算出来，因此可以直接将这些函数的返回值使用在数组长度的定义上。需要注意的是square和abs两个函数，它们接受一个形参x，当x确定为一个常量时（这里分别是5和-8），其常量表达式函数也就成立了。我们通过abs可以发现一个小技巧，由于标准规定函数体中只能有一个表达式return expr，因此是无法使用if语句的，幸运的是用条件表达式也能完成类似的效果。

接着让我们看一看反例：

```c
constexpr void foo()
{
}
constexpr int next(int x)
{
return ++x;
}
int g()
{
return 42;
}
constexpr int f()
{
return g();
}
constexpr int max_unsigned_char2();
enum {
max_uchar = max_unsigned_char2()
}
constexpr int abs2(int x)
{
if (x > 0) {
return x;
} else {
return -x;
}
}
constexpr int sum(int x)
{
int result = 0;
while (x > 0)
{
result += x--;
}
return result;
}
```

以上constexpr函数都会编译失败。其中函数foo的返回值不能为void，next函数体中的++x和f中的g()都不是一个常量表达式，函数max_unsigned_char2只有声明没有定义，函数abs2和sum

不能有多条语句。我们注意到abs2中if语句可以用条件表达式替换，可是sum函数这样的循环结构有办法替换为单语句吗？答案是可以的，我们可以使用递归来完成循环的操作，现在就来重写sum函数：

```lisp
constexpr int sum(int x)  
{  
return x > 0 ? x + sum(x - 1) : 0;  
}
```

以上函数比较容易理解，当x大于0时，将x和sum(x-1)相加，直到sum的参数为0。由于这里sum本身被声明为常量表达式函数，因此整个返回语句也是一个常量表达式，遵守了常量表达式的规则。于是我们能通过递归调用sum函数完成循环计算的任务。有趣的是，在刚开始提出常量表达式函数的时候，有些C++专家认为这种函数不应该支持递归调用，但是最终标准还是确定支持了递归调用。

需要强调一点的是，虽然常量表达式函数的返回值可以在编译期计算出来，但是这个行为并不是确定的。例如，当带形参的常量表达式函数接受了一个非常量实参时，常量表达式函数可能会退化为普通函数：

```cpp
constexpr int square(int x)  
{  
    return x * x;  
}  
int x = 5;  
std::cout << square(x);
```

这里由于x不是一个常量，因此square的返回值也可能无法在编译期确定，但是它依然能成功编译运行，因为该函数退化成了一个普通函数。这种退化机制对于程序员来说是非常友好的，它意味着我们不用为了同时满足编译期和运行期计算而定义两个相似的函数。另外，这里也存在着不确定性，因为GCC依然能在编译阶段计算square的结果，但是MSVC和CLang则不行。

有了常量表达式函数的支持，C++标准对STL也做了一些改进，比如在<limits>中增加了constexpr声明，正因如此下面的代码也可以顺利编译成功了：

```cpp
char buffer[std::numeric限度<unsigned char>::max()] = {0};
```

