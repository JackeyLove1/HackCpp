# 27.13 允许在constexpr中更改联合类型的有效成员

在C++20标准之前对constexpr的另外一个限制就是禁止更改联合类型的有效成员，例如：

```txt
union Foo {
    int i;
    float f;
};
constexpr int use() {
    Foo foo{};
    foo.i = 3;
    foo.f = 1.2f; // C++20之前编译失败
    return 1;
}
```

在上面的代码中，foo 是一个联合类型对象，foo.i = 3; 首次确定了有效成员为 i，这没有问题，接下来代码 foo.f = 1.2f; 改变有效成员为 f，这就违反了标准中关于不能更改联合类型的有效成员的规则，所以导致编译失败。现在 C++20 标准已经删除了这条规则，以上代码可以编译成功。实际编译过程中，只有 CLang 会在 C++17 标准中对以上代码报错，而 GCC 和 MSVC 均能用 C++17 和 C++20 标准编译成功。

C++20标准对constexpr做了很多修改，除了上面提到的修改以外，还修改了一些并不常用的地方，包括允许dynamic_cast和

typeid出现在常量表达式中；允许在constexpr函数使用未经评估的内联汇编。这些修改都没有需要详细介绍的特别之处，有兴趣的读者可以自己写点实验代码测试一下。

