# 28.1 表达式求值顺序的不确定性

在C++语言之父本贾尼·斯特劳斯特卢普的作品《C++程序设计语言（第4版）》中有一段这样的代码：

```txt
void f2() {
    std::string s = "but I have heard it works even if you don't believe in it";
    s.replace(0, 4, "", ).replace(s.find("even"), 4, "only").replace(s.find ("don't"), 6, "",);
    assert(s == "I have heard it works only if you believe in it");
    // OK
}
```

这段代码的本意是描述std::string成员函数replace的用法，但令人意想不到的是，在C++17之前它隐含着一个很大的问题，该问题的根源是表达式求值顺序。具体来说，是指一个表达式中的子表达式的求值顺序，而这个顺序在C++17之前是没有具体说明的，所以编译器可以以任何顺序对子表达式进行求值。比如说foo(a, b, c)，这里的foo、a、b和c的求值顺序是没有确定的。回到上面的替换函数，如果这里的执行顺序为：

1. replace(0, 4, "")  
2. tmp1 = find("even")  
3. replace(tmp1, 4, "only")

```txt
4. tmp2 = find("don't")
5. replace(tmp2, 6, "")
```

那结果肯定是“I have heard it works only if you believe in it”，没有任何问题。但是由于没有对表达式求值顺序的严格规定，因此其求值顺序可能会变成：

```lua
1. tmp1 = find("even")
2. tmp2 = find(" don't")
3. replace(0, 4, "")\n4. replace(tmp1, 4, "only")
5. replace(tmp2, 6, "")
```

相应的结果就不是那么正确了，我们会得到“I have heard it works evenonlyyou donieve in it”。

为了证实这种问题发生的可能性，我找到了两个版本的GCC编译运行上面的代码，在最新GCC中可以得到期望的字符串，其中间代码GIMPLE也很好地描述了编译后表达式求值的顺序：

```cpp
1 = std::_cxx11::basic_string<char>::replace (&s, 0, 4, "",);  
2 = std::_cxx11::basic_string<char>::find (&s, "even", 0);  
3 = std::_cxx11::basic_string<char>::replace (_1, _2, 4, "only");  
4 = std::_cxx11::basic_string<char>::find (&s, " don'\t", 0);  
std::_cxx11::basic_string<char>::replace (_3, _4, 6, "",);
```

但是在使用GCC5.4的时候，出现了“I have heard it works evenonlyyou donieve in it”的结果，查看GIMPLE以后会发现其表达式求值顺序发生了变化：

```cpp
D.22309 = std::_cxx11::basic_string<char>::find (&s, "don'\t", 0);  
D.22310 = std::_cxx11::basic_string<char>::find (&s, "even", 0);
```

```rust
D.22311 = std::_cxx11::basic_string<char>::replace (&s, 0, 4, " ");
D.22312 = std::_cxx11::basic_string<char>::replace (D.22311, D.22310, 4, "only");
std::_cxx11::basic_string<char>::replace (D.22312, D.22309, 6, " ");
```

除了上述的例子之外，我们常用的<<操作符也面临同样的问题：

```cpp
std::cout << f() << g() << h();
```

虽然我们认为上面的表达式应该按照f()、g()、h()顺序对表达式求值，但是编译器对此并不买单，在它看来这个顺序可以是任意的。

