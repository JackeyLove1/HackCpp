# 9.4 使用列表初始化的注意事项

使用列表初始化是如此的方便，让人不禁想马上运用到自己的代码中去。但是请别着急，这里还有两个地方需要读者注意。

# 9.4.1 隐式缩窄转换问题

隐式缩窄转换是在编写代码中稍不留意就会出现的，而且它的出现并不一定会引发错误，甚至有可能连警告都没有，所以有时候容易被人们忽略，比如：

```txt
int x = 12345; char y = x;
```

这段代码中变量y的初始化明显是一个隐式缩窄转换，这在传统变量初始化中是没有问题的，代码能顺利通过编译。但是如果采用列表初始化，比如char z{x}，根据标准编译器通常会给出一个错误，MSVC和CLang就是这么做的，而GCC有些不同，它只是给出了警告。

现在问题来了，在C++中哪些属于隐式缩窄转换呢？在C++标准里列出了这么4条规则。

1. 从浮点类型转换整数类型。  
2. 从long double转换到double或float，或从double转换到float，除非转换源是常量表达式以及转换后的实际值在目标可以表示的值范围内。  
3. 从整数类型或非强枚举类型转换到浮点类型，除非转换源是常量表达式，转换后的实际值适合目标类型并且能够将生成目标类型的目标值转换回原始类型的原始值。

4. 从整数类型或非强枚举类型转换到不能代表所有原始类型值的整数类型，除非源是一个常量表达式，其值在转换之后能够适合目标类型。

4条规则虽然描述得比较复杂，但是要表达的意思还是很简单的，结合标准的例子就很容易理解了：

```txt
int x = 999;  
const int y = 999;  
const int z = 99;  
const double cdb = 99.9;  
double db = 99.9;  
char c1 = x; //编译成功，传统变量初始化支持隐式缩窄转换  
char c2{x}; //编译失败，可能是隐式缩窄转换，对应规则4  
char c3{y}; //编译失败，确定是隐式缩窄转换，999超出char能够适应的范围，对应规则4  
char c4{z}; //编译成功，99在char能够适应的范围内，对应规则4  
unsigned char uc1 = {5}; //编译成功，5在unsigned char能够适应的范围内，//对应规则4  
unsigned char uc2 = {-1}; //编译失败，unsigned char不能够适应负数，对应规则4  
unsigned int ui1 = {-1}; //编译失败，unsigned int不能够适应负数，对应规则4  
signed int si1 = {(unsigned int)-1}; //编译失败，signed int不能够适应-1所对应的 //unsigned int，通常是4294967295，对应规则4  
int ii = {2.0}; //编译失败，int不能适应浮点范围，对应规则1  
float f1{x}; //编译失败，float可能无法适应整数或者互相转换，对应规则3  
float f2{7}; //编译成功，7能够适应float，且float也能转换回整数7，对应规则3  
float f3{cdb}; //编译成功，99.9能适应float，对应规则2  
float f4{db}; //编译失败，可能是隐式缩窄转无法表达double，对应规则2
```

# 9.4.2 列表初始化的优先级问题

通过9.2节和9.3节的介绍我们知道，列表初始化既可以支持普通的构造函数，也能够支持以std::initializer_list为形参的构造函数。如果这两种构造函数同时出现在同一个类里，那么编译器会如何选择构造函数呢？比如：

```cpp
std::vector<int> x1(5, 5);  
std::vector<int> x2{5, 5};
```

以上两种方法都可以对std::vector<int>进行初始化，但是初始化的结果却是不同的。变量x1的初始化结果是包含5个元素，且5个元素的值都为5，调用了vector(size_type count, const T& value, const Allocator& alloc = Allocator())这个构造函数。而变量x2的初始化结果是包含两个元素，且两个元素的值为5，也就是调用了构造函数vector(std::initializer_list<T> init, const Allocator& alloc = Allocator())。所以，上述问题的结论是，如果有一个类同时拥有满足列表初始化的构造函数，且其中一个是以std::initializer_list为参数，那么编译器将优先以std::initializer_list为参数构造函数。由于这个特性的存在，我们在编写或阅读代码的时候就一定需要注意初始化代码的意图是什么，应该选择哪种方法对变量初始化。

最后让我们回头看一看9.2节中没有解答的一个问题，std::map<std::string，int> x8{{"bear",4}}，{"cassowary",2}，{"tiger",7}}中两个层级的列表初始化分

别使用了什么构造函数。其实答案已经非常明显了，内层{"bear",4}、{"cassowary",2}和{"tiger",7}都隐式调用了std::pair的构造函数pair(const T1& x, const T2& y)，而外层的{...}隐式调用的则是std::map的构造函数map(std::initializer_list=value_type>init, const Allocator&)。

