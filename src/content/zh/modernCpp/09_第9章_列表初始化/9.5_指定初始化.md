# 9.5 指定初始化

为了提高数据成员初始化的可读性和灵活性，C++20标准中引入了指定初始化的特性。该特性允许指定初始化数据成员的名称，从而使代码意图更加明确。让我们看一看示例：

```c
struct Point {
    int x;
    int y;
};
```

虽然在这段代码中Point的初始化并不如Point p{4,2};方便，但是这个例子却很好地展现了指定初始化语法。实际上，当初始化的结构体的数据成员比较多且真正需要赋值的只有少数成员的时候，这样的指定初始化就非常好用了：

```txt
struct Point3D {
    int x;
    int y;
    int z;
};
```

```txt
Point3D p{ .z = 3 }; // x = 0, y = 0
```

在上面的代码中Point3D需要3个坐标，不过我们只需要设置z的值，指定

$\cdot z = 3$  即可。其中x和y坐标会调用默认初始化将其值设置为0。可能这个例子还是不能完全体现出它相对于Point3D p{0，0，3}；的优势所在，不过读者应该能感觉到，一旦结构体更加复杂，指定初始化就一定能带来不少方便之处。

最后需要注意的是，并不是什么对象都能够指定初始化的。

1. 它要求对象必须是一个聚合类型，例如下面的结构体就无法使用指定初始化：

```c
struct Point3D {
    Point3D() {}
    int x;
    int y;
    int z;
};
```

这里读者可能会有疑问，如果不能提供构造函数，那么我们希望数据成员x和y的默认值不为0的时候应该怎么做？不要忘了，从C++11开始我们有了非静态成员变量直接初始化的方法，比如当希望Point3D的默认坐标值都是100时，代码可以修改为：

```txt
struct Point3D {
    int x = 100;
    int y = 100;
    int z = 100;
```

```javascript
}; Point3D p{ .z = 3 }; // x = 100, y = 100, z = 3
```

2. 指定的数据成员必须是非静态数据成员。这一点很好理解，静态数据成员不属于某个对象。  
3. 每个非静态数据成员最多只能初始化一次:

```javascript
Point p{ .y = 4, .y = 2 }; // 编译失败，y不能初始化多次
```

4. 非静态数据成员的初始化必须按照声明的顺序进行。请注意，这一点和C语言中指定初始化的要求不同，在C语言中，乱序的指定初始化是合法的，但C++不行。其实这一点也很好理解，因为C++中的数据成员会按照声明的顺序构造，按照顺序指定初始化会让代码更容易阅读：

```txt
Point p{ .y = 4, .x = 2 }; // C++编译失败，C编译没问题
```

5. 针对联合体中的数据成员只能初始化一次，不能同时指定：

```javascript
union u {
    int a;
    const char* b;
};  
u f = { .a = 1 }; // 编译成功  
u g = { .b = "asdf" }; // 编译成功  
u h = { .a = 1, .b = "asdf" }; // 编译失败，同时指定初始化联合体中的多个数据成员
```

6. 不能嵌套指定初始化数据成员。虽然这一点在C语言中也是允许的，但是C++标准认为这个特性很少有用，所以直接禁止了：

```c
struct Line {
    Point a;
    Point b;
};
```

当然，如果确实想嵌套指定初始化，我们可以换一种形式来达到目的：

```javascript
Line 1{ .a {y = 5} };
```

7. 在C++20中，一旦使用指定初始化，就不能混用其他方法对数据成员初始化了，而这一点在C语言中是允许的：

```txt
Point p{ .x = 2, 3 }; // 编译失败，混用数据成员的初始化
```

8. 最后再来了解一下指定初始化在C语言中处理数组的能力，当然在  $\mathrm{C}++$  中这同样是被禁止的：

```txt
int arr[3] = { [1] = 5 }; // 编译失败
```

C++标准中给出的禁止理由非常简单，它的语法和lambda表达式冲突了。

