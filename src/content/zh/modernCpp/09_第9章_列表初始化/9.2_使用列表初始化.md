# 9.2 使用列表初始化

$\mathrm{C} + + 11$  标准引入了列表初始化，它使用大括号{}对变量进行初始化，和传统变量初始化的规则一样，它也区分为直接初始化和拷贝初始化，例如：

```cpp
include <string>   
struct C{ C(std::string a,int b){ } C(int a){ }   
}；   
void foo(C){} Cbar()
```

```txt
{ return {"world", 5};   
}   
int main()   
{ int  $\mathrm{x} = \{5\}$  //拷贝初始化 int x1{8}; //直接初始化 Cx2  $= \{4\}$  //拷贝初始化 Cx3{2}; //直接初始化 foo({8}); //拷贝初始化 foo({"hello", 8}); //拷贝初始化 Cx4  $\equiv$  bar(); //拷贝初始化 C\*x5  $\equiv$  new C{"hi", 42}；//直接初始化
```

仔细观察以上代码会发现，列表初始化和传统的变量初始化几乎相同，除了foo({"hello", 8})和return {"world", 5}这两处不同。读者应该发现了列表初始化在这里的奥妙所在，它支持隐式调用多参数的构造函数，于是{"hello", 8}和{"world", 5}通过隐式调用构造函数C::C(std::string a, int b)成功构造了类C的对象。当然了，有时候我们并不希望编译器进行隐式构造，这时候只需要在特定构造函数上声明explicit即可。

讨论使用大括号初始化变量就不得不提用大括号初始化数组，例如int x[] = {1,2,3,4,5}。不过遗憾的是，这个特性无法使用到STL的vector、list等容器中。想要初始化容器，我们不得不编写一个循环来完成初始化工作。现在，列表初始化将程序员从这个问题中解放了出来，我们可以使用列表初始化对标准容器进行初始化了，例如：

```txt
include <vector> #include <list>
```

```cpp
include <set>   
#include <map>   
#include <string>   
int main()   
{ int  $\mathrm{x[ ] = \{1,2,3,4,5\}}$  int x1[]{1,2,3,4,5}; std::vector<int> x2{1,2,3,4,5}； std::vector<int> x3  $=$  {1,2,3,4,5}； std::list<int> x4{1,2,3,4,5}； std::list<int> x5  $=$  {1,2,3,4,5}； std::set<int> x6{1,2,3,4,5}； std::set<int> x7  $=$  {1,2,3,4,5}； std::map<std::string，int> x8{{"bear",4}, {"cassowary",2}, {"tiger",7}}; std::map<std::string，int> x9  $=$  {{"bear",4}, {"cassowary",2}, {"tiger",7}};
```

以上代码在C++11环境下可以成功编译，可以看到使用列表初始化标准容器和初始化数组一样简单，唯一值得注意的地方是对x8和x9的初始化，因为它使用了列表初始化的一个特殊的特性。关于这个特性先卖一个关子，后面再做解释。让我们先将注意力放在如何能让容器支持列表初始化的问题上。

# 9.3 std::initializer_list详解

标准容器之所以能够支持列表初始化，离不开编译器支持的同时，它们自己也必须满足一个条件：支持

std::initializer_list为形参的构造函数。

std::initializer_list简单地说就是一个支持begin、end以及size成员函数的类模板，有兴趣的读者可以翻阅STL的源代码，然后会发现无论是它的结构还是函数都直截了当。编译器负责将列表里的

元素（大括号包含的内容）构造为一个std::initializer_list的对象，然后寻找标准容器中支持std:: initializer_list为形参的构造函数并调用它。而标准容器的构造函数的处理就更加简单了，它们只需要调用std:: initializer_list对象的begin和end函数，在循环中对本对象进行初始化。

通过了解原理能够发现，支持列表初始化并不是标准容器的专利，我们也能写出一个支持列表初始化的类，需要做的只是添加一个以std::initializer_list为形参的构造函数罢了，比如下面的例子：

```cpp
include<iostream>   
#include <string>   
struct C{ C(std::initializer_list<std::string> a) { for(const std::string\* item  $\equiv$  a.begin();item  $! =$  a.end(); ++item）{ std::cout<<\*item<<""; } std::cout<<std::endl; 1   
}；   
int main() { C c{ "hello", "c++", "world" };   
}
```

上面这段代码实现了一个支持列表初始化的类C，类C的构造函数为C(std:: initializer_list<std::string>a)，这是支持列表初始化所必需的，值得注意的是，std::

initializer_list的begin和end函数并不是返回的迭代器对象，

而是一个常量对象指针const T *。本着刨根问底的精神，让我们进一步探究编译器对列表的初始化处理：

```cpp
include<iostream>   
#include <string>   
struct C{ C(std::initializer_list<std::string> a) { for(const std::string\* item  $\equiv$  a.begin();item  $! =$  a.end(); ++item）{ std::cout<<item<<""; } std::cout<<std::endl; 1   
}；   
int main() { C c{ "hello", "c++", "world" }; std::cout<< "sizeof(std::string)  $=$  " << std::hex<<sizeof(std::string)  $<   <$  std::endl;
```

运行输出结果如下：

```rust
0x77fdd0 0x77fdf0 0x77fe10 sizeof(std::string) = 20
```

以上代码输出了std::string对象的内存地址以及单个对象的大小（不同编译环境的std::string实现方式会有所区别，其对象大小也会不同，这里的例子是使用GCC编译的，std::string对象的大小为0x20）。仔细观察3个内存地址会发现，它们的差别正好是std::string所占的内存大小。于是我们能推断出，编译器所进行的工作大概是这样的：

```cpp
const std::string _a[3] = {std::string{"hello"}, std::string {"c++"}, std::string {"world"}}; C c(std::initializer_list<std::string>(_, a+3));
```

另外，有兴趣的读者不妨用GCC对上面这段代码生成中间代码GIMPLE，不出意外会发现类似这样的中间代码：

```cpp
main()   
{ struct initializer_list D.40094; const struct basic_string D.36430[3]; std::_cxx11::basic_string<char>::basic_string (&D.36430[0], "hello", &D.36424); std::_cxx11::basic_string<char>::basic_string (&D.36430[1], "c++", &D.36426); std::_cxx11::basic_string<char>::basic_string (&D.36430[2], "world", &D.36428); D.40094._M_array = &D.36430; D.40094._M_len = 3; C::C (&c, D.40094); }
```

