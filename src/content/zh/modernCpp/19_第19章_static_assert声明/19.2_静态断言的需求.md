# 19.2 静态断言的需求

虽然运行时断言可以满足一部分需求，但是它有一个缺点就是必须让程序运行到断言代码的位置才会触发断言。如果想在模板实例化的时候对模板实参进行约束，这种断言是无法办到的。我们需要一个能在编译阶段就给出断言的方法。可惜在C++11标准之前，没有一个标准方法来达到这个目的，我们需要利用其他特性来模拟。下面给出几个可行的方案：

```txt
defineSTATIC.Assert_CONCAT_IMP(x,y)x##y #defineSTATIC_assert_CONCAT(x，y）\ STATIC.Assert_CONCAT_IMP(x，y)   
//方案1   
#defineSTATICAssert(expr) \ do{ charSTATIC_assert_CONCAT( static_assert_var，COUNTER_) \\ [(expr)!  $= 0$  ?1：-1]； }while(0)   
template<bool>
```

```c
struct static_assert_st;
template<> 
struct static_assert_st<true> {}; // 方案2 
#define STATIC_ASSERT2Expr() \ 
    static_assert_st<(expr) != 0>(); // 方案3 
#define STATIC_ASSERT3Expr() \ 
    static_assert_st<(expr) != 0> \ 
    STATIC_ASSERT_CONCAT(
        static_assert_var, __COUNTER__)
```

以上代码的方案1，利用的技巧是数组的大小不能为负值，当expr表达式返回结果为false的时候，条件表达式求值为-1，这样就导致数组大小为-1，自然就会引发编译失败。方案2和方案3则是利用了C++模板特化的特性，当模板实参为true的时候，编译器能找到特化版本的定义。但当模板参数为false的时候，编译器无法找到相应的特化定义，从而编译失败。方案2和方案3的区别在于，方案2会构造临时对象，这让它无法出现在类和结构体的定义当中。而方案3则声明了一个变量，可以出现在结构体和类的定义中，但是它最大的问题是会改变结构体和类的内存布局。总而言之，虽然我们可以在一定程度上模拟静态断言，但是这些方案并不完美。

