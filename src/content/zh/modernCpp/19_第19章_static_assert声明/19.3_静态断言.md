# 19.3 静态断言

static_assert声明是C++11标准引入的特性，用于在程序编译阶段评估常量表达式并对返回false的表达式断言，我们称这种断言为静态断言。它基本上满足我们对静态断言的要求。

1. 所有处理必须在编译期间执行，不允许有空间或时间上的运行时成本。  
2. 它必须具有简单的语法。  
3. 断言失败可以显示丰富的错误诊断信息。  
4. 它可以在命名空间、类或代码块内使用。  
5. 失败的断言会在编译阶段报错。

C++11标准规定，使用static_assert需要传入两个实参：常量表达式和诊断消息字符串。请注意，第一个实参必须是常量表达式，因为编译器无法计算运行时才能确定结果的表达式：

```cpp
include <typetraits>   
class A{   
}；   
class B : public A {   
}；   
class C{   
}；   
template<class T>   
class E{ static_assert(std::is_base_of<A,T>::value，"T is not base of A");   
}；   
int main(int argc, char *argv[])   
{ static_assert(args > 0, "args > 0"); // 使用错误，argc>0不是常量表达式  $\mathrm{E} <   \mathrm{C}>$  x; //使用正确，但由于A不是C的基类，所以触发断言
```

```txt
static_assert(sizeof(int) >= 4, // 使用正确，表达式返回真，不会触发失败断言
    "sizeof(int) >= 4");
E<B> y; // 使用正确，A是B的基类，不会触发失败断言
```

在上面的代码中， $\arg c > 0$ 依赖于用户输入的参数，显然不是一个常量表达式。在这种情况下，编译器会报错，符合上面的第5条要求。类模板E对static_assert的使用是正确的，根据第1条和第4条要求，static_assert可以在类定义里使用并且不会改变类的内部状态。只不过在实例化类模板E<C>的时候，因为A不是C的基类，所以会触发静态断言，导致编译中断。

