# 19.4 单参数static_assert

不知道读者是否和我有同样的想法，在大多数情况下使用static_assert的时候输入的诊断信息字符串就是常量表达式本身，所以让常量表达式作为诊断信息字符串参数的默认值是非常理想的。为了达到这个目的，我们可以定义一个宏：

```txt
define LAZY_STATIC_ASSERT(B) static_assert(B, #B)
```

可能是该需求比较普遍的原因，2014年2月C++标准委员会就提出升级static_assert的想法，希望让其支持单参数版本，即常量表达式，而断言输出的诊断信息为常量表达式本身。这个观点提出后得到了大多数人的认同，但是由于2014年2月C++14标准已经发布了，因

此该特性不得不顺延到C++17标准中。在支持C++17标准的环境中，我们可以忽略第二个参数：

```cpp
include <typetraits>   
class A{   
}；   
class B : public A {   
}；   
class C{   
}；   
template<class T>   
class E{ static_assert(std::is_base_of<A,T>::value);   
}；   
int main(int argc，char \*argv[])   
{ E<C> x; //使用正确，但由于A不是C的基类，会触 发失败断言 static_assert(sizeof(int)  $<  4$  ）；//使用正确，但表达式返回false，会触 发失败断言   
}
```

不过在GCC上，即使指定使用C++11标准，GCC依然支持单参数的static_assert。MSVC则不同，要使用单参数的static_assert需要指定C++17标准。

