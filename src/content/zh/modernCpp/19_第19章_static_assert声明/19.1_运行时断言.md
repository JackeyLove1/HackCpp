# 19.1 运行时断言

在静态断言出现以前，我们使用的是运行时断言，只有程序运行起来之后才有可能触发它。通常情况下运行时断言只会在Debug模式下使用，因为断言的行为比较粗暴，它会直接显示错误信息并终止程序。在Release版本中，我们通常会忽略断言（头文件cassert已经通过宏NDEBUG对Debug和Release版本做了区分处理，我们可以直接使用assert）。还有一点需要注意，断言不能代替程序中的错误检查，它只应该出现在需要表达式返回true的位置，例如：算术表达式的除数不能为0，分配内存的大小必须大于0等。相反，如果表达式中涉及外部输入，则不应该依赖断言，例如客户输入、服务端返回等：

```c
void* resize_buffer(void* buffer, int new_size)  
{  
    assert(buffer != nullptr); // OK，用assert检查函数参数  
    assert(new_size > 0);  
    assert(new_size <= MAX_BUFFER_SIZE);  
    ...  
}  
bool get_user_input(char c)  
{  
    assert(c == '\0x0d'); // 不合适，assert不应该用于检查外部输入  
    ...  
}
```

在上面这段代码中，我们对函数resize_buffer的形参buffer和new_size进行了断言，显然作为一个重新分配内存的函数，这两个参数必须是合法的。建议一个断言处理一个判别式，这样一来当断言发生的时候能迅速定位到问题所在。如果写成assert((buffer != nullptr) && (new_size > 0) && (new_size <= MAX_buffer_SIZE))，则当断言发生的时候，我们还是无法马上确定问题。而函数get_user_input就不应该使用断言检查参数了，因为用户输入的字符可能是各种各样的。

