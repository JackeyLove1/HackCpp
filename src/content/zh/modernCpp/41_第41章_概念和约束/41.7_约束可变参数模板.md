# 41.7 约束可变参数模板

使用概念约束可变参数模板实际上就是将各个实参替换到概念的约束表达式后合取各个结果。例如下面的代码：

```solidity
template<class T> concept C1 = true;
template<C1...T> struct s1 {};
```

s1包展开后的约束为(C1<T> &&...），具体来说对于s1<int, double，std::string>，其约束实际上为(C1<int> &&

C1<double> && C1<std::string>)。以上代码比较容易理解，但是有时候代码会更加复杂一些，比如：

```txt
template<class... Ts> concept C2 = true;
template<C2... T> struct s2{};
```

现在问题来了，s2包展开之后的结果应该是(C2<T> &&...)、C2<T...>还是(C2<T...> &&...)呢？是不是有点难以抉择，请记住，在这种情况下包展开的结果依然是(C2<T> &&...)。不得不说，C2<T...>曾经是正确的，但现在不是了。再次强调一下，包展开的结果是(C2<T> &&...）。

接下来让我们更进一步，对于：

```txt
template<class T, class U> concept C3 = true;
template<C3<int> T> struct s3{};
```

经过模板实参替换后实际的约束为C<T，int>，对比这个结果，下面的代码：

```txt
template<C3<int>... T> struct s3{};
```

包展开后的约束应该是 (C3<T, int> &&... )。

