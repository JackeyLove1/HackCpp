# 41.8 约束类模板特化

约束可以影响类模板特化的结果，在模板实例化的时候编译器会自动选择更满足约束条件的特化版本进行实例化，比如：

```cpp
template<typename T> concept C = true;
template<typename T> struct X {
    X() { std::cout << "1.template<typename T> struct X" << std::endl; }
};
template<typename T> struct X<T*> {
    X() { std::cout << "2.template<typename T> struct X<T*" << std::endl; }
};
template<C T> struct X<T> {
    X() { std::cout << "3.template<C T> struct X<T>" << std::endl; }
};
X<int*> s1;
X<int> s2;
```

以上代码的输出结果如下：

```txt
2. template<typename T> struct X<T*>
3. template<C T> struct X<T>
```

显然，对于X<int*>而言，匹配更精确的是

```cpp
template<typename T> struct X<T*>。而对于X<int>，由于 template<C T> struct X<T>有概念约束，相对于 template<typename T> struct x更加特殊，因此编译器选择前者进行实例化。

上面的例子只是说明了约束对类模板特化的影响，实际上约束在类模板特化上可以发挥很大的作用，请看以下代码：

```cpp
template<typename T> concept C = requires(T t) { t.f(); };
template<typename T> struct S {
    S() {
        std::cout << "1.template<typename T> struct S" << std::endl;
    }
}; template<C T> struct S<T> {
    S() {
```

```cpp
std::cout << "2.template<C T> struct S<T>" << std::endl;
}
```

以上代码的输出结果如下：

```txt
1. template<typename T> struct S
2. template<C T> struct S<T>
```

可以看出，由于S<int>中的int无法满足概念c的约束条件，因此编译器使用template<typename T> struct S对s1进行实例化。而对于S<Arg>，Arg满足概念c的约束，所以编译器选择更加特殊的template<C T> struct S<T>来实例化s2。值得注意的是，如果只是约束构造函数，区分不同类型的构造方法，那么有更简单的方式：

```cpp
template<typename T> struct S {
    S() {
        std::cout << "1.call S()" << std::endl;
    }
    S() requires requires(T t) { t.f(); } {
        std::cout << "2.call S() requires requires(T t)" << std::endl;
    }
};
```

