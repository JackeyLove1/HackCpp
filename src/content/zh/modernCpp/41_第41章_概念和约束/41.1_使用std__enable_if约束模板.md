# 41.1 使用std::enable_if约束模板

在第40章中我们探讨了SFINAE规则，即替换失败不是错误。对于SFINAE规则，一个典型的应用就是标准库中的std::enable_if模板元函数，SFINAE规则使该模板元函数能辅助模板的开发者限定实例化模板的模板实参类型，举例来说：

```cpp
template<class T, class U = std::enable_if_t<std::is_integral_v>>>
struct X{};
X<int> x1; //编译成功
X<std::string> x2; //编译失败
```

在上面的代码中，类模板x的模板形参class U =

std::enable_if_t <std::is_integral_v<T>>只是作为一个约束条件存在，当T的类型为整型时，std::is_integral_v<T>返回true，于是std::enable_if_t<std::is_

integral_v<T>>返回类型void，所以X<int>实际上是X<int, void>的一个合法类型。反之，对于X<std::string>来说，T的类型不为整型，std::enable_if不存在嵌套类型type，于是

std::enable_if_t<std::isIntegral_v<T>>无法符合语法规范，导致编译失败。

以下是enable_if的一种实现方法：

```txt
template bool B, class T = void> struct enable_if {}; template<class T> struct enable_if <true, T> { using type = T; };
```

可以看到enable_if的实现十分简单，而让它发挥如此大作用的幕后功臣就是SFINAE规则。不过使用std::enable_if作为模板实参约束也有一些硬伤，比如使用范围窄，需要加入额外的模板形参等。于是为了更好地对模板进行约束，C++20标准引入了概念（concept）。

