# 41.2 概念的背景介绍

概念是对C++核心语言特性中模板功能的扩展。它在编译时进行评估，对类模板、函数模板以及类模板的成员函数进行约束：它限制了能被接受为模板形参的实参集。

实际上概念并不是新鲜的特性，早在2008年“概念”已经被C++0x接受，只不过在2009年7月的法兰克福C++标准委员会会议上，通过投票表决删除了C++0x中的“概念”，原因是委员会需要限制新语法规则带来的风险并保证标准的实现进度。虽然在当时对于大多数程序员的影响不大，但是对于研究和意识到该特性的潜力的人来说确实是非常令人失望的。

“概念”最早的实现要追溯到2016年的GCC6.1，在GCC6.1中我们可以使用-fconcepts开关来开启“概念”实验性特性，当时我们称其为“Concept TS”（Concepts Technical Specification）。但即使已经实现了“概念”特性，也没让它进入C++17标准，原因简单来说就是“还不够好”。就这样一直到2017的多伦多C++标准委员会会议，新的概念功能特性才被正式列入C++20标准中。

所以在C++20中，上一节的例子可以改写为：

```cpp
template<class C> conceptraitsType = std::is_integral_v<C>; template<class T> struct X{};
```

上面的代码使用concept关键字定义了模板形参T的约束条件IntegerType，模板实参替换T之后必须满足std::is_integral_v<C>计算结果为true的条件，否则编译器会给出IntegerType约束失败的错误提示。这份代码还可以简化为：

```cpp
template<class T> requires std::is_integral_v<T> struct X {};
```

requires关键字可以直接约束模板形参T，从而达到相同的效果。concept和requires的详细用法将在后面的章节中讨论。现在我想让大家看一看用概念约束模板的另外一个优势，请对比下面的编译错误日志：

```ruby
std::enable_if: In substitution of 'template bool _Cond, class _Tp> using enable_if_t = typename std::enable_if::type [with bool _Cond = false; _Tp = void]': required from here error: no type named 'type' in 'struct std::enable_if<false, void>' 2554 | using enable_if_t = typename enable_if<_Cond, _Tp>::type; concept: error: template constraint failure for 'template<class T> requires IntegerType<T> struct X'
```

显然，使用concept代码的错误日志更加简洁清晰，在错误日志中明确地提示用户struct x模板约束失败。

