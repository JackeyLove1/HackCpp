# 41.6 requires表达式

requires关键字除了可以引入requires子句，还可以用来定义一个requires表达式，该表达式同样是一个纯右值表达式，表达式为true时表示满足约束条件，反之false表示不满足约束条件。需

要特别说明的是requires表达式的判定标准，因为这个标准比较特殊，具体来说是对requires表达式进行模板实参的替换，如果替换之后requires表达式中出现无效类型或者表达式违反约束条件，则requires表达式求值为false，反之则requires表达式求值为true。例如：

```cpp
template<class T> concept Check = requires {
    T().clear();
};
template<Check T> struct G{}; 
G<std::vector<char>> x; //编译成功
G<std::string>y; //编译成功
G<std::array<char, 10>> z; //编译失败
```

上面的代码使用requires表达式定义了概念Check，Check要求T().clear();是一个合法的表达式。因此

G<std::vector<char>> x;和G<std::string>y;可以顺利通过编译，因为std::vector<char>和std::string都有成员函数clear()。而std::array<char，10>中不存在成员函数clear()，导致编译失败。

值得注意的是，requires表达式还支持形参列表，使用形参列表可以使requires表达式更加灵活清晰，比如在上面的例子中，我希望除了要求实参具备成员函数clear()以外还需要支持+运算符，那么我们可以将代码修改为：

```javascript
template<class T> concept Check = requires {
    T().clear();
    T() + T();
};
```

以上代码可以完成检查+运算符的工作，但通常我们并不这样做，因为存在更加清晰的方式：

```txt
template<class T> concept Check = requires(T a, T b) {
    a.clear();
    a + b;
};
```

在上面的代码中，我们使用了requires表达式的形参列表，形参列表和普通函数的形参列表类似，不同的是这些形参并不存在生命周期和存储方式，只在编译期起作用，而且只有在requires表达式作用域内才是有效的。自然的，对于需要运行时计算实参数量的不定参数列表来说，requires表达式的形参列表也是不支持的：

```txt
template<typename T> concept C = requires(T t, ...) { // 编译失败，requires表达式的形参列表不能使用...
    t;
};
```

回过头来看经过修改的概念，Check会将

G<std::vector<char>> x; 拒之门外，因为

std::vector<char>的实例是无法使用+运算符的。另外，由于

std::string支持用+运算符完成字符串的连接，因此

G<std::string> y;能够编译成功。

在上面的requires表达式中，a.clear()和a + b可以说是对模板实参的两个要求，这些要求在C++标准中称为要求序列（requirement-seq）。要求序列分为4种，包括简单要求、类型要求、复合要求以及嵌套要求，接下来就让我们详细讨论这4种要求。

# 41.6.1 简单要求

简单要求是不以requires关键字开始的要求，它只断言表达式的有效性，并不做表达式的求值操作。如果表达式替换模板实参失败，则该要求的计算结果为false：

```txt
template<typename T> concept C = requires (T a, T b) {
    a + b;
};
```

在上面的代码中a + b是一个简单要求，编译器会断言a + b的合法性，但不会计算其最终结果。不以requires关键字开始是简单表达式的重要特征，后面将提到的嵌套要求则正好相反，它要求以requires关键字开头。

# 41.6.2 类型要求

类型要求是以typename关键字开始的要求，紧跟typename的是一个类型名，通常可以用来检查嵌套类型、类模板以及别名模板特

化的有效性。如果模板实参替换失败，则要求表达式的计算结果为false:

```cpp
template<typename T, typename T::type = 0> struct S;
template<typename T> using Ref = T&;
template<typename T> concept C = requires {
    typename T::inner; // 要求嵌套类型
    typename S<T>; // 要求类模板特化
    typename Ref<T>; // 要求别名模板特化
};
```

在上面的代码中，概念c中有3个类型要求，分别为T::inner、S<T>和Ref<T>，它们各自对应的是对嵌套类型、类模板特化和别名模板特化的检查。请注意代码中的类模板声明s，它不是一个完整类型，缺少了类模板定义。但是编译器仍然可以编译成功，因为标准明确指出类型要求中的命名类模板特化不需要该类型是完整的。

# 41.6.3 复合要求

相对于简洁的简单要求和类型要求，复合要求则稍微复杂一些，比如下面的代码：

```javascript
template<class T> concept Check = requires(T a, T b) {
    {a.clear()} noexcept;
```

```txt
$\{a + b\}$  noexcept -> std::same_as<int>;
```

在上面的代码中，{a.clear()} noexcept;和{a + b}noexcept -> std::same_as<int>;是需要断言的复合要求。复合要求可以由3个部分组成：{}中的表达式、noexcept以及->后的返回类型约束，其中noexcept和->后的返回类型约束是可选的。根据标准，断言一个复合要求需要按照以下顺序。

1. 替换模板实参到  $\{\mathrm{E}\}$  中的表达式  $\mathrm{E}$ , 检测表达式的有效性。  
2. 如果使用了noexcept，则需要检查并确保{E}中的表达式E不会有抛出异常的可能。  
3. 如果使用了->后的返回类型约束，则需要将模板实参替换到返回类型约束中，并且确保表达式E的结果类型，即decltype((E))，满足返回类型约束。

如果出现任何不符合以上检查规则的情况，则requires表达式判定为false。例如，在之前的代码中只有G<std::string> y;可以编译成功，因为std::string不仅存在成员函数clear()，也能够进行+操作。但是现在，a + b又多了两个约束，首先noexcept要求a + b不能有抛出异常的可能性，其次其结果类型必须满足概念std::same_as<int>；的约束。其中概念std::same_as的实现类似于：

```cpp
template<class T, class U>
concept same_as = std::is_same_v<T, U> && std::is_same_v<U, T>;
```

a + b的结果类型会作为第一个模板实参，实际编译代码类似于：

```cpp
std::same_as<decltype((a + b)), int>
```

显然，两个std::string相加的运算结果不可能是int类型，所以G<std::string> y; 是不能通过编译的。最后如果我们给std::vector<char>添加以下声明：

```cpp
int operator+ (const std::vector<char>&, const std::vector<char>&) noexcept;
```

那么G<std::vector<char>> x;就可以编译成功了。值得注意的是，这里的noexcept是必不可少的，operator+不需要是完整的。

# 41.6.4 嵌套要求

正如简单要求中提到的，嵌套要求是以requires开始的要求，它通常根据局部形参来指定其他额外的要求。例如：

```cpp
template<class T> concept Check = requires(T a, T b) {
    requires std::same_as<decltype((a + b)), int};
};
```

在上面的代码中，requires std::same_as<decltype((a + b)), int>；是一个嵌套要求，它要求表达式a + b的结果类型与int相同，可以等同于：

```cpp
template<class T> concept Check = requires(T a, T b) {
    {a + b} -> std::same_as<int>();
};
```

最后请注意，这里的局部形参不是可以参与运算的操作数，例如：

```javascript
template<typename T> concept C = requires(T a) {
    requires sizeof(a) == 4; // 编译成功
    requires a == 0; // 编译失败
};
```

这里  $a == 0$  中  $a$  的值是无法计算的。

