# 41.3 使用concept和约束表达式定义概念

我们可以使用concept关键字来定义概念，例如：

```cpp
template<class C> conceptraitsType = std::is_integral_v<C>;
```

其中IntegerType是概念名，这里的std::is_integral_v<C>称为约束表达式。

约束表达式应该是一个bool类型的纯右值常量表达式，当实参替换形参后，如果表达式计算结果为true，那么该实参满足约束条件，概念的计算结果为true。反之，在实参替换形参后，如果表达式计算结果为false或者替换结果不合法，则该实参无法满足约束条件，概念的计算结果为false。

请注意，这里所谓的计算都是编译期执行的，概念的最终结果是一个bool类型的纯右值：

```cpp
template<class T> concept TestConcept = true;
static_assert(TestConcept<int>>);
```

通过上面的代码可以看出，TestConcept<int>是一个bool类型的常量表达式，因为它能够作为static_assert的实参。

约束表达式还支持一般的逻辑操作，包括合取和析取：

```cpp
// 合取  
template<class C>  
concept SignedIntegerType = std::is_integral_v<C> && std::is_signed_v<C>;  
// 析取  
template<class C>  
concept IntegerFloatingType = std::is_integral_v<C> || std::is-floating_point_v<C>;
```

观察上面的代码可知，约束的合取是通过逻辑与&&完成的，运算规则也与逻辑与相同，要求两个约束都为true，整个约束表达式才会为true，当左侧约束为false时，整个约束表达式遵循短路原则为false。同样，约束的析取是通过逻辑或||完成的，运算规则与逻辑或相同，只要任意约束为true，整个约束表达式就会为true，当左侧约束为true时，整个约束表达式遵循短路原则为true。让我们尝试用上面的两个概念约束模板实参：

```txt
template <SignedIntegerType T> struct X {}; template <IntegerFloatingType T>
```

```txt
struct Y {};  
X<int> x1; //编译成功  
X<unsigned int> x2; //编译失败  
Y<int> y1; //编译成功  
Y<double> y2; //编译成功
```

在上面的代码中，只有x2会编译失败，因为x的模板形参的约束条件是一个有符号整型。

除了逻辑操作的合取和析取之外，约束表达式还有一种特殊情况叫作原子约束，很明显原子约束中的表达式不能存在约束的合取或者析取。由于原子约束概念解释起来比较晦涩，而且需要配合requires子句示例做解释，因此将在后面详细讨论。

