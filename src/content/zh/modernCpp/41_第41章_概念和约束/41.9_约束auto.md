# 41.9 约束auto

上文曾介绍过使用概念约束简写函数模板中的auto占位符，事实上对auto和decltype (auto)的约束可以扩展到普遍情况，例如：

```txt
template<class C> conceptIntegerType = std::is_integral_v<C>; 
IntegerType auto i1 = 5.2; //编译失败 
IntegerType auto i2 = 11; //编译成功 
IntegerType decltypeauto i3 = 4.8; //编译失败 
IntegerType decltype (auto) i4 = 7; //编译成功 
IntegerType auto fool() { return 1.1; } //编译失败 
IntegerType auto foo2() { return 0; } //编译成功 
auto bar1 = [] ->IntegerType auto { return 1.0; }; //编译失败 
auto bar2 = [] ->IntegerType auto { return 10; }; //编译成功
```

在上面的代码中，概念IntegerType约束auto的推导结果必须是一个整型，于是在声明并初始化i1和i3的时候会导致编译失败。同理，函数foo1返回值为浮点类型也会导致编译失败。对于lambda表达式也是一样，只不过需要显式声明返回类型和约束概念。

最后需要注意的是，要约束auto或decltype (auto)总是紧随约束之后。因此，cv限定符和概念标识符不能随意混合：

```txt
const IntegerType auto i5 = 23; //编译成功  
IntegerType auto const i6 = 8; //编译成功  
IntegerType const auto i7 = 6; //编译失败
```

在上面的代码中，i5和i6可以顺利通过编译，因为auto紧跟在IntegerType之后。反观i7的声明，IntegerType和auto之间存在const，导致编译失败。

