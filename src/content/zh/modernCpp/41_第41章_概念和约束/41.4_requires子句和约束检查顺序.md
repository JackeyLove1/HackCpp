# 41.4 requires子句和约束检查顺序

除了使用concept关键字来定义概念，我们还可以使用requires子句直接约束模板实参，例如：

```cpp
template<class T> requires std::isIntegral_v<T> && std::is_signed_v<C> struct X {};
```

上面的代码同样能够限制类模板x的模板实参必须为有符号整型类型，其中requires紧跟的std::isIntegral_v<T>& std::is_signed_v<C>必须是一个类型为bool的常量表达式。 requires子句对于该常量表达式还有一些额外的要求。

1. 是一个初等表达式或带括号的任意表达式。例如：

```javascript
constexpr bool bar() { return true; } template <class T> requires bar() struct X {};
```

由于这里的bar()不是初等表达式，不符合语法规则，因此编译失败，需要修改为：

```txt
constexpr bool bar() { return true; } template <class T> requires (bar()) struct X {};
```

2. 使用&&或者||运算符链接上述表达式：

```javascript
constexpr bool bar() { return true; } template <class T> requires (bar()) && true || false struct X {};
```

requires子句除了能出现在模板形参列表尾部，还可以出现在函数模板声明尾部，所以下面的用法都是正确的：

```cpp
template<class T> requires std::is_integral_v<T>
void foo();
template<class T>
void foo() requires std::is_integral_v<T>;
```

约束模板实参的方法很多，那么现在就有一个问题摆在我们面前——当一个模板同时具备多种约束时，如何确定优先级，例如：

```cpp
template<class C> concept ConstType = std::is_const_v<C>;  
template<class C> conceptIntegralType = std::isIntegral_v<C>;  
template<class T> requires std::is_pointer_v<T> void foo(IntegralType auto) requires std::is SAME_v<T, char* const> {}
```

上面的代码分别使用概念ConstType、模板形参列表尾部requires std:: is_pointer_v <T>和函数模板声明尾部requires std::is_integral_v<T>来约束模板实参，还使用概念IntegralType约束了auto占位符类型的函数形参。对于函数模板调用：

```txt
foo<int>(1.5);
```

编译器究竟应该用什么顺序检查约束条件呢？事实上，标准文档给出了明确的答案，编译器应该按照以下顺序检查各个约束条件。

1. 模板形参列表中的形参的约束表达式，其中检查顺序就是形参出现的顺序。也就是说使用concept定义的概念约束的形参会被优先检查，放到刚刚的例子中foo<int>(); 最先不符合的是ConstType的约束表达式std::is_const_v<C>。  
2. 模板形参列表之后的requires子句中的约束表达式。这意味着，如果foo的模板实参通过了前一个约束检查后将会面临std::is_pointer_v<T>的检查。

3. 简写函数模板声明中每个拥有受约束auto占位符类型的形参所引入的约束表达式。还是放到例子中看，如果前两个约束条件已经满足，编译器则会检查函数实参是否满足IntegralType的约束。  
4. 函数模板声明尾部requires子句中的约束表达式。所以例子中最后检查的是std::is_same_v<T, char * const>。

为了更好地理解约束的检查顺序，让我们来分别编译以下5句代码，看一看编译器输出日志（以GCC为例）：

```txt
foo<int>(1.5);  
foo<const int>(1.5);  
foo<int * const>(1.5);  
foo<int * const>(1);  
foo<char * const>(1);
```

对于foo<int>(1.5);，不满足所有约束条件，编译器报错提示不满足ConstType<T>的约束。

对于foo<const int>(1.5);，满足ConstType<T>，但是不满足其他条件，编译器报错提示不满足std::is_pointer_v<T>的约束。

对于foo<int * const>(1.5);，满足前两个条件，但是不满足其他条件，编译器报错提示不满足IntegralType<auto>的约束。

对于foo<int * const>(1);，满足前3个条件，但是不满足其他条件，编译器报错提示不满足std::is_same_v<T, char * const>的约束。

foo<char * const>(1);满足所有条件，编译成功。

