# 41.5 原子约束

现在让我们回头看一看什么是原子约束。原子约束是表达式和表达式中模板形参到模板实参映射的组合（简称为形参映射）。比较两个原子约束是否相同的方法很特殊，除了比较代码上是否有相同的表现，还需要比较形参映射是否相同，也就是说功能上相同的原子约束可能是不同的原子约束，例如：

```txt
template <int N> constexpr bool Atomic = true;
template <int N> concept C = Atomic<N};
template <int N> concept Add1 = C<N + 1};
template <int N> concept AddOne = C<N + 1};
template <int M> void f()
requires Add1<2 * M> {};
template <int M> void f()
requires AddOne<2 * M> && true {};
f<0>(); // 编译成功
```

在上面的代码中，虽然概念Add1和AddOne使用了不同的名称，但是实际上是相同的，因为在这两个函数中概念C的原子约束都是Atomic<N>，其形参映射都为N～2 * M + 1。在两个函数都符合约束的情况下，编译器会选择约束更为复杂的requires AddOne<2 *

M> && true作为目标函数，因为AddOne<2 * M> && true包含了AddOne<2 * M>。接下来让我们把形参映射改变一下：

```cpp
template <int N> void f2()
requires Add1 <2 * N > {}
template <int N> void f2()
requires Add1 <N * 2 > && true {}
f2 <0>(); // 编译失败
```

上面的代码无法通过编译，虽然都是用了概念Add1，但是它们的形参映射不同，分别为  $2 \times N + 1$  和  $N \times 2 + 1$ ，所以Add1<N × 2> && true并不能包含Add1 <2 * N>，而对于f2<0>();而言，两个f2函数模板都满足约束，这里的二义性让编译器不知所措，导致编译失败。当然，如果将requires Add1<N × 2> && true中的true改为false，就不会产生二义性，可以顺利地通过编译。

当约束表达式中存在原子约束时，如果约束表达式结果相同，则约束表达式应该是相同的，否则会导致编译失败，例如：

```cpp
template<class T> concept sad = false;
template<class T> int f1(T) requires (!sad<T>) { return 1; };
template<class T> int f1(T) requires (!sad<T>) && true {return 2;};
f1(0); // 编译失败
```

需要注意的是，逻辑否定表达式是一个原子约束。所以以上代码会产生二义性，原子约束表达式!sad<T>并不来自相同的约束表达式。为了让代码能成功编译，需要修改代码为：

```cpp
template<class T> concept not_sad = !sad<T>;  
template<class T> int f2(T) requires (not_sad<T>) { return 3; };  
template<class T> int f2(T) requires (not_sad<T>) && true { return 4; };  
f2(0);
```

这样一来，原子约束表达式!sad<T>都来自概念not_sad。另外，因为(not_sad<T>) && true包含了not_sad<T>，所以编译器选取约束表达式为requires (not_sad<T>) && true的函数模板进行编译，最终函数返回4。再进一步：

```c
template<class T> int f3(T) requires (not_sad<T> == true) {
return 5;};
template<class T> int f3(T) requires (not_sad<T> == true) && true
{ return 6; };
f3(0);
template<class T> concept not_sad_is_true = !sad<T> == true;
template<class T> int f4(T) requires (not_sad_is_true<T>) {
return 7;};
template<class T> int f4(T) requires (not_sad_is_true<T>) && true
{ return 8; };
f4(0);
```

同样的理由，f3(0)；会因为二义性无法通过编译，而f4(0)可以编译成功并最后返回8。

