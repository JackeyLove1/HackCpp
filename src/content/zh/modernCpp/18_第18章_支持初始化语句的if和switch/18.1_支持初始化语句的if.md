# 18.1 支持初始化语句的if

在C++17标准中，if控制结构可以在执行条件语句之前先执行一个初始化语句。语法如下：

```txt
if (init; condition) {}
```

其中init是初始化语句，condition是条件语句，它们之间使用分号分隔。允许初始化语句的if结构让以下代码成为可能：

```cpp
include<iostream>   
bool foo()   
{ return true;   
} int main() { if (bool b = foo(); b) { std::cout << std::boolalpha << "good! foo()=" << b << std::endl; }   
}
```

在上面的代码中，bool b = foo() 是一个初始化语句，在初始化语句中声明的变量b能够在if的作用域继续使用。事实上，该变量的生命周期会一直伴随整个if结构，包括else if和else部分。

if初始化语句中声明的变量拥有和整个if结构一样长的声明周期，所以前面的代码可以等价于：

```cpp
include<iostream>   
bool foo()   
{ return true;   
}   
int main()   
{ bool b  $=$  foo(); if (b){ std::cout << std::boolalpha << "good! foo("  $= "$  << b << std::endl; 1
```

当然，我们还可以在if结构中添加else部分：

```cpp
if (bool b = foo(); b) {
    std::cout << std::boolalpha << "good! foo()=" << b << std::endl;
}
else {
    std::cout << std::boolalpha << "bad! foo()=" << b << std::endl;
}
```

在if结构中引入elseif后，情况会稍微变得复杂一点，因为在elseif条件语句之前也可以使用初始化语句：

```cpp
include<iostream> bool foo(){ return false;   
} bool bar{ return true;
```

```cpp
int main()   
{ if (bool b  $=$  foo();b){ std::cout<<std::boolalpha<<"foo("  $\equiv$  "<<b<<std::endl; } else if (bool b1  $=$  bar();b1）{ std::cout<<std::boolalpha <<"foo("  $\equiv$  "<<b <<",bar  $(= ) = "$  <b1<<std::endl; 1
```

在上面的代码中，if和elseif都有初始化语句，它们分别初始化变量b和b1并且在各自条件成立的作用域内执行了日志输出。值得注意的是，b和b1的生命周期并不相同。其中变量b的生命周期会贯穿整个if结构（包括elseif），可以看到在elseif中也能引用变量b。但是b1则不同，它的生命周期只存在于elseif以及后续存在的elseif和elseif语句，而无法在之前的if中使用，等价于：

```cpp
{ bool b  $=$  foo(); if (b){ std::cout << std::boolalpha << "foo("  $\equiv$  "<< b << std::endl; } else { bool b1  $=$  bar(); if (b1){ std::cout << std::boolalpha << "foo("  $\equiv$  "<< b << ",bar("  $\equiv$  "<< b1 << std::endl; } 1
```

因为if初始化语句声明的变量会贯穿整个if结构，所以我们可以利用该特性对整个if结构加锁，例如：

```cpp
include <tex>   
std::tex mx;   
bool shared_flag  $=$  true;   
int main() { if (std::lock_guard<std::tex> lock(mx);shared_flag){ shared_flag  $\equiv$  false; 1
```

继续扩展思路，从本质上来说初始化语句就是在执行条件判断之前先执行了一个语句，并且语句中声明的变量将拥有与if结构相同的生命周期。所以我们在代码中没有必要一定在初始化语句中初始化判断条件的变量，如if(std::lock_guard <std::_mutex> lock(mx); shared_flag)，初始化语句并没有初始化条件判断的变量shared_flag。类似的例子还有：

```cpp
include <stdio>   
#include <string>   
int main()   
{ std::string str; if(charbuf[10]{0};std::fgets(buf,10，stdin)){ str  $+ =$  buf; }   
}
```

在上面的代码中，if的初始化语句只声明了一个数组buf并将buf作为实参传入std::fgets函数，而真正做条件判断的是std::fgets函数返回值。

