# 17.4 临时范围表达式的陷阱

读者是否注意到了，无论是C++11还是C++17标准，基于范围的for循环伪代码都是由以下这句代码开始的：

```txt
auto && __range = range_expression;
```

理解了右值引用的读者应该敏锐地发现了这里存在的陷阱auto&&。对于这个赋值表达式来说，如果range_expression是一个纯右值，那么右值引用会扩展其生命周期，保证其整个for循环过程中

访问的安全性。但如果range_expression是一个泛左值，那结果可就不确定了，参考以下代码：

```cpp
class T {
    std::vector<int> data;
public:
        std::vector<int>& items() { return data; }
};  
T foo()
{
    T t;
    return t;
}  
for (auto& x : foo().items()) {} // 未定义行为
```

请注意，这里的for循环会引发一个未定义的行为，因为foo().items()返回的是一个泛左值类型std::vector<int>&，于是右值引用无法扩展其生命周期，导致for循环访问无效对象并造成未定义行为。对于这种情况请读者务必小心谨慎，将数据复制出来是一种解决方法：

```typescript
T thing = foo();  
for (auto & x : thing.items()) {}
```

在C++20标准中，基于范围的for循环增加了对初始化语句的支持，所以在C++20的环境下我们可以将上面的代码简化为：

```javascript
for (T thing = foo(); auto & x : thing.items()) {}
```

