# 17.5 实现一个支持基于范围的for循环的类

前面用大量篇幅介绍了使用基于范围的for循环遍历数组和标准容器的方法，实际上我们还可以让自定义类型支持基于范围的for循环。要完成这样的类型必须先实现一个类似标准库中的迭代器。

1. 该类型必须有一组和其类型相关的begin和end函数，它们可以是类型的成员函数，也可以是独立函数。  
2. begin和end函数需要返回一组类似迭代器的对象，并且这组对象必须支持operator *、operator !=和operator ++运算符函数。

请注意，这里的operator ++应该是一个前缀版本，它需要通过声明一个不带形参的operator ++运算符函数来完成。下面是一个完整的例子：

```cpp
include<iostream>   
class IntIter{ public: IntIter(int \*p) : p_(p) {} bool operator!=(const IntIter& other) { return (p_ != other.p_); } const IntIter& operator++() { p_  $^{+ + }$  . return \*this; } int operator\* () const { return \*p_;   
} private:
```

```cpp
int \*p_;   
};   
template<unsigned int fix_size>   
class FixIntVector{   
public: FixIntVector(std::initializer_list<int> init_list) { int \*cur  $=$  data_; for (auto e : init_list){ \*cur  $=$  e; cur++; }   
}   
IntIter begin() { return IntIter(data_); }   
IntIter end() { return IntIter(data_ + fix_size);   
}   
private: int data_[fix_size]{0};   
}；   
int main() { FixIntVector<10> fix_int_vector{1,3,5,7,9}; for (auto e : fix_int_vector) { std::cout << e << std::endl; }
```

在上面的代码中，FixIntVector是存储int类型数组的类模板，类IntIter是FixIntVector的迭代器。在FixIntVector中实现了成员函数begin和end，它们返回了一组迭代器，分别表示数组的开始和结束位置。类IntIter本身实现了operator *、operator !=和operator ++运算符函数，其中operator *用于

编译器生成解引用代码，operator !=用于生成循环条件代码，而前缀版本的operator ++用于更新迭代器。

请注意，这里使用成员函数的方式实现了begin和end，但有时候需要遍历的容器可能是第三方提供的代码。这种情况下我们可以实现一组独立版本的begin和end函数，这样做的优点是能在不修改第三方代码的情况下支持基于范围的for循环。

