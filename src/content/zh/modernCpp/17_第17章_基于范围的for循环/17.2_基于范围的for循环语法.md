# 17.2 基于范围的for循环语法

C++11标准引入了基于范围的for循环特性，该特性隐藏了迭代器的初始化和更新过程，让程序员只需要关心遍历对象本身，其语法也比传统for循环简洁很多：

```txt
for ( range.Declaration : range_expression ) loop_statement
```

基于范围的for循环不需要初始化语句、条件表达式以及更新表达式，取而代之的是一个范围声明和一个范围表达式。其中范围声明是一个变量的声明，其类型是范围表达式中元素的类型或者元素类型的引用。而范围表达式可以是数组或对象，对象必须满足以下2个条件中的任意一个。

1. 对象类型定义了begin和end成员函数。

2. 定义了以对象类型为参数的begin和end普通函数。

```cpp
include<iostream>   
#include <string>   
#include <map>   
std::map<int, std::string> index_map{ {1, "hello"},{2, "world"},{3，"！"}}；   
int int_array[]  $=$  {0，1，2，3，4，5}；   
int main()   
{ for(const auto &e : index map){ std::cout<< "key=" << e.first << ",value=" << e(second << std::endl; } for (auto e : int_array){ std::cout<< e << std::endl; 1
```

以上代码通过基于范围的for循环遍历数组和标准库的map对象。其中const auto &e和auto e是范围声明，而index_map和int_array是范围表达式。为了让范围声明更加简洁，推荐使用auto占位符。当然，这里使用std::map<int, std::string>::value_type和int来替换auto也是可以的。值得注意的是，代码使用了两种形式的范围声明，前者是容器或者数组中元素的引用，而后者是容器或者数组中元素的值。一般来说，我们希望对于复杂的对象使用引用，而对于基础类型使用值，因为这样能够减少内存的复制。如果不会在循环过程中修改引用对象，那么推荐在范围声明中加上const限定符以帮助编译器生成更加高效的代码：

```txt
include <vector>   
struct X   
{
```

```cpp
X() { std::cout << "default ctor" << std::endl; } X(const X& other) { std::cout << "copy ctor" << std::endl; } ;   
int main() { std::vector<X> x(10); std::cout << "for (auto n : x)" << std::endl; for (auto n : x) { } std::cout << "for (const auto &n : x)" << std::endl; for (const auto &n : x) { }
```

编译运行上面这段代码会发现for( auto n : x)的循环调用10次复制构造函数，如果类x的数据量比较大且容器里的元素很多，那么这种复制的代价是无法接受的。而for(const auto &n : x)则解决了这个问题，整个循环过程没有任何的数据复制。

