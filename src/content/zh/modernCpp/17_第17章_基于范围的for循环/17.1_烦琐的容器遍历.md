# 17.1 烦琐的容器遍历

通常遍历一个容器里的所有元素会用到for循环和迭代器，在大多数情况下我们并不关心迭代器本身，而且在循环中使用迭代器的模式往往十分固定——获取开始的迭代器、不断更新当前迭代器、将当前迭代器与结束的迭代器作比较以及解引用当前迭代器获取我们真正关心的元素：

```cpp
std::map<int, std::string> index_map{ {1, "hello"},{2, "world"},{3，"！"}}；   
std::map<int, std::string>：:iterator it  $=$  index_map.begin(); for(；it  $! =$  index_map.end(); ++it）{ std::cout<< "key=" << (*it).first<<"，value="<< (*it).second << std::endl;   
}
```

从上面的代码可以看到，为了输出index_map中的内容不得不编写很多关于迭代器的代码，但迭代器本身并不是业务逻辑所关心的部分。对于这个问题的一个可行的解决方案是使用标准库提供的std::for_each函数，使用该函数只需要提供容器开始和结束的迭代器以及执行函数或者仿函数即可，例如：

```cpp
std::map<int, std::string> index_map{ {1, "hello"}, {2, "world"}, {3, !} };
```

```cpp
void print(std::map<int, std::string>::const_reference e) { std::cout << "key=" << e.first << ", value=" << e(second << std::endl; } std::for_each(index_map.begin(), index_map.end(), print);
```

相对于上一段代码，这段代码使用std::for_each遍历容器比直接使用迭代器的方法要简洁许多。实际上单纯的迭代器遍历操作完全可以交给编译器来完成，这样能让程序员专注于业务代码而非迭代器的循环。

