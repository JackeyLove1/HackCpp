# 21.1 使用noexcept代替throw

异常处理是C++语言的重要特性，在C++11标准之前，我们可以使用throw (optional_type_list)声明函数是否抛出异常，并描述函数抛出的异常类型。理论上，运行时必须检查函数发出的任何异常是否确实存在于optional_type_list中，或者是否从该列表中的某个类型派生。如果不是，则会调用处理程序

std::unexpected。但实际上，由于这个检查实现比较复杂，因此并不是所有编译器都会遵从这个规范。此外，大多数程序员似乎并不喜欢throw(optional_type_list)这种声明抛出异常的方式，因为在他们看来抛出异常的类型并不是他们关心的事情，他们只需要关心函数是否会抛出异常，即是否使用了throw()来声明函数。

使用throw声明函数是否抛出异常一直没有什么问题，直到 $\mathrm{C} + + 11$  标准引入了移动构造函数。移动构造函数中包含着一个严重的异常陷阱。

当我们想将一个容器的元素移动到另外一个新的容器中时。在  $\mathrm{C}++11$  之前，由于没有移动语义，我们只能将原始容器的数据复制到

新容器中。如果在数据复制的过程中复制构造函数发生了异常，那么我们可以丢弃新的容器，保留原始的容器。在这个环境中，原始容器的内容不会有任何变化。

但是有了移动语义，原始容器的数据会逐一地移动到新容器中，如果数据移动的途中发生异常，那么原始容器也将无法继续使用，因为已经有一部分数据移动到新的容器中。这里读者可能会有疑问，如果发生异常就做一个反向移动操作，恢复原始容器的内容不就可以了吗？实际上，这样做并不可靠，因为我们无法保证恢复的过程中不会抛出异常。

这里的问题是，throw并不能根据容器中移动的元素是否会抛出异常来确定移动构造函数是否允许抛出异常。针对这样的问题，C++标准委员会提出了noexcept说明符。

noexcept 是一个与异常相关的关键字，它既是一个说明符，也是一个运算符。作为说明符，它能够用来说明函数是否会抛出异常，例如：

```txt
struct X {
    int f() const noexcept {
        return 58;
    }
    void g() noexcept {};
} ;
int foo() noexcept {
    return 42;
}
```

以上代码非常简单，用noexcept声明了函数foo以及x的成员函数f和g。指示编译器这几个函数是不会抛出异常的，编译器可以根据声明优化代码。请注意，noexcept只是告诉编译器不会抛出异常，但函数不一定真的不会抛出异常。这相当于对编译器的一种承诺，当我们在声明了noexcept的函数中抛出异常时，程序会调用std::terminate去结束程序的生命周期。

另外，noexcept还能接受一个返回布尔的常量表达式，当表达式评估为true的时候，其行为和不带参数一样，表示函数不会抛出异常。反之，当表达式评估为false的时候，则表示该函数有可能会抛出异常。这个特性广泛应用于模板当中，例如：

```txt
template<class T> T copy(const T& o) noexcept {
    ...
}
```

以上代码想实现一个复制函数，并且希望使用noexcept优化不抛出异常时的代码。但问题是如果T是一个复杂类型，那么调用其复制构造函数是有可能发生异常的。直接声明noexcept会导致当函数遇到异常的时候程序被终止，而不给我们处理异常的机会。我们希望只有在T是一个基础类型时复制函数才会被声明为noexcept，因为基础类型的复制是不会发生异常的。这时就需要用到带参数的noexcept了：

```cpp
template<class T> T copy(const T&o) noexcept(std::is_fundamental<T>::value) {
```

```txt
…
```

上面这段代码通过std::is_fundamental来判断T是否为基础类型，如果T是基础类型，则复制函数被声明为noexcept(true)，即不会抛出异常。反之，函数被声明为noexcept(false)，表示函数有可能抛出异常。请注意，由于noexcept对表达式的评估是在编译阶段执行的，因此表达式必须是一个常量表达式。

实际上，这段代码并不是最好的解决方案，因为我还希望在类型T的复制构造函数保证不抛出异常的情况下都使用noexcept声明。基于这点考虑，C++标准委员会又赋予了noexcept作为运算符的特性。noexcept运算符接受表达式参数并返回true或false。因为该过程是在编译阶段进行，所以表达式本身并不会被执行。而表达式的结果取决于编译器是否在表达式中找到潜在异常：

```cpp
include<iostream>   
int foo() noexcept   
{ return 42;   
}   
int fool() { return 42;   
}   
int foo2() throw() { return 42;   
}   
int main() { std::cout << std::boolalpha; std::cout << "noexcept(foo()) = " << noexcept.foo()) <<
```

```cpp
std::endl;
    std::cout << "noexcept(foo1()) = " << noexcept(foo1()) << 
std::endl;
    std::cout << "noexcept(foo2()) = " << noexcept(foo2()) << 
std::endl;
}
```

上面这段代码的运行结果如下:

```julia
noexcept(foo()) = true  
noexcept(foo1()) = false  
noexcept(foo2()) = true
```

noexcept运算符能够准确地判断函数是否有声明不会抛出异常。有了这个工具，我们可以进一步优化复制函数模板：

```txt
template<class T> 
T copy(const T&o) noexcept(noexcept(T(o)) { ... }
```

这段代码看起来有些奇怪，因为函数声明中连续出现了两个noexcept关键字，只不过两个关键字发挥了不同的作用。其中第二个关键字是运算符，它判断T(o)是否有可能抛出异常。而第一个noexcept关键字则是说明符，它接受第二个运算符的返回值，以此决定T类型的复制函数是否声明为不抛出异常。

