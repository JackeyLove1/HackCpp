# 21.4 默认使用noexcept的函数

C++11标准规定下面几种函数会默认带有noexcept声明。

1. 默认构造函数、默认复制构造函数、默认赋值函数、默认移动构造函数和默认移动赋值函数。有一个额外要求，对应的函数在类型的基类和成员中也具有noexcept声明，否则其对应函数将不再默认带有noexcept声明。另外，自定义实现的函数默认也不会带有noexcept声明：

```cpp
include<iostream>   
struct X{ }； #define PRINT_NOEXCEPT(x) \ std::cout<<#x<<"  $=$  "<<x<<std::endl int main() { Xx; std::cout<<std::boolalpha; PRINT_NOEXCEPT(noexcept(X()）); PRINT_NOEXCEPT(noexcept(X(x))）; PRINT_NOEXCEPT(noexcept(X(std::move(x)))）; PRINT_NOEXCEPT(noexcept(x operator=(x))）; PRINT_NOEXCEPT(noexcept(x.operaor=(std::move(x))))； 1
```

以上代码的运行输出结果如下:

```julia
noexcept(X()) = true  
noexcept(X(x)) = true  
noexcept(X(std::move(x))) = true  
noexcept(x operator=(x)) = true  
noexcept(x operator=(std::move(x))) = true
```

可以看到编译器默认实现的这些函数都是带有noexcept声明的。如果我们在类型x中加入某个成员变量M，情况会根据M的具体实现发生变化：

```c
include<iostream>   
struct M{ M（）{} M(constM&）{} M(M&&)noexcept{} Moperator  $\equiv$  (constM)&noexcept{return\*this;} M operator= (M&&){return\*this;} }；   
struct X{ Mm; }；   
#define PRINT_NOEXCEPT(x）\ std::cout<<#x<<"  $=$  "<<x<<std::endl   
int main() { Xx; std::cout<<std::boolalpha; PRINT_NOEXCEPT(noexcept(X())); PRINT_NOEXCEPT(noexcept(X(x))）; PRINT_NOEXCEPT(noexcept(X(std::move(x))))； PRINT_NOEXCEPT(noexcept(x_operator=(x))）; PRINT_NOEXCEPT(noexcept(x/operator=(std::move(x)))）; 1
```

# 这时的结果如下:

```julia
noexcept(X()) = false  
noexcept(X(x)) = false  
noexcept(X(std::move(x))) = true  
noexcept(x operator=(x)) = true  
noexcept(x operator=(std::move(x))) = false
```

以上代码表明如果成员m的类型M自定义实现了默认函数，并且部分函数没有声明为noexcept，那么x对应的默认函数也会丢失noexcept声明。比如M(){}没有使用noexcept声明，导致noexcept(X())返回false，而M(M&&) noexcept{}使用了noexcept声明，则noexcept(x operator=(x))返回true。

2. 类型的析构函数以及delete运算符默认带有noexcept声明，请注意即使自定义实现的析构函数也会默认带有noexcept声明，除非类型本身或者其基类和成员明确使用noexcept(false)声明析构函数，以上也同样适用于delete运算符：

```c
include<iostream>   
struct M{ \~M() noexcept(false){ }；   
struct X{ ；   
struct X1{ \~X1（）{}   
}；   
struct X2{ \~X2（）noexcept(false）{}   
}；   
struct X3{ M m;   
}；   
#define PRINT_NOEXCEPT(x) \   
std::cout<<#x<<"  $=$  "<<x<< std::endl   
int main(） { X\*x  $=$  new X; X1\*x1  $=$  new X1;
```

```cpp
X2  $\star_{\mathrm{x2}} =$  new X2;   
X3  $\star_{\mathrm{x3}} =$  new X3;   
std::cout << std::boolalpha;   
PRINT_NOEXCEPT(noexcept(x->~X()));   
PRINT_NOEXCEPT(noexcept(x1->~X1())));   
PRINT_NOEXCEPT(noexcept(x2->~X2())));   
PRINT_NOEXCEPT(noexcept(x3->~X3())));   
PRINT_NOEXCEPT(noexcept(delete x));   
PRINT_NOEXCEPT(noexcept(delete x1));   
PRINT_NOEXCEPT(noexcept(delete x2));   
PRINT_NOEXCEPT(noexcept(delete x3));
```

以上代码的运行输出结果如下:

```txt
noexcept(x->X()) = true  
noexcept(x1->X1()) = true  
noexcept(x2->X2()) = false  
noexcept(x3->X3()) = false  
noexcept(delete x) = true  
noexcept(delete x1) = true  
noexcept(delete x2) = false  
noexcept(delete x3) = false
```

可以看出noexcept运算符对于析构函数和delete运算符有着同样的结果。自定义析构函数~X1()依然会带有noexcept的声明，除非如同~X2()显示的声明noexcept(false)。X3有一个成员变量m，其类型M的析构函数被声明为noexcept(false)，这使X3的析构函数也被声明为noexcept(false)。

