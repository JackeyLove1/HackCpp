# 21.2 用noexcept来解决移动构造问题

上文曾提到过，异常的存在对容器数据的移动构成了威胁，因为我们无法保证在移动构造的时候不抛出异常。现在noexcept运算符可以判断目标类型的移动构造函数是否有可能抛出异常。如果没有抛

出异常的可能，那么函数可以选择进行移动操作；否则将使用传统的复制操作。

下面，我们就来实现一个使用移动语义的容器经常用到的工具函数 swap:

```cpp
template<class T> void swap(T& a, T& b) noexcept(noexcept(T(std::move(a))) && noexcept(a operator=(std::move(b)))) {
    T tmp(std::move(a));
    a = std::move(b);
    b = std::move(tmp);
}
```

上面这段代码只做了两件事情：第一，检查类型T的移动构造函数和移动赋值函数是否都不会抛出异常；第二，通过移动构造函数和移动赋值函数移动对象a和b。在这个函数中使用noexcept的好处在于，它让编译器可以根据类型移动函数是否抛出异常来选择不同的优化策略。但是这个函数并没有解决上面容器移动的问题。

继续改进swap函数：

```cpp
template<class T> void swap(T& a, T& b) noexcept(noexcept(T(std::move(a))) && noexcept(a operator=(std::move(b)))) {
    static_assert(noexcept(T(std::move(a)))
        && noexcept(a operator=(std::move(b)))) ;
    T tmp(std::move(a));
    a = std::move(b);
    b = std::move(tmp);
}
```

改进版的swap在函数内部使用static_assert对类型T的移动构造函数和移动赋值函数进行检查，如果其中任何一个抛出异常，那么函数会编译失败。使用这种方法可以迫使类型T实现不抛出异常的移动构造函数和移动赋值函数。但是这种实现方式过于强势，我们希望在不满足移动要求的时候，有选择地使用复制方法完成移动操作。

# 最终版swap函数：

```cpp
include<iostream>   
#include <typetraits   
struct X{ X(){} X(X&&) noexcept{} X(constX&）{} X operator  $\equiv$  (X&&)noexcept{return \*this;} X operator  $=$  (constX&）{return \*this;}   
};   
struct X1{ X1(){} X1(X1&&）{} X1(constX1&）{} X1 operator  $\equiv$  (X1&&){return \*this;} X1 operator  $=$  (constX1&）{return \*this;}   
};   
template<typename T>   
void swap Impl(T& a,T& b,std::integral_constant bool true)>   
noexcept   
{ T tmp(std::move(a)); a  $=$  std::move(b); b  $=$  std::move(tmp);   
}   
template<typename T>   
void swap Impl(T& a,T& b,std::integral_constant bool false>)   
{ T tmp(a); a  $=$  b; b  $=$  tmp;
```

```cpp
template<typename T> void swap(T& a, T& b) noexcept(noexcept(swapImpl(a, b, std::integral_constant bool, noexcept(T(std::move(a))) && noexcept(a operator=(std::move(b))>>()))) {
    swapImpl(a, b, std::integral_constant bool, noexcept(T(std::move(a)))
        && noexcept(a operator=(std::move(b))>>(); }
} int main()
{
    X x1, x2;
    swap(x1, x2);
    X1 x3, x4;
    swap(x3, x4);
}
```

以上代码实现了两个版本的swapImpl，它们的形参列表的前两个形参是相同的，只有第三个形参类型不同。第三个形参为std::integral_constant bool, true>的函数会使用移动的方法交换数据，而第三个参数为std::integral_constant bool, false>的函数则会使用复制的方法来交换数据。swap函数会调用swapImpl，并且以移动构造函数和移动赋值函数是否会抛出异常为模板实参来实例化swapImpl的第三个参数。这样，不抛出异常的类型会实例化一个类型为std::integral_constant bool, true>的对象，并调用使用移动方法的swapImpl；反之则调用使用复制方法的swapImpl。

请注意这段代码中，我为了更多地展示noexcept的用法将代码写得有些复杂。实际上noexcept(T(std::move(a))) && noexcept(a operator=(std::move(b))) 这段代码完全可以

使用std::is_nothrow_move_constructible<T>::value&& std::is_nothrow_move_assignable<T>::value来代替。

