# 21.6 将异常规范作为类型的一部分

在C++17标准之前，异常规范没有作为类型系统的一部分，所以下面的代码在编译阶段不会出现问题：

```txt
void(\*fp)(noexcept  $\equiv$  nullptr;   
void foo(){   
int main()   
{ fp  $=$  &foo;
```

在上面的代码中fp是一个指向确保不抛出异常的函数的指针，而函数foo则没有不抛出异常的保证。在C++17之前，它们的类型是相同的，也就是说std::is_same <decltype(fp)，decltype(&foo)>:value返回的结果为true。显然，这种宽松的规则会带来一些问题，例如一个会抛出异常的函数通过一个保证不抛出异常的函数指针进行调用，结果该函数确实抛出了异常，正常流程本应该是由程序捕获异常并进行下一步处理，但是由于函数指针保证不会抛出异常，因此程序直接调用std::terminate函数中止了程序：

```cpp
include<iostream> #include<string> void(\*fp)(noexcept  $\equiv$  nullptr; void foo(){ throw(5); } int main() { fp  $=$  &foo; try{ fp(); 1
```

```cpp
catch (int e)   
{ std::cout << e << std::endl; }
```

以上代码预期中的运行结果应该是输出数字5。但是由于函数指针的使用不当，导致程序意外中止并且只留下了一句：“terminate called after throwing an instance of ‘int’”。

为了解决此类问题，C++17标准将异常规范引入了类型系统。这样一来，fp = &foo就无法通过编译了，因为fp和&foo变成了不同的类型，std::is_same <decltype(fp)，

decltype(&foo)>:::value会返回false。值得注意的是，虽然类型系统引入异常规范导致noexcept声明的函数指针无法接受没有noexcept声明的函数，但是反过来却是被允许的，比如：

```txt
void(\*fp）  $) =$  nullptr;   
void foo(）noexcept{}   
int main()   
{ fp  $=$  &foo;   
}
```

这里的原因很容易理解，一方面这个设定可以保证现有代码的兼容性，旧代码不会因为没有声明noexcept的函数指针而编译报错。另一方面，在语义上也是可以接受的，因为函数指针既没有保证会抛出异常，也没有保证不会抛出异常，所以接受一个保证不会抛出异常的函数也合情合理。同样，虚函数的重写也遵守这个规则，例如：

```txt
class Base { public: virtual void foo() noexcept {} }; class Derived :public Base { public: void foo() override {}; }
```

以上代码无法编译成功，因为派生类试图用没有声明noexcept的虚函数重写基类中声明noexcept的虚函数，这是不允许的。但反过来是可以通过编译的：

```cpp
class Base { public: virtual void foo(){}; class Derived :public Base{ public: void foo() noexcept override{}; }；
```

最后需要注意的是模板带来的兼容性问题，在标准文档中给出了这样一个例子：

```cpp
void g1() noexcept{}   
void g2(){}   
template<class T> void f(T\*，T\*){}   
int main() { f(g1,g2);   
}
```

在  $\mathrm{C} + + 17$  中  $\mathrm{g} 1$  和  $\mathrm{g} 2$  已经是不同类型的函数，编译器无法推导出同一个模板参数，导致编译失败。为了让这段编译成功，需要简单修改一下函数模板：

```txt
template<class T1, class T2> void f(T1 *, T2 *) {}
```

