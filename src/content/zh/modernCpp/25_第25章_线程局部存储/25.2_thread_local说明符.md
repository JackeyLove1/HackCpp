# 25.2 thread_local说明符

thread_local说明符可以用来声明线程生命周期的对象，它能与static或extern结合，分别指定内部或外部链接，不过额外的static并不影响对象的生命周期。换句话说，static并不影响其线程局部存储的属性：

```txt
struct X {
    thread_local static int i;
};
```

```txt
thread_local X a;
int main()
{
    thread_local X b;
}
```

从上面的代码可以看出，声明一个线程局部存储变量相当简单，只需要在普通变量声明上添加thread_local说明符。被 thread_local声明的变量在行为上非常像静态变量，只不过多了线程属性，当然这也是线程局部存储能出现在我们的视野中的一个关键原因，它能够解决全局变量或者静态变量在多线程操作中存在的问题，一个典型的例子就是errno。

errno通常用于存储程序当中上一次发生的错误，早期它是一个静态变量，由于当时大多数程序是单线程的，因此没有任何问题。但是到了多线程时代，这种errno就不能满足需求了。设想一下，一个多线程程序的线程A在某个时刻刚刚调用过一个函数，正准备获取其错误码，也正是这个时刻，另外一个线程B在执行了某个函数后修改了这个错误码，那么线程A接下来获取的错误码自然不会是它真正想要的那个。这种线程间的竞争关系破坏了errno的准确性，导致不可确定的结果。为了规避由此产生的不确定性，POSIX将errno重新定义为线程独立的变量，为了实现这个定义就需要用到线程局部存储，直到C++11之前，errno都是一个静态变量，而从C++11开始errno被修改为一个线程局部存储变量。

在了解了线程局部存储的意义之后，让我们回头仔细阅读其定义，会发现线程局部存储只是定义了对象的生命周期，而没有定义可访问性。也就是说，我们可以获取线程局部存储变量的地址并将其传递给其他线程，并且其他线程可以在其生命周期内自由使用变量。不过这样做除了用于诊断功能以外没有实际意义，而且其危险性过大，一旦没有掌握好目标线程的声明周期，就很可能导致内存访问异常，造成未定义的程序行为，通常情况下是程序崩溃。

值得注意的是，使用取地址运算符&取到的线程局部存储变量的地址是运行时被计算出来的，它不是一个常量，也就是说无法和constexpr结合：

```txt
thread_local int tv;
static int sv;
int main()
{
    constexpr int *sp = &sv; // 编译成功，sv的地址在编译时确定
    constexpr int *tp = &tv; // 编译失败，tv的地址在运行时确定
```

在上面的代码中，由于sv是一个静态变量，因此在编译时可以获取其内存常量地址，并赋值到常量表达式sp。但是tv则不同，它在线程创建时才可能确定内存地址，所以这里会产生编译错误。

最后来说明一下线程局部存储对象的初始化和销毁。在同一个线程中，一个线程局部存储对象只会初始化一次，即使在某个函数中被多次调用。这一点和单线程程序中的静态对象非常相似。相对应的，

对象的销毁也只会发生一次，通常发生在线程退出的时刻。下面来看一个例子：

```cpp
include<iostream>   
#include <string>   
#include <thread>   
#include <_mutex>   
std::mutable g_out_lock;   
struct RefCount{ RefCount(const char\*f)：i(0)，func(f){ std::lock_guard<std::mutable> lock(g_out_lock); std::cout<<std::this_thread::get_id()  $<  <   \text{"} |$  ＿  $<  <   \text{功}$ $<  <   \text{"} :$  ctor i("<<i<<")"<<std::endl; } ~RefCount(){ std::lock_guard<std::mutable> lock(g_out_lock); std::cout<<std::this_thread::get_id()  $<  <   \text{"} |$  ＿  $<  <   \text{功}$ $<  <   \text{"} :$  dtor i("<<i<<")"<<std::endl; } void inc(){ std::lock_guard<std::mutable> lock(g_out_lock); std::cout<<std::this_thread::get_id()  $<  <   \text{"} |$  ＿  $<  <   \text{功}$ $<  <   \text{"} :$  ref count add 1 to i("<<i<<")" << std::endl; i++; int i; std::string func; }; RefCount \*lp_ptr = nullptr;   
void foo(const char\*f) { std::string func(f); thread_local RefCount tv func.append("\#foo").c_str()); tv.inc();   
void bar(const char\*f)
```

```cpp
{ std::string func(f); thread_local RefCount tv(func.append "#bar").c_str()); tv.inc();   
}   
void threadfunc1() { const char\* func  $=$  "threadfunc1"; foo(func); foo(func); foo(func); }   
void threadfunc2() { const char\* func  $=$  "threadfunc2"; foo(func); foo(func); foo(func);   
}   
void threadfunc3() { const char\* func  $=$  "threadfunc3"; foo(func); bar(func); bar(func);   
}   
int main() { std::thread t1(threadfunc1); std::thread t2(threadfunc2); std::thread t3(threadfunc3); t1.join(); t2.join(); t3.join();   
}
```

上面的代码并发3个工作线程，前两个线程threadfunc1和threadfunc2分别调用了3次foo函数。而第三个线程threadfunc3调用了1次foo函数和2次bar函数。其中foo和bar函数的功能相似，它们分别声明并初始化了一个线程局部存储对象tv，并调用其自增函

数inc，而inc函数会递增对象成员变量i。为了保证输出的日志不会受到线程竞争的干扰，在输出之前加了互斥锁。下面是在Windows上的运行结果：

```txt
27300|threadfunc1#foo : ctor i(0)  
27300|threadfunc1#foo : ref count add 1 to i(0)  
27300|threadfunc1#foo : ref count add 1 to i(1)  
27300|threadfunc1#foo : ref count add 1 to i(2)  
25308|threadfunc3#foo : ctor i(0)  
25308|threadfunc3#foo : ref count add 1 to i(0)  
25308|threadfunc3#bar : ctor i(0)  
25308|threadfunc3#bar : ref count add 1 to i(0)  
25308|threadfunc3#bar : ref count add 1 to i(1)  
10272|threadfunc2#foo : ctor i(0)  
10272|threadfunc2#foo : ref count add 1 to i(0)  
10272|threadfunc2#foo : ref count add 1 to i(1)  
10272|threadfunc2#foo : ref count add 1 to i(2)  
27300|threadfunc1#foo : dtor i(3)  
25308|threadfunc3#bar : dtor i(2)  
25308|threadfunc3#foo : dtor i(1)  
10272|threadfunc2#foo : dtor i(3)
```

从结果可以看出，线程threadfunc1和threadfunc2分别只调用了一次构造和析构函数，而且引用计数的递增也不会互相干扰，也就是说两个线程中线程局部存储对象是独立存在的。对于线程threadfunc3，它进行了两次线程局部存储对象的构造和析构，这两次分别对应foo和bar函数里的线程局部存储对象tv。可以发现，虽然这两个对象具有相同的对象名，但是由于不在同一个函数中，因此也应该认为是相同线程中不同的线程局部存储对象，它们的引用计数的递增同样不会相互干扰。

