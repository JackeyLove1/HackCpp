# 30.4 使用alignas说明符

接下来看一看alignas说明符的用法，该说明符可以接受类型或者常量表达式。特别需要注意的是，该常量表达式计算的结果必须是一个2的幂值，否则是无法通过编译的。具体用法如下（这里采用GCC编译器，因为其alignof可以查看变量的对齐字节长度）：

```txt
include<iostream> struct X char a1;
```

```cpp
int a2; double a3;   
}；   
struct X1 { alignas(16) char a1; alignas(double) int a2; double a3; }；   
struct alignas(16) X2 { char a1; int a2; double a3; }；   
struct alignas(16) X3 { alignas(8) char a1; alignas(double) int a2; double a3; }；   
struct alignas(4) X4 { alignas(8) char a1; alignas(double) int a2; double a3; }；   
#define COUT ALIGN(s) std::cout << "alignof(" #s ") = " << alignof(s) << std::endl   
int main() { X x; X1 x1; X2 x2; X3 x3; X4 x4; alignas(4) X3 x5; alignas(16) X4 x6; COUT ALIGN(x); COUT ALIGN(x1); COUT ALIGN(x2); COUT ALIGN(x3); COUT ALIGN(x4);
```

```txt
COUT ALIGN (x5);  
COUT ALIGN (x6);  
COUT ALIGN (x5.a1);  
COUT ALIGN (x6.a1);  
}
```

输出结果如下:

```txt
alignof(x) = 8
alignof(x1) = 16
alignof(x2) = 16
alignof(x3) = 16
alignof(x4) = 8
alignof(x5) = 4
alignof(x6) = 16
alignof(x5.a1) = 8
alignof(x6.a1) = 8
```

从上面的代码可以看出，alignas的使用非常灵活，例子中它既可以用于结构体，也可以用于结构体的成员变量。如果将alignas用于结构体类型，那么该结构体整体就会以alignas声明的对齐字节长度进行对齐，比如在例子中，x的类型对齐字节长度为8字节，而x2在使用了alignas(16)之后，对齐字节长度修改为了16字节。另外，如果修改结构体成员的对齐字节长度，那么结构体本身的对齐字节长度也会发生变化，因为结构体类型的对齐字节长度总是需要大于或者等于其成员变量类型的对齐字节长度。比如x1的成员变量a1类型的对齐字节长度修改为了16字节，所有x1类型也被修改为16字节对齐。同样的规则也适用于结构体x3，x3类型的对齐字节长度被指定为16字节，虽然其成员变量a1的类型对齐字节长度被指定为8字节，但是并不能改变x3类型的对齐字节长度。x4就恰恰相反，由于x4指定的对齐字节长度为4字节，明显小于其成员变量类型需要的对齐字节长度的

字节数，因此这里x4的alignas(4)会被忽略。最后要说明的是，结构体类型的对齐字节长度，并不能影响声明变量时变量的对齐字节长度，比如x5、x6。不过在变量声明时指定对齐字节长度，也不影响变量内部成员变量类型的对齐字节长度，比如x5.a1、x6.a1。上面的代码用结构体作为例子，实际上对于类也是一样的。

