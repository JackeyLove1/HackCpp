# 30.3 使用 alignof 运算符

alignof运算符和我们前面提到的编译器扩展关键字 __alignof、__alignof__用法相同，都是获得类型的对齐字节长度，比如：

```txt
auto x1 = alignof(int);  
auto x2 = alignof(void(*))();
```

```txt
int a = 0;  
auto x3 = alignof(a); //  $*C++$  标准不支持这种用法
```

请注意上面的第4句代码，alignof的计算对象并不是一个类型，而是一个变量。但是C++标准规定alignof必须是针对类型的。不过GCC扩展了这条规则，alignof除了能接受一个类型外还能接受一个变量，用GCC编译此段代码是可以编译通过的。阅读了第4章的读者可能会想到，我们只需要结合decltype，就能够扩展出类似这样的功能：

```txt
int a = 0;  
auto x3 = alignof(decltype(a));
```

但实际情况是，这种做法只有在类型使用默认对齐的时候才是正确的，如果用在下面的情况中会产生错误的结果：

```txt
alignas(8) int a = 0;
auto x3 = alignof(decltype(a)); // 错误的返回4，而并非设置的8
```

使用MSVC的读者如果想获得变量的对齐，不妨使用编译器的扩展关键字 __alignof:

```txt
alignas(8) int a = 0;
auto x3 = __alignof(a); // 返回8
```

另外，我们还可以通过alignof获得类型std::max_align_t的对齐字节长度，这是一个非常重要的值。C++11定义了

std::max_align_t，它是一个平凡的标准布局类型，其对齐字节长度要求至少与每个标量类型一样严格。也就是说，所有的标量类型

都适应std::max_align_t的对齐字节长度。C++标准还规定，诸如 new和malloc之类的分配函数返回的指针需要适合于任何对象，也就是说内存地址至少与std::max_align_t严格对齐。由于C++标准并没有定义std::max_align_t对齐字节长度具体是什么样的，因此不同的平台会有不同的值，通常情况下是8字节和16字节。下面做一个小实验来验证一下刚刚的说法：

```cpp
for (int i = 0; i < 100; i++) { auto *p = new char(); auto addr = reinterpret_cast<std::uintptr_t>(p); std::cout << addr % alignof(std::max_align_t) << std::endl; delete p; }
```

编译运行以上代码，会发现输出的都是0，也就是说即使我们分配的是1字节的内存，内存分配器也会将指针定位到与

std::max_align_t对齐的地方。如果我们有自定义内存分配器的需要，请务必考虑到这个细节。

