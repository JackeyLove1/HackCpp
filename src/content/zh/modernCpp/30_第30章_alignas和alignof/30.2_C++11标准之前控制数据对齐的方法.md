# 30.2 C++11标准之前控制数据对齐的方法

在C++11标准之前我们没有一个标准方法来设定数据的对齐字节长度，只能依靠一些编程技巧和各种编译器自身提供的扩展功能来达到这一目的。

首先让我们来看一看如何获得类型的对齐字节长度。在 alignof 运算符被引入之前，程序员常用 offsetof 来间接实现 alignof 的功能，其中一种实现方法如下：

```txt
define ALIGNOF(type, result) \ struct type##_alignof_trick{ char c; type member; }; \ result = offsetof(type##_alignof_trick, member) int x1 = 0; ALIGNOF(int, x1);
```

以上代码用宏定义了一个结构体，其中用type定义了成员变量 member，然后用OFFSET获取member的偏移量，从而获取指定类型的对齐字节长度。该方法运用在大部分类型上没有问题，不过还是有些例外，比如函数指针类型：

```c
int x1 = 0;  
ALIGNOF(void(*)(x1); //无法编译通过
```

当然了，我们可以用 typedef来解决这个问题：

```c
int x1 = 0;  
typedef void (*f)();  
ALIGNOF(f, x1);
```

实际上我们还有第二种更好的方案：

```c
template<class T> struct alignof_trick{char c;T member;}; #define ALIGNOF(type) offsetof(alignof_trick[type], member) auto x1 = ALIGNOF(int); auto x2 = ALIGNOF(void(*))();
```

上面的代码利用模板来构造结构体，这一点显然优于用宏构造。因为它不仅可以处理函数指针类型，还能够在表达式中构造结构体，从而让ALIGNOF写在表达式当中，这也让它更接近alignof运算符的用法。

除用一些小技巧获取类型对齐字节长度之外，很多编译器还提供了一些扩展方法帮助我们获得类型的对齐字节长度，以MSVC和GCC为例，它们分别可以通过扩展关键字 __alignof 和 __alignof_ 来获取数据类型的对齐字节长度：

```txt
//MSVC   
auto x1  $=$  __alignof(int);   
auto x2  $=$  __alignof(void(\*）();   
//GCC   
auto x3  $=$  __alignof__(int);   
auto x4  $=$  __alignof__(void(\*）);
```

相对于获取数据对齐的功能而言，设置数据对齐就没那么幸运了，在C++11之前，我们不得不依赖编译器给我们提供的扩展功能来设置数据对齐。幸好很多编译器也提供了这样的功能，还是以MSVC和GCC为例：

```txt
// MSVC short x1;
```

```cpp
__declspec(align(8)) short x2;
std::cout << "x1 = " << __alignof(x1) << std::endl;
std::cout << "x2 = " << __alignof(x2) << std::endl;
// GCC
short x3;
__attribute_((aligned(8))) short x4;
std::cout << "x3 = " << __alignof_x3) << std::endl;
std::cout << "x4 = " << __alignof_x4) << std::endl;
```

上面的代码输出结果如下：

```latex
$\begin{array}{rlr}{\tt x1} & = & 2\\ {\tt x2} & = & 8\\ {\tt x3} & = & 2\\ {\tt x4} & = & 8 \end{array}$
```

declspec(align(8))和

__attribute__(aligned(8))分别将x2和x4两个short类型的对齐长度从2字节扩展到8字节。

不同的编译器需要采用不同的扩展功能来控制类型的对齐字节长度，这一点对于程序员来说很不友好。所以C++标准委员在C++11标准中新增了alignof和 Alignas两个关键字。

