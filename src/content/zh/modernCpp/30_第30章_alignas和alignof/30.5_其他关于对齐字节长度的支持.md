# 30.5 其他关于对齐字节长度的支持

C++11标准除了提供了关键字alignof和 Alignas来支持对齐字节长度的控制以外，还提供了std::alignment_of、

std::aligned_storage和std::aligned_union类模板型以及std::align函数模板来支持对于对齐字节长度的控制。下面简单地介绍一下它们的用法。

std::alignment_of和alignof的功能差不多，可以获取类型的对齐字节长度，例如：

```cpp
std::cout << std::alignment_of<int>::value << std::endl; //输出4  
std::cout << std::alignment_of<int>() << std::endl; //输出4  
std::cout << std::alignment_of double>::value << std::endl; //输出8  
std::cout << std::alignment_of double>() << std::endl; //输出8
```

std::aligned_storage可以用来分配一块指定对齐字节长度和大小的内存，例如：

```cpp
std::aligned_storage<128, 16>::type buffer;  
std::cout << sizeof(buffer) << std::endl; //内存大小指定为128字节  
std::cout << alignof(buffer) << std::endl; //对齐字节长度指定为16字节
```

std::aligned_union接受一个std::size_t作为分配内存的大小，以及不定数量的类型。std::aligned_union会获取这些类型中对齐字节长度最严格的（对齐字节数最大）作为分配内存的对齐字节长度，例如：

```cpp
std::aligned_union<64, double, int, char>::type buffer;  
std::cout << sizeof(buffer) << std::endl; //内存大小指定为64字节  
std::cout << alignof(buffer) << std::endl; //对齐字节长度自动选择为  
//double，8字节对齐
```

最后解释一下std::align函数模板，该函数接受一个指定大小的缓冲区空间的指针和一个对齐字节长度，返回一个该缓冲区中最近的能找到符合指定对齐字节长度的指针。通常来说，我们传入的缓冲区内存大小为预分配的缓冲区大小加上预指定对齐字节长度的字节数。下面会给出一个例子详解这个函数模板的用法，这个例子不仅说明了函数的用法，更重要的是，它证明了在CPU喜爱的对齐字节长度上做计算，CPU的工作效率会更高：

```c
include<iostream>   
#include <memory>   
#include <chrono>   
static inline void \*movsb(void \*d, const void \*s,size_t n){ asm volatile("rep movsb" :  $\equiv$  D"(d),  $^{\prime \prime} = S^{\prime \prime}$  (s),
```

```cpp
"=" c" (n)
: "0" (d),
"1" (s),
"2" (n)
: "memory");
return d;
}
int main(int argc, char *argv[])
{
constexpr int align_size = 32;
constexpr int alloc_size = 10001;
constexpr int buff_size = align_size + alloc_size;
char dest[buffer_size] {0};
char src[buffer_size] {0};
void *dest_ori_ptr = dest;
void *src_ori_ptr = src;
size_t dest_size = sizeof(dest);
size_t src_size = sizeof(src);
char *dest_ptr = static_cast<char *>(std::align(align_size,
alloc_size, dest_ori_ptr, dest_size));
char *src_ptr = static_cast<char *>(std::align(align_size,
alloc_size, src_ori_ptr, src_size));
if (argc == 2 && argv[1][0] == '1') {
++dest_ptr;
++src_ptr;
}
auto start = std::chrono::high_resolution_clock::now());
for (int i = 0; i < 10000000; i++) {
__movsb(dest_ptr, src_ptr, alloc_size - 1);
}
auto end = std::chrono::high_resolution_clock::now());
std::chrono::duration<double> diff = end - start;
std::cout << " elapsed time = " << diff.count();
}
```

上面的代码用汇编语言实现了一个memcpy函数以确保复制内存函数都是通过汇编指令movsb完成的。然后我们预先分配了两个10001+32字节大小的内存作为目标缓冲区和源缓冲区。此后通过std::align找到两个缓冲区中按照32字节对齐的指针，该指针指向的内存大小至少为10001字节。最后我们用自己实现的内存复制函数进

行内存复制。如果运行的时候不带任何参数，则使用32字节对齐的内存进行复制，否则用1字节对齐的内存进行内存复制，复制动作重复10000000次。在Intel(R) Core(TM)i7-7700 CPU @ 3.60GHz的机器上，两种方法的运行结果很有大差别：

```txt
./aligntest elapsed time  $= 0.951485$  ./aligntest1 elapsed time  $= 1.36937$
```

可以看到，32字节对齐的缓冲区复制时间比1字节对齐的缓冲区复制时间整整少了0.4s有余。在性能优化上来说是非常巨大的提升。

