# 20.3 结构化绑定的3种类型

结构化绑定可以作用于3种类型，包括原生数组、结构体和类对象、元组和类元组的对象，接下来将一一介绍。

# 20.3.1 绑定到原生数组

我们在上面的示例代码中并没有见到过这种类型，它是3种情况中最简单的一种。绑定到原生数组即将标识符列表中的别名一一绑定到原生数组对应的元素上。所需条件仅仅是要求别名的数量与数组元素的个数一致，比如：

```txt
include<iostream>   
int main()   
{ int a[3]{1,3,5}; auto[x,y,z]  $=$  a; std::cout  $\ll$  "x，y，z]  $= [^{\prime \prime}$ $\ll x\ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll \ll$
```

以上代码很好理解，别名x、y和z分别绑定到a[0]、a[1]和a[2]所对应的匿名对象上。另外，绑定到原生数组需要小心数组的退化，因为在绑定的过程中编译器必须知道原生数组的元素个数，一旦数组退化为指针，就将失去这个属性。

# 20.3.2 绑定到结构体和类对象

将标识符列表中的别名分别绑定到结构体和类的非静态成员变量上，这一点在之前的例子中已经见到了。但是我们之前没有提过关于这种绑定的限制条件，实际上这种情况的限制条件要比原生数组复杂得多。首先，类或者结构体中的非静态数据成员个数必须和标识符列表中的别名的个数相同；其次，这些数据成员必须是公有的（ $\mathrm{C}++20$  标准修改了此项规则，详情见20.5节）；这些数据成员必须是在同一个类或者基类中；最后，绑定的类和结构体中不能存在匿名联合体：

```txt
classBindTest{ int  $\mathrm{a} = 42$  //私有成员变量 public: double  $b = 11.7$  { int main() { BindTestbt; auto[x，y]  $\equiv$  bt; }
```

以上代码会编译错误，因为BindTest成员变量a是私有的，违反了绑定结构体的限制条件：

```txt
class BindBase1 {
public:
    int a = 42;
    double b = 11.7;
};
class BindTest1 : public BindBase1 {
class BindBase2 {
class BindTest2 : public BindBase2 {
public:
    int a = 42;
    double b = 11.7;
};
class BindBase3 {
public:
    int a = 42;
};
class BindTest3 : public BindBase3 {
public:
    double b = 11.7;
};
int main()
{
    BindTest1 bt1;
    BindTest2 bt2;
    BindTest3 bt3;
    auto[x1, y1] = bt1; //编译成功
    auto[x2, y2] = bt2; //编译成功
    auto[x3, y3] = bt3; //编译错误
}
```

在上面这段代码中，auto[x1，y1] = bt1和auto[x2，y2] = bt2可以顺利地编译，因为类BindTest1和BindTest2的非静态数据成员要么全部在派生类中定义，要么全部在基类中定义。

BindTest3却不同，其中成员变量a的定义在基类，成员变量b的定义在派生类，这一点违反了绑定结构体的限制条件，所以auto[x3,

y3] = bt3会导致编译错误。最后需要注意的是，类和结构体中不能出现匿名的联合体，而对于命名的联合体则没有限制。

# 20.3.3 绑定到元组和类元组的对象

绑定到元组就是将标识符列表中的别名分别绑定到元组对象的各个元素。绑定到类元组又是什么意思呢？要解释这个概念就要从绑定的限制条件讲起。实际上，绑定元组和类元组有一系列抽象的条件：对于元组或者类元组类型T。

1. 需要满足std::tuple_size<T>::value是一个符合语法的表达式，并且该表达式获得的整数值与标识符列表中的别名个数相同。  
2. 类型T还需要保证std::tuple_element<i, T>::type也是一个符合语法的表达式，其中i是小于std::tuple_size<T>::value的整数，表达式代表了类型T中第i个元素的类型。  
3. 类型T必须存在合法的成员函数模板get<i>()或者函数模板get<i>(t)，其中i是小于std::tuple_size<T>::value的整数，t是类型T的实例，get<i>()和get<i>(t)返回的是实例t中第i个元素的值。

理解上述条件会发现，它们其实比较抽象。这些条件并没有明确规定结构化绑定的类型一定是元组，任何具有上述条件特征的类型都可以成为绑定的目标。另外，获取这些条件特征的代价也并不高，只需要为目标类型提供std::tuple_size、std::tuple_element以及get的特化或者偏特化版本即可。实际上，标准库中除了元组本身毫无疑问地能够作为绑定目标以外，std::pair和std::array也能作为结构化绑定的目标，其原因就是它们是满足上述条件的类元组。说到这里，就不得不进一步讨论std::pair了，因为它对结构化绑定的支持给我们带来了一个不错的惊喜：

```cpp
include<iostream>   
#include <string>   
#include <map>   
int main()   
{ std::map<int, std::string> id2str{ {1, "hello"},{3, "Structured"},{5, " bindings"} }; for(const auto& elem : id2str){ std::cout << "id=" << elem.first << ", str=" << elem(second << std::endl; }   
}
```

上面这段代码是一个基于范围的for循环遍历std::map的例子，其中elem是std::pair const int, std::string>类型，要在循环体中输出key和value的值就需要访问成员变量first和second。这个例子中使用基于范围的for循环已经比使用迭代器遍历std::map简单了很多，但是加入结构化绑定后代码将被进一步简

化。我们可以将std::pair的成员变量first和second绑定到别名以保证代码阅读起来更加清晰：

```cpp
for (const auto& [id, str]: id2str) {
    std::cout << "id=" << id
        << ", str=" << str << std::endl;
}
```

