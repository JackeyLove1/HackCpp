# 20.2 深入理解结构化绑定

在阅读了前面的内容之后，读者是否有这样的理解。

1. 结构化绑定的目标就是等号右边的对象。  
2. 所谓的别名就是对等号右边对象的子对象或者元素的引用。

如果确实是这么理解的，请忘掉它们，因为上面的理解是错误的。真实的情况是，在结构化绑定中编译器会根据限定符生成一个等号右边对象的匿名副本，而绑定的对象正是这个副本而非原对象本身。另外，这里的别名真的是单纯的别名，别名的类型和绑定目标对

象的子对象类型相同，而引用类型本身就是一种和非引用类型不同的类型。在初步了解了结构和绑定的“真相”之后，现在我将使用伪代码进一步说明它是如何工作起来的。对于结构化绑定代码：

```txt
BindTest bt; const auto [x, y] = bt;
```

编译器为其生成的代码大概是这样的：

```txt
BindTest bt;  
const auto __anonymous = bt;  
aliasname x = __anonymous.a  
aliasname y = __anonymous.b
```

在上面的伪代码中，_anonymous是编译器生成的匿名对象，可以注意到const auto[x, y] = bt中auto的限定符会直接应用到匿名对象_anonymous上。也就是说，_anonymous是const还是volatile完全依赖auto的限定符。另外，在伪代码中x和y的声明用了一个不存在的关键字aliasname来表达它们不是_anonymous成员的引用而是_anonymous成员的别名，也就是说x和y的类型分别为const int和const std::string，而不是const int&和const std::string&。为了证明以上两点，读者可以尝试编译运行下面这段代码：

```c
include<iostream>   
#include<string>   
struct Test{ int  $\mathrm{a} = 42$  std::string b  $=$  "hello structured binding";   
};
```

```cpp
int main()   
{ BindTest bt; const auto[x, y]  $=$  bt; std::cout<<"&bt.a="<<&bt.a<<" &x="<<&x<<std::endl; std::cout<<"&bt.b="<<&bt.b<<" &y="<<&y<<std::endl; std::cout<<"std::is alike_v<const int,decltype(x)>=" <<std::is alike_v<const int,decltype(x)><<std::endl; std::cout<<"std::is alike_v<const std::string,decltype(y)>=" <<std::is alike_v<const std::string,decltype(y)><< std::endl;   
}
```

# 编译运行的结果如下:

```cpp
&bt.a=0x77fde0 &x=0x77fd80  
&bt.b=0x77fde8 &y=0x77fd88  
std::is SAME_v<const int,oclotype(x)> = 1  
std::is SAME_v<const std::string,oclotype(y)> = 1
```

正如上文中描述的那样，别名x并不是bt.a，因为它们的内存地址不同。另外，x和y的类型分别与const int和const

std::string相同也证明了它们是别名而不是引用的事实。由此可见，如果在上面这段代码中试图使用x和y去修改bt的数据成员是无法成功的，因为一方面x和y都是常量类型；另一方面即使x和y是非常量类型，改变的x和y只会影响匿名对象而非bt本身。当然了，了解了结构化绑定的原理之后，写一个能改变bt成员变量的结构化绑定代码就很简单了：

```cpp
int main()   
{ BindTest bt; auto&[x，y]  $=$  bt; std::cout<<"&bt.a="<<&bt.a<<" &x="<<&x<<std::endl; std::cout<<"&bt.b="<<&bt.b<<" &y="<<&y<<std::endl;
```

```cpp
$\texttt{x} = 11$  std::cout<<"bt.a="<<bt.a<<std::endl; bt.b  $=$  "hi structured binding"; std::cout<<"y="<<y<<std::endl;   
1
```

虽然只是将const auto修改为auto&，但是已经能达到让bt数据成员和x、y相互修改的目的了：

```ini
BindTest bt;  
auto &_anonymous = bt;  
aliasname x = _anonymous.a  
aliasname y = _anonymous.b
```

关于引用有趣的一点是，如果结构化绑定声明为const auto& [x, y] = bt，那么x = 11会编译失败，因为x绑定的对象是一个常量引用，而bt.b = "hi structured binding"却能成功修改y的值，因为bt本身不存在常量问题。

请注意，使用结构化绑定无法忽略对象的子对象或者元素：

```cpp
auto t = std::make tuple(42, "hello world"); auto [x] = t;
```

以上代码是无法通过编译的，必须有两个别名分别对应bt的成员变量a和b。熟悉C++11的读者可能会提出仿照std::tie使用std::ignore的方案：

```rust
auto t = std::make tuple(42, "hello world");  
int x = 0, y = 0;  
std::tie(x, std::ignore) = t;  
std::tie(y, std::ignore) = t;
```

虽然这个方案对于std::tie是有效的，但是结构化绑定的别名还有一个限制：无法在同一个作用域中重复使用。这一点和变量声明是一样的，比如：

```txt
auto t = std::make tuple(42, "hello world");  
auto[x, ignore] = t;  
auto[y, ignore] = t; //编译错误，ignore无法重复声明
```

