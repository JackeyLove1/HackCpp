# 20.5 绑定的访问权限问题

前面提到过，当在结构体或者类中使用结构化绑定的时候，需要有公开的访问权限，否则会导致编译失败。这条限制乍看是合理的，但是仔细想来却引入了一个相同条件下代码表现不一致的问题：

```txt
struct A {
    friend void foo();
}
private:
    int i;
};
void foo() {
    A a {};
    auto x = a.i; // 编译成功
    auto [y] = a; // 编译失败
}
```

在上面这段代码中，foo是结构体A的友元函数，它可以访问A的私有成员i。但是，结构化绑定却失败了，这就明显不合理了。同样

的问题还有访问自身成员的时候：

```txt
class C{ int i; void foo(const C& other){ auto[x]  $=$  other; //编译失败 }；
```

为了解决这类问题，C++20标准规定结构化绑定的限制不再强调必须为公开数据成员，编译器会根据当前操作的上下文来判断是否允许结构化绑定。幸运的是，虽然标准是2018年提出修改的，但在我实验的3种编译器上，无论是C++17还是C++20标准，以上代码都可以顺利地通过编译。

