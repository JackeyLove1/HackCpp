# 20.1 使用结构化绑定

熟悉Python的读者应该知道，Python函数可以有多个返回值，例如：

```python
def return_multiple_values():
    return 11, 7
x, y = return_multiple_values()
```

在上面的代码中函数return_multiple_values返回的是一个元组（tuple）(11，7)，在函数返回后元组中元素的值被自动地分配到了x和y上。回过头来看C++, 我们惊喜地发现在C++11标准中同样引入了元组的概念，通过元组C++也能返回多个值，但使用方法却不如Python那般简洁：

```cpp
include<iostream> #include <tuple> std::tuple<int，int> return_multiple_values() { return std::make tuple(11,7); int main() { int  $\mathrm{x} = 0$  ，y  $= 0$  std::tie(x,y)  $=$  return multiple_values(); std::cout<< "x=" << x<<"y="<< y<< std::endl; }
```

可以看到，这段代码和Python完成了同样的工作，但代码却要麻烦许多。其中一个原因是C++11必须指定return_multiple_values函数的返回值类型，另外，在调用return_multiple_values函数前还需要声明变量x和y，并且使用函数模板std::tie将x和y通过引用绑定到std::tuple<int&, int>&上。对于第一个问题，我们可以使用C++14中auto的新特性来简化返回类型的声明（可以回顾第3章）：

```cpp
auto return_multiple_values()
{
return std::make tuple(11, 7);
}
```

重点来了，要想解决第二个问题就必须使用C++17标准中新引入的特性——结构化绑定。所谓结构化绑定是指将一个或者多个名称绑定到初始化对象中的一个或者多个子对象（或者元素）上，相当于给初始化对象的子对象（或者元素）起了别名，请注意别名不同于引用，这一点会在后面详细介绍。首先让我们看一看结构化绑定是如何化腐朽为神奇的：

```cpp
include<iostream>   
#include <tuple>   
auto return_multiple_values()   
{ return std::make tuple(11,7);   
}   
int main()   
{ auto[x,y]  $=$  return_multiple_values(); std::cout<<"x="<<x<<"y="<<y<<std::endl;
```

在上面这段代码中，auto[x, y] = return_multiple_values() 是一个典型的结构化绑定声明，其中 auto 是类型占位符，[x, y] 是绑定标识符列表，其中 x 和 y 是用于绑定的名称，绑定的目标是函数 return_multiple_values() 返回结果副本的子对象或者元素。用支持 C++17 标准的编译器编译运行这段代码会正确地输出：

```txt
x=11 y=7
```

请注意，结构化绑定的目标不必是一个函数的返回结果，实际上等号的右边可以是任意一个合理的表达式，比如：

```cpp
include<iostream>   
#include<string>   
structBindTest{ int  $\mathbf{a} = 42$  std::stringb  $=$  "hello structured binding";   
};   
int main()   
{ BindTest bt; auto[x,y]  $\equiv$  bt; std::cout<<"x="<<x<<"y="<<y<<std::endl;
```

编译运行这段代码的输出如下:

```txt
x=42 y=hello structured binding
```

可以看到结构化绑定能够直接绑定到结构体上。将其运用到基于范围的for循环中会有更好的效果：

```cpp
include<iostream>   
#include<string>   
#include<vector>   
structBindTest{ int  $\mathrm{a} = 42$  std::stringb  $=$  "hello structured binding";   
};   
int main() { std::vector<BindTest>bt{11，"hello"},{7，"c++"}，{42, "world"}}； for(const auto&[x,y]：bt){ std::cout<<"x="<<x<<"y="<<y<<std::endl; }   
}
```

请注意以上代码的for循环部分。在这个基于范围的for循环中，通过结构化绑定直接将x和y绑定到向量bt中的结构体子对象上，省去了通过向量的元素访问成员变量a和b的步骤。

