# 20.4 实现一个类元组类型

我们已经知道了通过满足类元组的限制条件让任何类型支持结构化绑定的方法，现在是时候实践一下了。以上一节中提到的BindTest3为例，我们知道由于它的数据成员分散在派生类和基类之中，因此无法使用结构化绑定。下面将通过让其满足类元组的条件，从而达到支持结构化绑定的目的：

```txt
include<iostream> #include <tuple> classBindBase3{ public: int  $\mathrm{a} = 42$  ；   
classBindTest3：publicBindBase3{ public: double  $\mathtt{b} = 11.7$  ·   
};   
namespace std{ template<> struct tuple_size<BindTest3> { static constexpr size_t value  $= 2$  · ； template<> struct tuple_element  $<  0$  ，BindTest3> { using type  $=$  int;
```

```cpp
}； template<> struct tuple_element<1, BindTest3> { using type  $=$  double; } template<std::size_t Idx> auto& get(BindTest3 &bt)  $=$  delete; template<> auto& get  $<  0>$  (BindTest3 &bt）{return bt.a;} template<> auto& get  $<  1>$  (BindTest3 &bt）{return bt.b;} int main() { BindTest3 bt3; auto& [x3，y3]  $\equiv$  bt3; x3  $= 78$  std::cout<<bt3.a<<std::endl;
```

在上面这段代码中，我们为BindTest3实现了3种特性以满足类元组的限制条件。首先实现的是：

```txt
template<> struct tuple_size<BindTest3> {
    static const char size_t value = 2;
};
```

它的作用是告诉编译器将要绑定的子对象和元素的个数，这里通过特化让tuple_size<BindTest3>::value的值为2，也就是存在两个子对象。然后需要明确的是每个子对象和元素的类型：

```txt
template<> struct tuple_element<0, BindTest3> {
    using type = int;
};
```

```typescript
struct tuple_element<1, BindTest3> {
    using type = double;
};
```

这里同样通过特化的方法指定了两个子对象的具体类型。最后需要实现的是get函数，注意，get函数的实现有两种方式，一种需要给BindTest3添加成员函数；另一种则不需要，我们通常会选择不破坏原有代码的方案，所以这里先展示后者：

```cpp
template<std::size_t Idx> auto& get(BindTest3 &bt) = delete; template<> auto& get<0>(BindTest3 &bt) { return bt.a; } template<> auto& get<1>(BindTest3 &bt) { return bt.b;}
```

可以看到函数模板get也特化出了两个函数实例，它们分别返回bt.a和bt.b的引用。之所以这里需要返回引用，是因为我希望结构化绑定的别名能够修改BindTest3的实例，如果需要的是一个只读的结构化绑定，则这里可以不必返回引用。最后

```txt
template<std::size_t Idx> auto& get(BindTest3 &bt) = delete可以明确地告知编译器不要生成除了特化版本以外的函数实例以防止get函数模板被滥用。
```

正如上文强调的，我不推荐实现成员函数版本的get函数，因为这需要修改原有的代码。但是当我们重新编写一个类，并且希望它支持结构化绑定的时候，也不妨尝试实现几个get成员函数：

```cpp
include<iostream>   
#include <tuple>   
class BindBase3{   
public: int a  $= 42$  .   
};   
class BindTest3 : public BindBase3{   
public: double b  $= 11.7$  templatestd::size_t Idx> auto& get()  $=$  delete;   
};   
template<>auto&BindTest3::get<0>(）{return a;}   
template<>auto&BindTest3::get<1>(）{return b;}   
namespace std{ template<> struct tuple_size<BindTest3> { static constexpr size_t value  $= 2$  . }； template<> struct tuple_element  $<  0$  ,BindTest3> { using type  $=$  int; }； template<> struct tuple_element  $<  1$  ,BindTest3> { using type  $=$  double; }   
int main() { BindTest3 bt3; auto& [x3,y3]  $=$  bt3; x3  $= 78$  std::cout<<bt3.a<<std::endl;
```

这段代码和第一份实现代码基本相同，我们只需要把精力集中到get成员函数的部分：

```cpp
class BindTest3 : public BindBase3 {
public:
    double b = 11.7;
    template<std::size_t Idx> auto& get() = delete;
};
template<> auto& BindTest3::get<0>(   ) \{ return a; \}
template<> auto& BindTest3::get<1>(   ) \{ return b; \}
```

这段代码中get成员函数的优势显而易见，成员函数不需要传递任何参数。另外，特化版本的函数get  $< 0>$  和get  $< 1>$  可以直接返回a和b，这显得格外简洁。读者不妨自己编译运行一下这两段代码，其输出结果应该都是78，修改bt.a成功。

