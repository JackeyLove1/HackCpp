# 42.3 friend声明模板形参（C++11）

友元在C++中一直是一个备受争议的特性，争议的焦点是一个类的友元可以忽略该类的访问属性（public、protected、private），对类成员进行直接访问，破坏了代码的封装性。不过，

我却很喜欢这个特性，在我看来友元语法简单且使用方便，合理使用不会造成代码混乱、难以阅读甚至可以简化代码，它提供了一种语法上的可能性，让程序员更灵活地控制对类的访问。至于说破坏封装性的问题，我们大可以谨慎使用友元，保证编写的类不会被滥用即可。

也许C++委员会也是出于我这样的想法，在C++标准中不但没有反对和删除这个特性，反而扩展了它在模板里的能力。介绍该能力之前，需要先介绍一个语法上的改进，在C++11标准中，将一个类声明为另外一个类的友元，可以忽略前者的class关键字。当然，忽略class关键字还有一个大前提，必须提前声明该类，例如：

```txt
class C;   
class X1{ friend class C; //C++11前后都能编译成功   
};   
class X2{ friend C; //C++11以前会编译错误，C++11以后编译成功   
}；
```

在上面的代码中，x1可以在C++11以及之前标准的编译器中编译成功，而x2在C++11之前则可能会编译失败，因为friend C缺少class关键字。这里说可能，是因为在某些新版本的编译器中，例如GCC，即使指定了- std=c++03，x2也能够编译通过，而在另外一些新编译器中可能会给出警告，例如CLang，但也会编译成功。请注意，这里为了保证x2编译通过，class C的提前声明是必不可少的。

引入忽略class关键字这个能力后，我们会发现friend多了一些事情可以做，比如用friend声明基本类型、用friend声明别名、用friend声明模板参数：

```txt
class C; typedef C Ct;   
class X1 { friend C; friend Ct; friend void; friend int;   
}; template <typename T> class R { friend T;   
}；   
R<C> rc;   
R<CT> rct;   
R<int> ri;   
Rvoid> rv;
```

以上代码中的friend C和friend Ct具有相同的含义，都是指定类C为类X1的友元。对于基本类型，friend void和friend int虽然也能编译成功，但是实际上编译器不会做任何事情，也就是说它们会被忽略。这个特性可以延伸到模板参数上，当模板参数为C或者 Ct时，C为类R<C>的友元，当模板参数为int等内置类型时，friend T被忽略，类R<int>不存在友元。

通过上面的示例可以发现，用模板参数结合友元可以让我们在使用友元的代码上进行切换而不需要多余的代码修改，例如：

```javascript
classInnerVisitor{/\*访问SomeDatabase内部数据\*/}；
```

```txt
template <typename T> class SomeDatabase {
    friend T;
    // ... 内部数据
public:
    // ... 外部接口
};
```

这里DiagDatabase是一个对内的诊断数据库类，它设置InnerVisitor为友元，通过InnerVisitor对数据库数据进行诊断。而对外则使用类StandardDatabase，因为它的友元声明为void，所以不存在友元，外部需要通过标准方法访问数据库的数据。

