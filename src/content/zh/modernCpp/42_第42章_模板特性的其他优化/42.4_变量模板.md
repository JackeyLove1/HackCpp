# 42.4 变量模板（C++14）

请读者回答一个问题，如果想根据不同的类型去定义一个变量有哪些做法，根据以往的C++知识，读者应该能想到两种方法。

在类模板定义静态数据成员：

```cpp
include<iostream>   
template<class T>   
struct PI{ static constexpr T value  $=$  static cast<T>(3.1415926535897932385);   
}；   
int main() { std::cout<<PI<float>::value<<std::endl;   
}
```

使用函数模板返回所需的值：

```cpp
include<iostream>   
template<class T>   
constexpr T PI()   
{ return static cast<T>(3.1415926535897932385);   
}   
int main()   
{ std::cout << PI<int>() << std::endl;   
}
```

很明显，根据类型定义变量并不是一件有难度的事情，通过类模板和函数模板可以轻松达到这个目的。

不过C++委员会似乎并不满足于此，在C++14的标准中引入了变量模板的特性，有了变量模板，我们不再需要冗余地定义类模板和函数模板，只需要专注要定义的变量即可，还是以变量PI为例：

```cpp
include<iostream>   
template<class T>   
constexprTPI  $\equiv$  static cast<T>(3.1415926535897932385L); intmain() { std::cout<<PI<float  $> <   <$  std::endl; 1
```

在上面的代码中，constexpr T PI = static_cast<T>(3.141592653589 7932385L);是变量的声明和初始化，template<class T>是变量的模板形参。请注意，虽然这里的变量声明为常量，但是对于变量模板而言这不是必需的，同其他模板一样，变量模板的模板形参也可以是非类型的：

```cpp
include<iostream>   
template<class T, int N>   
T PI = static cast<T>(3.1415926535897932385L) \* N; int main()   
{ PI float, 2>  $^ { \text{串} } =$  5; std::cout << PIfloat, 2> << std::endl;
```

在上面的代码中，变量模板PI不再是一个常量，我们可以在任意时候改变它的值。实际上，在C++14标准中变量模板给我们带来的最大便利是关于模板元编程的。举例来说，当比较两个类型是否相同时会用到：

```cpp
bool b = std::is_like<int, std::size_t>::value;
```

可以看到，类模板std::is_same使用常量静态成员变量的方法定义了value的值，显而易见，直接使用变量模板编写代码要简单得多，比如：

```cpp
template<class T1, class T2> constexpr bool is SAME_v = std::is_same<T1, T2>::value;
bool b = is SAME_v<int, std::size_t>;
```

有些令人尴尬的是，虽然C++14标准已经支持变量模板的特性并且也证明了可以简化代码的编写，但是在C++14的标准库中却没有对它的支持。我们不得不继续使用std::is_same<int, std::size_t>::value的方法来判断两个类型是否相同。这个尴尬的问题一直延续到C++17标准的发布才得到解决，在C++17标准库的type Traits中对类型特征采用了变量模板，比如对于

some_trait<T>:: value，会增加与它等效的变量模板 some_trait_v<T>，这里_v后缀表示该类型是一个变量模板。因此在C++17的环境下，判断两种类型是否相同就只需要编写一行代码即可：

```cpp
bool b = std::is_like_v<int, std::size_t>;
```

# 42.5 explicit(bool)

C++20标准扩展了explicit说明符的功能，在新标准中它可以接受一个求值类型为bool的常量表达式，用于指定explicit的功能是否生效。为了解释这项新功能的目的，让我们先看一看提案文档中的示例代码：

```cpp
std::pair<std::string, std::string> safe() {
    return {"meow", "purr"}; // 编译成功
}  
std::pair<std::vector<int>, std::vector<int>> unsafe() {
    return {11, 22}; // 编译失败
```

在上面的代码中safe()函数可以通过编译，unsafe()则会编译报错。这个结果符合预期，整型转换为std::vector<int>看上去都不可能是合理的。不过，让我们想一想这个差异是怎么发生的。因为"meow"和"purr"都可以构造std::string，所以safe()能编译成功，这没有问题。问题是整型也可以通过构造函数构造std::vector<int>，为何unsafe()函数编译失败了，有读者可能

会想到std::vector<int>的构造函数使用了explicit说明符，所以整型需要显式构造std::vector<int>。知识点的确没错，但是这里std::vector<int>的构造函数使用explicit说明符无法阻止std::pair的构造，因为std::pair的实现类似于以下代码：

```cpp
template<class T1, class T2> struct MyPair {
    template<class U1, class U2> MyPair(const U1& u1, const U2& u2): first_(u1), second_(u2) {}
    T1 first;
    T2 second;
};
```

上面这段代码是可以通过编译的，这说明std::vector<int>的构造函数使用explicit说明符没有限制作用。仔细观察代码会发现，实际上{11，22}并没有直接构造std::vector<int>，而是通过first_(u1)和second_(u2)间接构造std::vector<int>，这个过程显然是一个显式构造。要解决这个问题，我们需要对MyPair的构造函数使用explicit说明符。

```cpp
template<class T1, class T2> struct MyPair {
    template<class U1, class U2> explicit MyPair(const U1& u1, const U2& u2): first_(u1), second_(u2) {}
    T1 first;
    T2 second;
};
```

```txt
return{11，22}； //编译失败   
}   
MyPair<std::string，std::string>safe() { return {"meow"，"purr"}；//编译失败
```

但是这样一来又会导致safe()编译失败。为了解决这一系列的问题，标准库采用SFINAE和概念的方法实现了std::pair的构造函数，其代码类似于：

```cpp
// SFINAE版本  
template <typename T1, typename T2>  
struct pair {  
    template <typename U1 = T1, typename U2 = T2, std::enable_if_t< std::isconstructible_v<T1, U1> && std::isconstructible_v<T2, U2> && std::is.convertible_v<U1, T1> && std::is.convertible_v<U2, T2> , int> = 0 >  
constexpr pair(U1&&, U2&&);  
template <typename U1 = T1, typename U2 = T2, std::enable_if_t< std::isconstructible_v<T1, U1> && std::isconstructible_v<T2, U2> && ! (std::is.convertible_v<U1, T1> && std::is.convertible_v<U2, T2>) , int> = 0 >  
explicit constexpr pair(U1&&, U2&&);  
};
```

# // 概念版本

```cpp
template <typename T1, typename T2>
struct pair {
    template <typename U1 = T1, typename U2 = T2>
        requires std::isconstructible_v<T1, U1> && std::isconstructible_v<T2, U2> && std::is.convertible_v<U1, T1> && std::is.convertible_v<U2, T2>
    constexpr pair(U1&&, U2&&);
    template <typename U1 = T1, typename U2 = T2>
        requires std::isconstructible_v<T1, U1> &&
```

```cpp
std::is constructingible_v<T2,U2> explicit constexpr pair(U1&&,U2&&);   
};
```

从上面的代码可以看出，标准库利用SFINAE和概念实现了两套构造函数，对于类型可以转换地（使用std::is convertible_v判定）采用无explicit说明符的构造函数，而对于其他情况使用有explicit说明符的构造函数。

尽管使用以上方法很好地解决了上述一系列问题，但是不得不说它的实现非常复杂。幸好explicit(bool)的引入有效地缩减了解决上述问题的编码：

// SFINAE版本  
```cpp
template <typename T1, typename T2>   
struct pair { template <typename U1 = T1, typename U2 = T2, std::enable_if_t< std::isconstructible_v<T1, U1> && std::isconstructible_v<T2, U2> , int> = 0> explicit(!std::is convertible_v<U1, T1> || !std::is convertible_v<U2, T2>) constexpr pair(U1&&, U2&&); };
```

// 概念版本  
```cpp
template <typename T1, typename T2> struct pair {
    template <typename U1 = T1, typename U2 = T2>
        requires std::is_constructible_v<T1, U1> && std::is_constructible_v<T2, U2>
        explicit(!std::is.convertible_v<U1, T1> || !std::is Converted_v<U2, T2>) constexpr pair(U1&&, U2&&);
};
```

观察上述代码可以发现，std::pair不再需要实现两套构造函数了。取而代之的是：

```cpp
explicit(!std::is convertible_v<U1, T1> || !std::is convertible_v<U2, T2>)
```

当U1、U2不能转换到T1和T2的时

候，!std::is.convertible_v<U1, T1> || !std::is_

convertible_v<U2，T2>的求值为true，explicit(true)表示该构造函数为显式的。反之，当U1、U2可以转换到T1和T2时，最终结果为explicit(false)，explicit说明符被忽略，构造函数可以隐式执行。

