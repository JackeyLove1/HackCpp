# 42.2 连续右尖括号的解析优化（C++11）

从C++引入右尖括号开始直到C++11标准发布，C++一直存在这样一个问题，两个连续的右尖括号>>一定会被编译器解析为右移，这是因为编译器解析采用的是贪婪原则。但是在很多情况下，连续两个右尖括号并不是要表示右移，可能实例化模板时模板参数恰好也是一个类模板，又或者类型转换的目标类型是一个类模板。在这种情况下，过去我们被要求在两个尖括号之间用空格分隔，比如：

```cpp
include <vector> typedef std::vector<std::vector<int>>Table; //编译成功 typedef std::vector<std::vector bool>>Flags; //编译失败，>>被解析为右移
```

如果上面的代码使用GCC 4.1编译，会发现代码无法通过编译，同时编译器会给出具体的提示，要求将代码中的'>'修改为'>'。当然，类型转换static_cast、const_cast、dynamic_cast和reinterpret_cast也存在同样的问题。这个问题虽然不大，但是确实也挺让人厌烦的，所以在C++11中将连续右尖括号的解析进行了优化。

在C++11标准中，编译器不再一味地使用贪婪原则将连续的两个右尖括号解析为右移，它会识别左尖括号激活状态并且将右尖括号优先匹配给激活的左尖括号。这样一来，我们就无须在两个右尖括号中插入空格了。

还是编译上面的代码，只不过这一次我们采用新一点的编译器，比如GCC 8.1，代码就能够顺利地编译。

这样就结束了吗？并不是，由于解析规则的修改会造成在老规则下编写的代码出现问题，比如：

```txt
template<int N> class X{};  
X <1 >> 3 > x;
```

上面的代码用GCC 4.1可以顺利编译，因为代码里的  $1 >> 3$  被优先处理，相当于  $\mathrm{x} < (1 >> 3) > \mathrm{x}$  。但是在新的编译器中，这段代码无法成功编译，因为连续两个右尖括号的第一个括号总是会跟开始的左尖括号匹配，相当于  $(\mathrm{x} < 1 >> 3) > \mathrm{x}$  。无法兼容老代码的问题虽然看似严重，但其实要解决这个问题非常简单，只要将需要优先解析的内容用小括号包括起来即可，比如  $\mathrm{x} < (1 >> 3) > \mathrm{x}$  。

故事到这里还没有结束，由于涉及模板编程，因此情况比我们想象得还要复杂一点，因此来看一看下面的例子：

```cpp
include<iostream>   
template<int I> struct X{ static int const c  $= 2$  .   
};   
template<>struct  $\mathrm{x} <   0 >$  { typedef int c;   
};   
template<typename T> struct Y{ static int const c  $= 3$  .   
};   
static int const c  $= 4$    
int main() { std::cout<<Y<X<1>>:c>>:c)<<std::endl; std::cout<<Y<X<1>>:c>>:c）<<std::endl;   
}
```

上面的代码在新老编译器上都可以成功编译，但是输出结果却不相同，用GCC 4.1编译这份代码，运行后输出为0和3。但是在GCC 8.1或者以上版本的编译器上编译运行，得到的结果却是0和0。现在让我们看一看这是怎么发生的。

对于GCC 8.1而言，std::cout << (Y<X<1> >= c > ::c > ::c) << std::endl; 和 std::cout << (Y<X<1> >= c > ::c > ::c) << std::endl; 的解析方式相同，都是先解析X<1>，接着解析Y<X<1> ::c，最后的代码相当于std::cout << (3 > 4 > 4) << std::endl，所以输出都为0。

而对于GCC4.1，两个语句有着截然不同的解析顺序。其中std::cout << (Y<X<1> >>> c > >>> c) << std::endl;和GCC8.1的解析顺序相同，所以输出为0。但是std::cout << (Y<X<1>> >>> c > >>> c) << std::endl;的解析顺序则不同，先解析1>>>c得到结果0，接着解析X<0>>>c得到结果为类型int，最后解析Y<int>> ::c的结果为3，所以输出结果为3。

对于同一份代码的运行结果不同，这是我们处理兼容问题时最不想看到的情况。值得庆幸的是，像上面这份“奇怪”的代码不太会出现在真实的开发环境中。不过在将老代码迁移到新编译环境中时还是应该小心谨慎，避免出现难以预测的问题。

