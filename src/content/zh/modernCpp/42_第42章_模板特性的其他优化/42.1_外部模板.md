# 42.1 外部模板（C++11）

读者对extern关键字应该不会陌生，它可以在声明变量和函数的时候使用，用于指定目标为外部链接，但其本身并不参与目标的定义，所以对目标的属性没有影响。extern最常被使用的场景是当一个变量需要在多份源代码中使用的时候，如果每份源代码都定义一个变量，那么在代码链接时会出错，正确的方法是在其中一个源代码中定义该变量，在其他的源代码中使用extern声明该变量为外部变量。

```latex
\src1.cpp int  $\mathbf{x} = 0$    
\src2.cpp extern int x;  $\mathrm{x} = 11$
```

由于在多份源代码中定义同一个变量会让链接报错，因此我们不得不使用extern来声明外部变量。但是外部模板又是怎么一回事呢？我们都知道，在多份源代码中对同一模板进行相同的实例化是不会有任何链接问题的，例如：

```cpp
// header.h   
template<class T> bool foo(T t) { return true; }   
// src1.cpp   
#include <header.h>   
bool b = foo(7);   
// src2.cpp   
#include <header.h>   
bool b = foo(11);
```

在上面的代码中，src1.cpp和src2.cpp都会实例化一份相同的函数代码bool foo<int>(int)。不过它们并没有在链接的时候产生冲突，这是因为链接器对于模板有特殊待遇。编译器在编译每份源代码的时候会按照单个源代码的需要生成模板的实例，而链接器对于这些实例会进行一次去重操作，它将完全相同的实例删除，最后只留下一份实例。不过读者有没有发现，在整个过程中编译器生成各种模板实例，连接器却删除重复实例，中间的编译和连接时间完全被浪费了。如果只是一两份源代码中出现这种情况应该不会有太大影响，但是如果源代码数量达到上万的级别，那么编译和连接的过程将付出大量额外的时间成本。

为了优化编译和连接的性能，C++11标准提出了外部模板的特性，这个特性保留了extern关键字的语义并扩展了关键字的功能，让它能够声明一个外部模板实例。在进一步说明外部模板之前，我们先回顾一下如何显式实例化一个模板：

```cpp
// header.h   
template<class T> bool foo(T t) { return true; }   
// src1.cpp   
#include <header.h>   
template bool foo(double);
```

```cpp
// src2.cpp  
#include <header.h>  
template bool foo(double);
```

在上面的代码中，src1.cpp和src2.cpp编译时分别显式实例化了同一份函数bool foo<double>(double)，而在连接时其中的一个副本被删除，这个过程和之前隐式实例化的代码是一样的。如果想在这里声明一个外部模板，只需要在其中一个显式实例化前加上extern template，比如：

```cpp
// header.h   
template<class T> bool foo(T t) { return true; }   
// src1.cpp   
#include <header.h>   
extern template bool foo<double>(double);   
// src2.cpp   
#include <header.h>   
template bool foo<double>(double);
```

这样编译器将不会对src1.cpp生成foo函数模板的实例，而是在链接的时候使用src2.cpp生成的bool foo<double>(double)函数。如此一来就省去了之前冗余的副本实例的生成和删除的过程，改善了软件构建的性能。另外，外部模板除了可以针对函数模板进行优化，对于类模板也同样适用，例如：

```cpp
// header.h   
template<class T> class bar {   
public: void foo(T t) {};   
};   
// src1.cpp   
#include <header.h>   
extern template class bar<int>;
```

```cpp
extern template void bar<int>::foo(int); //src2.cpp #include <header.h> template class bar<int>;
```

从上面的代码可以看出，extern template不仅可以声明外部类模板实例extern template class bar<int>，还可以明确具体的外部实例函数extern template void bar<int>::foo(int)。

最后需要说明一下，我并没有在大型的工程中使用外部模板提升工程的构建性能，所以无法给出一个明确的数据证明。但是从原理上来说，这种优化应该是非常有效的，因为对一个复杂的模板实例化确实需要不少的时间。如果有读者正在苦于项目工程的构建效率过低，并且有足够的精力对大量的源代码进行修改，不妨试一试外部模板这个特性。

