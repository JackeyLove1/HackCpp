# 29.1 十六进制浮点字面量

从C++11开始，标准库中引入了std::hexfloat和std::defaultfloat来修改浮点输入和输出的默认格式化，其中std::hexfloat可以将浮点数格式化为十六进制的字符串，而std::defaultfloat可以将格式还原到十进制，以输出为例：

```cpp
include<iostream>   
int main()   
{ double float_array[]{5.875，1000，0.117}； for (auto elem : float_array) { std::cout << std::hexfloat << elem << " = " << std::defaultfloat << elem << std::endl; }   
}
```

上面的代码分别使用std::hexfloat和std::defaultfloat格式化输出了数组x里的元素，输出结果如下：

```txt
0x1.780000p+2 = 5.875  
0x1.f40000p+9 = 1000  
0x1.df3b64p-4 = 0.117
```

这里有必要简单说明一下十六进制浮点数的表示方法，以  $0 \times 1. f 4 0 0 0 0 p + 9$  为例：其中  $0 \times 1. f 4$  是一个十六进制的有效数， $p + 9$

是一个以2为底数，9为指数的幂。其中底数一定为2，指数使用的是十进制。也就是说  $0 \times 1 . f 4 0 0 0 0 p + 9$  可以表示为： $0 \times 1 . f 4 * 2^{9}$ 。

虽然  $\mathrm{C} + + 11$  已经具备了在输入输出的时候将浮点数格式化为十六进制的能力，但遗憾的是我们并不能在源代码中使用十六进制浮点字面量来表示一个浮点数。幸运的是，这个问题在  $\mathrm{C} + + 17$  标准中得到了解决：

```cpp
include<iostream>   
int main()   
{ double float_array[] { 0x1.7p+2, 0x1.f4p+9, 0x1.df3b64p-4 }; for (auto elem : float_array) { std::cout << std::hexfloat << elem << " = " << std::defaultfloat << elem << std::endl; }   
}
```

使用十六进制浮点字面量的优势显而易见，它可以更加精准地表示浮点数。例如，IEEE-754标准最小的单精度值很容易写为  $0 \times 1.0 \mathrm{p} - 126$  。当然了，十六进制浮点字面量的劣势也很明显，它不便于代码的阅读理解。总之，我们在  $\mathrm{C}++17$  中可以根据实际需求选择浮点数的表示方法，当需要精确表示某个浮点数的时候可以采用十六进制浮点字面量，其他情况使用十进制浮点字面量即可。

