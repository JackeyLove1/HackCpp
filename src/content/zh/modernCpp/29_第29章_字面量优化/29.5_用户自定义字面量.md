# 29.5 用户自定义字面量

在C++11标准中新引入了一个用户自定义字面量的概念，程序员可以通过自定义后缀将整数、浮点数、字符和字符串转化为特定的对象。这个特性往往用在需要大量声明某个类型对象的场景中，它能够减少一些重复类型的书写，避免代码冗余。一个典型的例子就是不同单位对象的互相操作，比如长度、重量、时间等，举个例子：

```txt
include<iostream>   
template<int scale, char ... unit_char>   
struct LengthUnit{ constexpr static int value  $=$  scale; constexpr static char unit_str[sizeof...(unit_char) + 1]  $=$  { unit_char,...,'\\0' \};   
}；   
template<class T>   
class LengthWithUnit{   
public: LengthWithUnit(）：length_unit_(0）{} LengthWithUnit(unsigned long long length)：length_unit_(length
```

```cpp
\*T::value）{} template<class U> LengthWithUnit<std::conditional_t<(T::value  $\rightharpoondown$  U::value)，U，T>> operator+(const LengthWithUnit<U>&rhs) { using unit_type  $=$  std::conditional_t<(T::value  $\rightharpoonup$  U::value) U，T>; returnLengthWithUnit<unit_type>(（length_unit_  $^+$  rhs.get_length()）/unit_type::value); } unsigned long long get_length() const{return length_unit;} constexpr static const char\*get_unit_str(){return T::unit_str;} private: unsigned long long length_unit_; template<class T> std::ostream& operator<< (std::ostream& out, const LengthWithUnit<T>&unit) { out<< unit.get_length() /T::value << LengthWithUnit<T::get_unit_str(); return out; } usingMMUnit  $=$  LengthUnit1,'m'，'m'>; using CMUnit  $=$  LengthUnit10，'c'，'m'>; using DMUnit  $=$  LengthUnit100，'d'，'m'>; using MUnit  $=$  LengthUnit1000，'m'>; using KMUnit  $=$  LengthUnit1000000，'k'，'m'>; usingLengthWithMMUnit  $=$  LengthWithUnit<MMUnit>; usingLengthWithCMUnit  $=$  LengthWithUnit<CMUnit>; usingLengthWithDMUnit  $=$  LengthWithUnit<DMUnit>; usingLengthWithMUnit  $=$  LengthWithUnit<MUnt>; usingLengthWithKMUnit  $=$  LengthWithUnit<KMUnit>; int main(） { auto total_length  $\equiv$  LengthWithCMUnit(1)+LengthWithMUnit(2)+ LengthWithMMUnit(4); std::cout<<total_length; }
```

上面的代码定义了两个类模板，一个是长度单位LengthUnit，另外一个是带单位的长度LengthWithUnit，然后基于这两个类模板生成了毫米、厘米、分米、米和千米单位类以及它们对应的带单位的长度类。为了不同单位的数据相加，我们在类模板LengthWithUnit中重载了加号运算符，函数中总是会将较大的单位转换到较小的单位进行求和，比如千米和厘米相加得到的结果单位为厘米。最后，我们在main函数中对不同单位的对象求和并且输出求和结果。类模板的编写用到了一些模板元编程的知识，我们暂时可以忽略它们，现在需要关注的是main函数里的代码。我们发现每增加一个求和的操作数就需要重复写一个类型LengthWithXXUnit，当操作数很多时候代码会变得很长，难以阅读和维护。当遇到这种情况的时候，我们可以考虑使用用户自定义字面量来简化代码，比如：

```c
LengthWithMMUnit operator ""_mm(unsigned long long length)  
{ return LengthWithMMUnit(length); }  
LengthWithCMUnit operator ""_cm(unsigned long long length)  
{ return LengthWithCMUnit(length); }  
LengthWithDMUnit operator ""_dm(unsigned long long length)  
{ return LengthWithDMUnit(length); }  
LengthWithMUnit operator ""_m(unsigned long long length)  
{ return LengthWithMUnit(length); }  
LengthWithKMUnit operator ""_km(unsigned long long length)  
{ return LengthWithKMUnit(length);
```

```cpp
}   
int main()   
{ auto total_length  $=$  1_cm  $^+$  2_m  $^+$  4_mm; std::cout<<total_length;
```

上面的代码定义了5个字面量运算符函数，这些函数返回不同单位的长度对象，分别对应于毫米、厘米、分米、米和千米。字面量运算符函数的函数名会作为后缀应用于字面量。在main函数中，我们可以看到现在的代码省略了LengthWithXXUnit的类型声明，取而代之的是一个整型的字面量紧跟着一个以下画线开头的后缀_cm、_m或者_mm。在这里编译器会根据字面量的后缀去查找对应的字面量运算符函数，并根据函数形式对字面量做相应处理后调用该函数，如果编译器没有找到任何对应的函数，则会报错。所以这里的1_cm、2_m和4_mm分别等于调用了LengthWithCM-Unit(1)、LengthWithMUnit(2)和LengthWithMMUnit(4)。

接下来让我们看一看字面量运算符函数的语法规则，字面量运算符函数的语法和其他运算符函数一样都是由返回类型、operator关键字、标识符以及函数形参组成的：

```python
retrun_type operator "" identifier (params)
```

值得注意的是在  $\mathrm{C} + + 11$  的标准中，双引号和紧跟的标识符中间必须有空格，不过这个规则在  $\mathrm{C} + + 14$  标准中被去除。在  $\mathrm{C} + + 14$  标准中，标识符不但可以紧跟在双引号后，而且还能使用  $\mathrm{C} + +$  的保留字作为标识符。标准中还建议用户定义的字面量运算符函数的标识符应该以下

画线开始，把没有下画线开始的标识符保留给标准库使用。虽然标准并没有强制规定自定义的字面量运算符函数标识符必须以下画线开始，但是我们还是应该尽量遵循标准的建议。这一点编译器也会提示我们，如果使用了非下画线开始的标识符，它会给出明确的警告信息。

上文曾提到，用户自定义字面量支持整数、浮点数、字符和字符串4种类型。虽然它们都通过字面量运算符函数来定义，但是对于不同的类型字面量运算符函数，语法在参数上有略微的区别。

对于整数字面量运算符函数有3种不同的形参类型 unsigned long long、const char *以及形参为空。其中 unsigned long long 和 const char *比较简单，编译器会将整数字面量转换为对应的无符号long long 类型或者常量字符串类型，然后将其作为参数传递给运算符函数。而对于无参数的情况则使用了模板参数，形如 operator "" identifier<char...c>()，这个稍微复杂一些，我们在后面的例子中详细介绍。

对于浮点数字面量运算符函数也有3种形参类型long double、const char *以及形参为空。和整数字面量运算符函数相比，除了将unsigned long long换成了long double，没有其他的区别。

对于字符串字面量运算符函数目前只有一种形参类型列表const char * str, size_t len。其中str为字符串字面量的具体内容，len是字符串字面量的长度。

对于字符字面量运算符函数也只有一种形参类型char，参数内容为字符字面量本身：

```cpp
include <string>   
unsigned long long operator ""_w1(unsigned long long n)   
{ return n;   
}   
const char \* operator ""_w2(const char \*str)   
{ return str;   
}   
unsigned long long operator ""_w3(long double n)   
{ return n;   
}   
std::string operator ""_w4(const char\* str,size_t len)   
{ return str;   
}   
char operator ""_w5(char n)   
{ return n;   
}   
unsigned long long operator ""if(unsigned long long n)   
{ return n;   
}   
int main()   
{ auto x1  $=$  123_w1; auto x2_1  $=$  123_w2; auto x2_2  $=$  12.3_w2; auto x3  $=$  12.3_w3; auto x4  $=$  "hello world"w4; auto x5  $=$  'a'w5; auto x6  $=$  123if;   
}
```

在上面的代码中，根据字面量运算符函数的语法规则，后缀_w1和_w2可以用于整数，后缀_w3和_w2可以用于浮点数，而_w4和_w5分别用于字符串和字符。请注意最后一个if后缀，它必须用支持C++14标准的编译器才能编译成功。这个后缀有两点比较特殊，首先它使用保留关键字if作为后缀，其次它没有用下画线开头。前者能够这么做是因为C++14标准中字面量运算符函数双引号后紧跟的标识符允许使用保留字，而对于后者支持C++11标准的编译器通常允许这么做，只是会给出警告。

最后来看一下字面量运算符函数使用模板参数的情况（关于可变参数模板的内容会在第35章详细介绍），在这种情况下函数本身没有任何形参，字面量的内容通过可变模板参数列表<char...>传到函数，例如：

```cpp
include <string>   
template <char...c> std::string operator ""_w()   
{ std::string str; //(str.push_back(c)，...）； //C++17的折叠表达式 using unused  $=$  int[]; unused{（str.push_back(c)，0）...}； return str;   
}   
int main()   
{ auto  $\mathrm{x} = 123\_ \mathrm{w}$  . auto  $\mathrm{y} = 12.3\_ \mathrm{w}$  ·
```

上面这段代码展示了一个使用可变参数模板的字面量运算符函数，该函数通过声明数组展开参数包的技巧将char类型的模板参数

push_back到str中。实际上，通常情况下很少会用到这种形式的字面量运算符函数，从易用性和可读性的角度来说它都不是一个好的选择，所以我建议还是采用上面提到的那些带有形参的字面量运算符函数。

