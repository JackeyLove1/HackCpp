# 37.1 允许常量求值作为所有非类型模板的实参

熟悉模板编程的读者应该知道，相对于以类型为模板参数的模板而言，以非类型为模板参数的模板实例化规则更加严格。在C++17标准之前，这些规则包括以下几种。

1. 如果整型作为模板实参，则必须是模板形参类型的经转换常量表达式。所谓经转换常量表达式是指隐式转换到某类型的常量表达式，特点是隐式转换和常量表达式。这一点很好理解，例如：

```c
constexpr char v = 42;   
constexpr char foo() { return 42; }   
template<int> struct X {};   
int main()   
{ X<v> x1; X<foo>> x2; }
```

在上面的代码中constexpr char到int的转换就满足隐式转换和常量表达式。

2. 如果对象指针作为模板实参，则必须是静态或者是有内部或者外部链接的完整对象。  
3. 如果函数指针作为模板实参，则必须是有链接的函数指针。  
4. 如果左值引用的形参作为模板实参，则必须也是有内部或者外部链接的。  
5. 而对于成员指针作为模板实参的情况，必须是静态成员。

请注意，以上提到的后4条规则都强调了两种特性：链接和静态。因为一旦代码满足了这些要求，就表明实参指引的内存地址固定了下来，对于编译器而言这是实例化模板的关键。比如：

```txt
template <const char *> struct Y {};
extern const char str1[] = "hello world"; // 外部链接
const char str2[] = "hello world"; // 内部链接
int main()
{
    Y<str1> y1;
    Y<str2> y2;
}
```

除了上面的规则以外，其他的实例化方式都是非法的，这其中也包括了一些合理场景，例如返回指针的常量表达式：

```c
int v = 42;  
constexpr int* foo() { return &v; }  
template const int*> struct X {};  
int main()  
{  
    X<foo> x;  
}
```

上面的代码在C++17之前是无法编译成功的，因为模板并不接受foo()的返回值类型，根据第一条规则它只会接受整型的经转换常量表达式。

在C++17标准中，C++委员会对这套规则做了重新的梳理，一方面简化规则的描述，另一方面也允许常量求值作为所有非类型模板的实参。新的标准只强调了一条规则：非类型模板形参使用的实参可以是该模板形参类型的任何经转换常量表达式。其中经转换常量表达式的定义添加了对象、数组、函数等到指针的转换。这从另一个角度对以前的规则进行了兼容。

在新规则的支持下，上面的代码可以编译成功，因为新规则不再强调经转换常量表达式的求值结果为整型。由于规则的修改，还带来了一个有趣的变化。仔细观察新规则会发现，现在对于指针不再要求是具有链接的，取而代之的是必须满足经转换常量表达式求值。这就是说，下面的代码可以顺利地编译通过：

```txt
template const char *> struct Y{};
int main()
{
    static const char str[] = "hello world";
    Y<str> y;
}
```

在C++17以前，上面的代码会编译失败，给出的错误提示为 &str，而不是一个有效的模板实参，因为str没有链接。不过C++17不存在上述问题，代码能够顺利地编译通过。

最后要强调的是，新规则并非万能，以下对象作为非类型模板实参依旧会造成编译器报错。

1. 对象的非静态成员对象。  
2. 临时对象。  
3. 字符串字面量。  
4. typeof的结果。  
5. 预定义变量。

