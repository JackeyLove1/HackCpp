# 37.2 允许局部和匿名类型作为模板实参

在C++11标准之前，将局部或匿名类型作为模板实参是不被允许的，但是这个限制并没有什么道理，所以在C++11标准中允许了这样的行为，让我们看一个提案文档中的例子：

```cpp
template<class T> class X{};  
template<class T> void f(T t){}  
struct{} unnamed_obj;  
int main()  
{  
    struct A{};  
    enum{e1};  
    typedef struct{} B;  
    B b;  
    X<A> x1; // C++11编译成功，C++03编译失败  
    X<A*> x2; // C++11编译成功，C++03编译失败  
    X<B> x3; // C++11编译成功，C++03编译失败  
    f(e1); // C++11编译成功，C++03编译失败  
    f(unnamed_obj); // C++11编译成功，C++03编译失败
```

```txt
f(b); // C++11编译成功，C++03编译失败}
```

在上面的代码中，由于结构体A和B都是局部类型，因此x1、x2和x3在C++11之前会编译失败。另外，因为e1、unnamed_obj的类型为匿名类型，所以f(e1)和f(unnamed_obj)在C++11之前也会编译失败。最后，由于b的类型是局部类型，因此f(b)在C++11之前同样无法编译成功。当然，在C++11上就没有以上的编译问题了。

