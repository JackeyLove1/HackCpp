# 37.6 扩展的模板参数匹配规则

一直以来，模板形参只能精确匹配实参列表，也就是说实参列表里的每一项必须和模板形参有着相同的类型。虽然这种匹配规则非常严谨且不易出错，但是却排除了很多合理的情况，比如：

```txt
template <template <typename> class T, class U> void foo()
{
    cout << "类型"
}
```

```cpp
$\mathrm{T} <   \mathrm{U}>$  n;   
}   
template<class, class  $=$  int> struct bar {};   
int main()   
{ foo<bar,double>();   
}
```

在上面的代码中，函数模板foo的模板形参列表接受一个模板实参，并且要求这个模板实参只有一个模板形参，巧的是类模板bar的模板形参列表中正好只有一个形参是需要指定的，而另外一个形参可以使用默认值。看起来foo<bar, double>()这种写法应该顺利地通过编译，但是事与愿违，这份代码在C++17之前是无法编译成功的。原因就是我们上文提到的：模板形参只能精确匹配实参列表，而这里类模板bar的模板形参数量与函数模板foo要求的模板实参的模板形参数量并不匹配，很明显这种匹配规则过于严苛了。

另外，由于在C++17中非类型模板形参可以使用auto作为占位符，因此我们可以写出这样的代码：

```cpp
template <template auto> class T, auto N> void foo()
{
    T<N> n;
}
template <auto> struct bar {}
int main()
{
    foo<bar, 5>();
```

在上面的代码中，类型占位符auto最终都会被推导为int类型，于是模板形参和模板实参列表是匹配的，编译起来没有问题。但是修

改一下函数模板foo，结果还是正确的吗？

```cpp
template <template <int> class T, int N> void foo()
{
    T<N> n;
}
```

从推导的角度来看，类模板bar的模板形参中类型占位符auto被推导为int，这样一来整个推导过程似乎是顺理成章的，但是从匹配规则的角度来看又违反了必须精确匹配的要求，所以为了让以auto占位符作为非类型模板形参这个特性使用得更为广泛，也是时候对模板参数的匹配规则进行一些扩展了。

在C++17标准中放宽了对模板参数的匹配规则，它要求模板形参至少和实参列表一样特化。换句话说，模板形参可以和实参列表精确匹配。另外，模板形参也可以比实参列表更加特化。在新的匹配规则下，让我们重新审视上面的代码。

很显然，函数模板foo的模板形参template <typename> class T相较于实参template<class, class = int> struct bar更加特化。而模板形参template<int> class T相较于template auto> struct bar也更加特化。这两份代码在 C++17中都可以顺利地编译成功。

