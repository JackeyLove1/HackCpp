# 37.3 允许函数模板的默认模板参数

在  $\mathrm{C}++11$  标准之前，与局部和匿名类型不能作为模板实参同样没有道理的还有函数模板不能有默认模板参数的规则。说这条规则没有道理，是因为类模板是可以有默认模板参数的，而函数模板却不能，但却找不到一条要这么限制函数模板的理由。正因如此，这条限制在  $\mathrm{C}++11$  标准中也被解除了。在  $\mathrm{C}++11$  中，我们可以自由地在函数模板中使用默认的模板参数，甚至在语法上比类模板更加灵活：

```txt
template<class T = double> void foo()
{
    T t;
}
int main()
{
    foo();
}
```

在上面的代码中，函数模板foo有一个默认的模板参数double，所以在main函数中直接调用foo不会造成编译失败。因为在没有指定

模板实参的时候它会使用默认的模板参数。值得注意的是，函数模板的默认模板参数是不会影响模板实参的推导的，也就是说推导出类型的优先级高于默认参数，比如：

```cpp
template<class T = double> void foo(T t) {}
int main()
{
    foo(5);
}
```

在上面的代码中，虽然函数模板foo的默认模板参数是double，但是由于函数模板会根据函数实参推导模板实参类型，而且其优先级高于默认模板参数，因此这里相当于调用了foo(int)函数。

最后要说的是，函数模板的默认模板参数要比类模板的默认模板参数以及函数的默认参数都要灵活。我们知道无论是函数的默认参数还是类模板的默认模板参数，都必须保证从右往左定义默认值，否则无法通过编译，例如：

```txt
template<class T = double, class U, class R = double> struct X {};
void foo(int a = 0, int b, double c = 1.0) {}
```

以上代码由于模板参数u和参数b没有指定默认参数，破坏了必须从右往左定义默认值的规则，因此会编译失败。而函数模板就没有这个问题了：

```txt
template<class T = double, class U, class R = double> void foo(U u) {}
```

```txt
int main() { foo(5); }
```

以上代码可以顺利地通过编译，其中T和R都有默认参数double，而U没有默认参数，不过U可以通过实参5推导出来。所以这里实际上调用的是foo<double，int，double>(int)函数。

