# 37.5 允许非类型模板形参中的字面量类类型

在C++20之前，非类型模板形参可以是整数类型、枚举类型、指针类型、引用类型和std::nullptr_t，但是类类型是无法作为非类型模板形参的，比如：

```txt
struct A{};  
template <A a>  
struct B{};  
A a;  
B<a> b; // 编译失败
```

不过从C++20开始，字面量类类型（literal class）可以作为形参在非类型模板形参列表中使用了。具体要求如下。

1. 所有基类和非静态数据成员都是公开且不可变的。  
2. 所有基类和非静态数据成员的类型是标量类型、左值引用或前者的（可能是多维）数组。

使用C++20的编译环境可以顺利编译上述代码，注意，到目前为止CLang还没有支持这项特性。

不知道读者是否曾经为非类型模板形参不能使用字符串字面量而感到遗憾呢？比如：

```txt
template <const char *>
struct X{};
X["hello"] x; // 编译失败
```

现在，我们可以利用字面量类类型以及其构造函数，让非类型模板形参间接地支持字符串字面量了，请看下面的代码：

```cpp
template<typename T, std::size_t N> struct basic_fixated_string
{
    constexpr basic_fixated_string(const T(&foo)[N + 1])
    {
        std::copy_n(foo, N + 1, data);
    }
    T data_[N + 1];
};
template<typename T, std::size_t N> 
basic_fixated_string(const T(&str)[N]) ->basic_fixated_string<T, N - 1>; 
template <basic_fixated_string Str> 
struct X {
    X() {
        std::cout << Str.data;
    }
}
```

```txt
}；  
X<"hello world">x;
```

以上代码是在提案文档的示例上稍作修改，其中basic_fixated_string是一个典型的字面量类类型，它的构造函数接受一个常量字符串数组并将该数组复制到数据成员m_data中，因为构造函数声明为constexpr，所以可以在编译期执行完毕。接下来，代码通过自定义推导指引（详情请见第39章）：

```cpp
template <typename CharT, std::size_t N> 
basic_fixated_string(const CharT(&str)[N]) ->basic_fixated_string<CharT, N - 1>;
```

明确编译器通过构造函数推导模板实参的方法。然后将basic_fixe_string作为模板形参加入类模板x的模板形参列表中，这样编译器编译x["hello world">x;的时候就会根据basic_fixe_string的构造函数将"hello world"复制到data_中。最终，代码在运行期执行x的构造函数，输出字符串hello world。

