# 37.4 函数模板添加到ADL查找规则

在C++20标准之前，ADL的查找规则是无法查找到带显式指定模板实参的函数模板的，比如：

```cpp
namespace N {
    struct A {};
    template<class T> int f(T) { return 1; }
}  
int x = f<N::A>(N::A());
```

MSVC会报错并提示找不到函数f，而GCC相对友好一些，它会报错并且询问是否要调用的是N::f。而CLang更加友好，它会编译成功，最后给出一条温馨的警告信息。

从C++20标准开始以上问题得以解决，编译器可以顺利地找到命名空间N中的函数f。不过需要注意的是，有些情况仍会让编译器报错，比如：

```txt
int h = 0;  
void g() {}  
namespace N {
```

```cpp
struct A{};  
template<class T> int f(T) { return 1; }  
template<class T> int g(T) { return 2; }  
template<class T> int h(T) { return 3; }  
}  
int x = f<N::A>(N::A()); // 编译成功，查找f没有找到任何定义，f被认为是模板  
int y = g<N::A>(N::A()); // 编译成功，查找g找到一个函数，g被认为是模板  
int z = h<N::A>(N::A()); // 编译失败
```

在上面的代码中f和g都编译成功，因为根据标准要求编译器查找f和g的结果分别是什么都没找到以及找到一个函数，在这种情况下可以猜测它们都是模板函数，并且尝试匹配到命名空间N的f和g两个函数模板。而h则不同，编译器可以找到一个int变量h，在这种情况下紧跟h之后的<可以被认为是小于号，不符合标准要求，所以编译器仍会报错。

