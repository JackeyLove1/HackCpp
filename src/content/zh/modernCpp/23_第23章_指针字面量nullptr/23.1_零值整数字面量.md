# 23.1 零值整数字面量

在C++标准中有一条特殊的规则，即0既是一个整型常量，又是一个空指针常量。0作为空指针常量还能隐式地转换为各种指针类型。比如我们在初始化变量的时候经常看到的代码：

```txt
char \*p  $=$  NULL; int  $\mathbf{x} = 0$
```

这里的NULL是一个宏，在C++11标准之前其本质就是0：

```c
ifndef NULL
		#ifdef __cplusplus
			#define NULL 0
		#else
			#define NULL ((void * 0)
			#endif
	#endif
```

在上面的代码中，C++将NULL定义为0，而C语言将NULL定义为(void *)0。之所以有所区别，是因为C++和C的标准定义不同，C++标准中定义空指针常量是评估为0的整数类型的常量表达式右值，而C标准中定义0为整型常量或者类型为void *的空指针常量。

使用0代表不同类型的特殊规则给C++带来了二义性，对C++的学习和使用造成了不小的麻烦，下面是C++标准文档的两个例子：

```cpp
//例子1  
void f(int)  
{ std::cout << "int" << std::endl; }  
void f(char*) { std::cout << "char*" << std::endl; }  
f(NULL);  
f(reinterpret_cast<char*>NULL);
```

在上面这段代码中f(NULL)函数调用的是f(int)函数，因为NULL会被优先解析为整数类型。没有办法让编译器自动识别传入NULL的意图，除非使用类型转换，将NULL转换到char*，f(reinterpret_cast<char *>(NULL))可以正确地调用f(char*)函数。注意，上面的代码可以在MSVC中编译执行。在GCC中，我们会得到一个NULL有二义性的错误提示。

下面这个例子看起来就更加奇怪了：

```cpp
//例子2  
std::string s1(false);  
std::string s2(true);
```

以上代码可以用MSVC编译，其中s1可以成功编译，但是s2则会编译失败。原因是false被隐式转换为0，而0又能作为空指针常量转换为const char * const，所以s1可以编译成功，true则没有这样的待遇。在GCC中，编译器对这种代码也进行了特殊处理，如果用C++11(-std=c++11)及其之后的标准来编译，则两条代码均会报

错。但是如果用C++03以及之前的标准来编译，则虽然第一句代码能编译通过，但会给出警告信息，第二句代码依然编译失败。

