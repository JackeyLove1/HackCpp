# 36.2 减少typename使用的必要性

我们知道当使用未决类型的内嵌类型时，例如X<T>:Y，需要使用typename明确告知编译器X<T>::Y是一个类型，否则编译器会将其当作一个表达式的名称，比如一个静态数据成员或者静态成员函数：

```txt
template<class T> void f(T::R);
```

```txt
template<class T> void f<typename T::R);
```

在C++20标准之前，只有两种情况例外，它们分别是指定基类和成员初始化，例如：

```txt
struct Impl {};  
struct Wrap { using B = Impl; };  
template<class T> struct D: T::B{ D(): T::B{} };  
D<Wrap> var;
```

在上面的代码中struct D : T::B和D() : T::B() {}都没有指定typename，但是编译器依然可以正确地识别程序意图。实际上，除了以上两种情况外，还有很多时候也可以从语义中明确地判断出X<T>::Y表示的是类型，比如使用using创建类型别名的时候，using R = typename T::B;中typename完全没有存在的必要。

在C++20标准中，增加了一些情况可以让我们省略typename关键字。

1. 在上下文仅可能是类型标识的情况，可以忽略typename。

static cast、const cast、reinterpret cast或dynamic cast等类型转换：

```txt
static cast<T::B>(p);
```

定义类型别名:

```txt
using R = T::B;
```

后置返回类型:

```txt
auto g() -> T::B;
```

模板类型形参的默认参数:

```cpp
template<class R = T::B> struct X;
```

2. 还有一些声明的情况也可以忽略typename。

全局或者命名空间中简单的声明或者函数的定义:

```txt
template<class T> T::R f();
```

结构体的成员:

```txt
template<class T> struct D: T::B {
    D(): T::B() {}
    T::B b; // 编译成功
};
```

作为成员函数或者lambda表达式形参声明:

```cpp
template<class T> struct D: T::B {
    D(): T::B() {}
    T::B f(T::B) { return T::B(); } // 编译成功
};
```

最后需要提出的是，到目前为止实现了这部分特性的编译器只有GCC而已，至于CLang和MSVC编译以上代码依然会报错，并且提示需要添加typename。

