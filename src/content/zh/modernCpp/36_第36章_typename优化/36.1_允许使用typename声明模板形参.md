# 36.1 允许使用typename声明模板形参

在C++17标准之前，必须使用class来声明模板形参，而 typename是不允许使用的，例如：

```txt
template <typename T> struct A{};
template <template <typename> class T> struct B{};
int main()
{
    B<A> ba;
}
```

上面的代码可以顺利地编译通过，但是如果将B的定义修改为 template <template <typename> typename T> struct B{}；，则可能会发生编译错误。具体情况要根据编译器厂商和版本而定，比如在GCC新版本中这种写法都是允许的，而CLang的新版本也只会给出一个警告，只有在它们的老版本中才会给出错误提示。总之，在C++17之前typename的这种写法是不符合标准的。

其实，这种严苛的规则在过去看来是顺理成章的。因为在过去，能作为模板形参的只有类模板，并没有其他可能性，所以规定必须使用class来声明模板形参是合情合理的。但是自从C++11标准诞生，随着别名模板的引入，类模板不再是模板形参的唯一选择了，例如：

```cpp
template <typename T> using A = int;
template <template <typename> class T> struct B{}; int main()
{
    B<A> ba;
}
```

可以看到，这里的A实际上就是int类型而不是一个类模板。很明显，现在已经没有必要强调必须使用class来声明模板形参了，删除这个规则可以让语言更加简单合理。所以在C++17标准中使用typename来声明模板形参已经不是问题了：

```txt
template <typename T> using A = int;
template <template <typename> typename T> struct B{};  
int main()
{
    B<A> ba;
}
```

