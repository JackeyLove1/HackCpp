# 1.1 整数类型long long

整型long long虽然是C++11才新加入标准的，但是我们似乎很早就开始使用这个类型了，这其中包含了一个有趣的故事。

long long这个类型早在1995年6月之前就由罗兰·哈丁格（Roland Hartinger）提出申请加入C++标准。但是当时的C++标准委员会以C语言中不存在这个基本类型为由，拒绝将这个类型加入C++中。而就在C++98标准出台的一年后，C99标准就添加了long long这个类型，并且流行的编译器也纷纷支持了该类型，这也就是我们很早就接触到long long的原因。在此之后C++标准委员会在C++11中才有计划将整型long long加入标准中。

我们知道long通常表示一个32位整型，而long long则是用来表示一个64位的整型。不得不说，这种命名方式简单粗暴。不仅写法冗余，而且表达的含义也并不清晰。如果按照这个命名规则，那么128位整型就该被命名为long long long了。但是不管怎么样，long long既然已经加入了C++11的标准，那么我们能做的就是适应它，并且希望不会有long long long这种类型的诞生。

C++标准中定义，long long是一个至少为64位的整数类型。请注意这里的用词“至少”，也就说long long的实际长度可能大于64位。不过我至今也没有看到大于64位长度的long long出现。另外，long long是一个有符号类型，对应的无符号类型为unsigned long long，当然读者可能看到过诸如long long int、unsigned long long int等类型，实际上它们和long long、unsigned long long具有相同的含义。C++标准还为其定义LL和ULL作为这两种类型的字面量后缀，所以在初始化long long类型变量的时候可以这么写：

```txt
long long  $\mathbf{x} = 65536\mathbb{L}\mathbb{L}$
```

当然，这里可以忽略LL这个字面量后缀，直接写成下面的形式也可以达到同样的效果：

```txt
long long  $\mathbf{x} = 65536$
```

要强调的是，字面量后缀并不是没有意义的，在某些场合下我们必须用到它才能让代码的逻辑正确，比如下面的代码：

```cpp
long long x1 = 65536 << 16; // 计算得到的x1值为0  
std::cout << "x1 = " << x1 << std::endl;  
long long x2 = 65536LL << 16; // 计算得到的x2值为4294967296（0x100000000）  
std::cout << "x2 = " << x2 << std::endl;
```

以上代码的目的是将65536左移16位，以获得一个更大的数值。但是，x1计算出来的值却是0，没有增大反而减小了。原因是在没有

字面量后缀的情况下，这里的65536被当作32位整型操作，在左移16位以后，这个32位整型的值变成了0，所以事实是将0赋值给了x1，于是我们看到x1输出的结果为0。而在计算x2的过程中，代码给65536添加了字面量后缀LL，这使编译器将其编译为一个64位整型，左移16位后仍然可以获得正确的结果：4294967296（0x100000000）。另外，有些编译器可能在编译long long x1 = 65536 << 16；的时候显示一些警告提示，而另一些编译器可能没有，无论如何我们必须在编写代码的时候足够小心，避免上面情况的发生。

和其他整型一样，long long也能运用于枚举类型和位域，例如：

```cpp
enumlonglong_enum:long long{x1,x2};   
structlonglong_struct{ longlongx1:8; longlongx2:24; longlongx3:32; };   
std::cout<<sizeof(longlong_enum::x1)  $<  <$  std::endl; //输出大小为8   
std::cout<<sizeof(longlong_struct)  $<  <$  std::endl; //输出大小为8
```

作为一个新的整型long long，C++标准必须为它配套地加入整型的大小限制。在头文件中增加了以下宏，分别代表long long的最大值和最小值以及unsigned long long的最大值：

```txt
define LLONG_MAX 9223372036854775807LL // long long的最大值
```

```txt
define LLONG_MIN(-9223372036854775807LL-1）//long long的最小值  
#define ULLONG_MAX 0xxxxxxxxxxxxxxuLL //unsigned longlong的最大值
```

在C++中应该尽量少使用宏，用模板取而代之是明智的选择。C++标准中对标准库头文件做了扩展，特化了long long和unsigned long long版本的numericLimits类模板。这使我们能够更便捷地获取这些类型的最大值和最小值，如下面的代码示例：

```cpp
include<iostream> #include <limits> #include <stdio> int main(int argc, char \*argv[]) { //使用宏方法 std::cout << "LLong_MAX = " << LLong_MAX << std::endl; std::cout << "LLong_MIN = " << LLong_MIN << std::endl; std::cout << "ULLONG_MAX = " << ULLONG_MAX << std::endl; //使用类模板方法 std::cout << "std::numeric_limitsinlong long:max()  $=$  " << std::numeric_limitsinlong long:max(）<< std::endl; std::cout << "std::numeric_limitsinlong long:max(min)  $=$  " << std::numeric_limitsinlong long:maxmin(）<< std::endl; std::cout << "std::numeric_limitsinunsigned long long:max(）=" << std::numeric_limitsinunsigned long long:max(）<< std::endl; //使用printf打印输出 std::printf("LLong_MAX=%lld\n",LLong_MAX); std::printf("LLong_MIN=%lld\n",LLong_MIN); std::printf("ULLONG_MAX=%llu\n",ULLONG_MAX); }
```

输出结果如下:

```txt
LLONG_MAX = 9223372036854775807  
LLONG_MIN = -9223372036854775808
```

```cpp
ULLONG_MAX = 18446744073709551615  
std::numeric限度长long::max() = 9223372036854775807  
std::numeric限度<long long::min() = -9223372036854775808  
std::numeric限度<unsigned long long::max() = 18446744073709551615  
LLONG_MAX = 9223372036854775807  
LLONG_MIN = -9223372036854775808  
ULLONG_MAX = 18446744073709551615
```

以上代码很容易理解，唯一需要说明的一点是，随着整型long long的加入，std::printf也加入了对其格式化打印的能力。新增的长度指示符11可以用来指明变量是一个long long类型，所以我们分别使用%1ld和%1lu来格式化有符号和无符号的long long整型了。当然，使用C++标准的流输入/输出是一个更好的选择。

