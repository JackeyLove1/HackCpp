# 32.2 特性测试宏

C++20标准添加了一组用于测试功能特性的宏，这组宏可以帮助我们测试当前的编译环境对各种功能特性的支持程度。

# 32.2.1 属性特性测试宏

属性测试宏（_has_cpp_attribute）可以指示编译环境是否支持某种属性，该属性可以是标准属性，也可以是编译环境厂商特有的属性。标准属性将被展开为该属性添加到标准时的年份和月份，而厂商特有的属性将被展开为一个非零的值：

```cpp
std::cout << __has_cpp_attribute(deprecated); // 输出结果如下：201309
```

上面这句代码会输出201309，代表该属性在2013年9月加入标准，并且被当前编译环境支持。当前的标准属性如表32-1所示。

▼表32-1  

<table><tr><td>属性</td><td>值</td></tr><tr><td>carries_capacity</td><td>200809L</td></tr><tr><td>deprecated</td><td>201309L</td></tr><tr><td>fallthrough</td><td>201603L</td></tr><tr><td>likely</td><td>201803L</td></tr><tr><td>maybe_unused</td><td>201603L</td></tr><tr><td>no_unique_address</td><td>201803L</td></tr><tr><td>nodiscard</td><td>201603L</td></tr><tr><td>noreturn</td><td>200809L</td></tr><tr><td>unlikely</td><td>201803L</td></tr></table>

# 32.2.2 语言功能特性测试宏

以下列表的宏代表编译环境所支持的语言功能特性，每个宏将被展开为该特性添加到标准时的年份和月份。请注意，这些宏展开的值会随着特性的变更而更新，如表32-2所示。

▼表32-2

<table><tr><td>宏</td><td>值</td></tr><tr><td>__cpp_aggregatebases</td><td>201603L</td></tr><tr><td>__cpp_aggregate_nsdmi</td><td>201304L</td></tr><tr><td>__cpp_aggregate_paren_init</td><td>201902L</td></tr><tr><td>__cpp alias templates</td><td>200704L</td></tr><tr><td>__cpp_aligned_new</td><td>201606L</td></tr><tr><td>__cpp_attributes</td><td>200809L</td></tr><tr><td>__cpp_binary_literals</td><td>201304L</td></tr><tr><td>__cpp)capture_star.this</td><td>201603L</td></tr><tr><td>__cpp_char8_t</td><td>201811L</td></tr><tr><td>__cpp_concepts</td><td>201907L</td></tr><tr><td>__cpp_conditional_explicit</td><td>201806L</td></tr><tr><td>__cpp_consteval</td><td>201811L</td></tr><tr><td>__cpp_constexpr</td><td>201907L</td></tr><tr><td>__cpp_constexpr_dynamic_alloc</td><td>201907L</td></tr><tr><td>__cpp_constexpr_in_decltype</td><td>201711L</td></tr><tr><td>__cpp_constinit</td><td>201907L</td></tr><tr><td>__cpp-coroutines</td><td>201902L</td></tr><tr><td>__cpp-decltype</td><td>200707L</td></tr><tr><td>__cpp-decltype-auto</td><td>201304L</td></tr><tr><td>__cpp_deduction-guides</td><td>201907L</td></tr><tr><td>__cpp delegating Constructors</td><td>200604L</td></tr><tr><td>__cpp-designated_initializer</td><td>201707L</td></tr><tr><td>__cpp enumerator_attributes</td><td>201411L</td></tr><tr><td>__cpp_foldExpressions</td><td>201603L</td></tr><tr><td>__cpp_generic_lambda</td><td>201707L</td></tr><tr><td>__cpp_guaranteed_copy_elision</td><td>201606L</td></tr><tr><td>__cpp_hex_float</td><td>201603L</td></tr><tr><td>__cpp_if_constexpr</td><td>201606L</td></tr><tr><td>__cpp Impl(coroutine</td><td>201902L</td></tr><tr><td>__cpp Impldestroying_delete</td><td>201806L</td></tr><tr><td>__cpp Impl_three_way比較</td><td>201907L</td></tr><tr><td>__cpp_inheriting_constructors</td><td>201511L</td></tr><tr><td>__cpp_init_captures</td><td>201803L</td></tr><tr><td>__cpp_initializerLists</td><td>200806L</td></tr><tr><td>__cpp在线Variables</td><td>201606L</td></tr><tr><td>__cpp_lambda</td><td>200907L</td></tr><tr><td>__cpp Modules</td><td>201907L</td></tr><tr><td>__cppnamespace_attributes</td><td>201411L</td></tr><tr><td>__cpp_noexcept_function_type</td><td>201510L</td></tr><tr><td>__cpp_nontype_template_args</td><td>201911L</td></tr><tr><td>__cpp_nontype_template_parameter_AUTO</td><td>201606L</td></tr><tr><td>__cpp_nsdmi</td><td>200809L</td></tr><tr><td>__cpp_range_based_for</td><td>201603L</td></tr><tr><td>__cpp_raw_strings</td><td>200710L</td></tr><tr><td>__cpp_ref_qualifiers</td><td>200710L</td></tr><tr><td>__cpp_return_type_deduction</td><td>201304L</td></tr><tr><td>__cpp_rvalue references</td><td>200610L</td></tr><tr><td>__cpp Sized_deallocation</td><td>201309L</td></tr><tr><td>__cppStatic_assert</td><td>200410L</td></tr><tr><td>__cpp_structured bindings</td><td>201606L</td></tr><tr><td>__cpp_template_template_args</td><td>201611L</td></tr><tr><td>__cpp_threadsafe-static_init</td><td>200806L</td></tr><tr><td>__cpp_unICODE Characters</td><td>200704L</td></tr><tr><td>__cpp_unicode_literals</td><td>200710L</td></tr><tr><td>__cpp_user_defined_literals</td><td>200809L</td></tr><tr><td>__cpp(using一团</td><td>201907L</td></tr><tr><td>__cpp_variable_template</td><td>201304L</td></tr><tr><td>__cpp_variadic Templates</td><td>200704L</td></tr><tr><td>__cpp_variadic-using</td><td>201611L</td></tr></table>

# 32.2.3 标准库功能特性测试宏

以下列表的宏代表编译环境所支持的标准库功能特性，它们通常包含在<version>头文件或者表中的任意对应头文件中。同样，每个宏将被展开为该特性添加到标准时的年份和月份。请注意，这些宏展开的值会随着特性的变更而更新，如表32-3所示。

▼表32-3  

<table><tr><td>宏</td><td>值</td><td>头文件</td></tr><tr><td>__cpp_lib_addressof_constexpr</td><td>201603L</td><td></td></tr><tr><td>__cpp_lib_allocator Traits_is_alwaysEQUAL</td><td>201411L</td><td></td></tr><tr><td>__cpp_lib_any</td><td>201606L</td><td></td></tr><tr><td>__cpp_lib_apply</td><td>201603L</td><td></td></tr><tr><td>__cpp_lib_array_constexpr</td><td>201811L</td><td></td></tr><tr><td>__cpp_lib_as_const</td><td>201510L</td><td></td></tr><tr><td>__cpp_libshipsaligned</td><td>201811L</td><td></td></tr><tr><td>__cpp_lib_atomic_flag_test</td><td>201907L</td><td></td></tr><tr><td>__cpp_lib_atomic_float</td><td>201711L</td><td></td></tr><tr><td>__cpp_lib_atomic_is_always_lock_free</td><td>201603L</td><td></td></tr><tr><td>__cpp_lib_atomic_lock_free_type_aliases</td><td>201907L</td><td></td></tr><tr><td>__cpp_lib_atomic_ref</td><td>201806L</td><td></td></tr><tr><td>__cpp_lib_atomic_shared_ptr</td><td>201711L</td><td></td></tr><tr><td>__cpp_lib_atomic_value_initializer</td><td>201911L</td><td></td></tr><tr><td>__cpp_lib_atomic_wait</td><td>201907L</td><td></td></tr><tr><td>__cpp_lib Barrier</td><td>201907L</td><td></td></tr><tr><td>__cpp_lib_bind_front</td><td>201907L</td><td></td></tr><tr><td>__cpp_lib_bit_cast</td><td>201806L</td><td></td></tr><tr><td>__cpp_lib_bitops</td><td>201907L</td><td></td></tr><tr><td>__cpp_lib(bool_constant</td><td>201505L</td><td></td></tr><tr><td>__cpp_lib_bounded_array Traits</td><td>201902L</td><td></td></tr><tr><td>__cpp_lib_boyer_moore_searcher</td><td>201603L</td><td></td></tr><tr><td>__cpp_lib_byte</td><td>201603L</td><td></td></tr><tr><td>__cpp_lib_char8_t</td><td>201907L</td><td></td></tr><tr><td>__cpp_lib chrono</td><td>201907L</td><td></td></tr><tr><td>__cpp_lib chrono.udls</td><td>201304L</td><td></td></tr><tr><td>__cpp_lib_clamp</td><td>201603L</td><td></td></tr><tr><td>__cpp_lib_complex.udls</td><td>201309L</td><td></td></tr><tr><td>__cpp_lib_concepts</td><td>202002L</td><td></td></tr><tr><td>__cpp_lib_constexpr Algorithms</td><td>201806L</td><td></td></tr><tr><td>__cpp_lib_constexpr_complex</td><td>201711L</td><td></td></tr><tr><td>__cpp_lib_constexprDynamic_alloc</td><td>201907L</td><td></td></tr><tr><td>__cpp_lib_constexpr_functional</td><td>201907L</td><td></td></tr><tr><td>__cpp_lib_constexprIterator</td><td>201811L</td><td></td></tr><tr><td>__cpp_lib_constexpr_memory</td><td>201811L</td><td></td></tr><tr><td>__cpp_lib_constexpr_numeric</td><td>201911L</td><td></td></tr><tr><td>__cpp_lib_constexpr_string</td><td>201907L</td><td></td></tr><tr><td>__cpp_lib_constexpr_string_view</td><td>201811L</td><td></td></tr><tr><td>__cpp_lib_constexpr_tuple</td><td>201811L</td><td></td></tr><tr><td>__cpp_lib_constexprutility</td><td>201811L</td><td></td></tr><tr><td>__cpp_lib_constexpr_vector</td><td>201907L</td><td></td></tr><tr><td>__cpp_lib-coroutine</td><td>201902L</td><td></td></tr><tr><td>__cpp_libdestroying_delete</td><td>201806L</td><td></td></tr><tr><td>__cpp_lib_enable_shared_from.this</td><td>201603L</td><td></td></tr><tr><td>__cpp_lib_endian</td><td>201907L</td><td></td></tr><tr><td>__cpp_lib_lease_if</td><td>202002L</td><td></td></tr><tr><td>__cpp_lib_exchange_function</td><td>201304L</td><td></td></tr><tr><td>__cpp_lib_execution</td><td>201902L</td><td></td></tr><tr><td>__cpp_lib_filesystem</td><td>201703L</td><td></td></tr><tr><td>__cpp_lib_format</td><td>201907L</td><td></td></tr><tr><td>__cpp_lib_gcd lcm</td><td>201606L</td><td></td></tr><tr><td>__cpp_lib.Generic_associative.lookup</td><td>201304L</td><td></td></tr><tr><td>__cpp_lib_generic_unorderedlookup</td><td>201811L</td><td></td></tr><tr><td>__cpp_lib_hardware_interference_size</td><td>201703L</td><td></td></tr><tr><td>__cpp_lib_has_unique_object Representations</td><td>201606L</td><td></td></tr><tr><td>__cpp_lib_hypot</td><td>201603L</td><td></td></tr><tr><td>__cpp_lib_incompletecontainer_elements</td><td>201505L</td><td></td></tr><tr><td>__cpp_lib_int.pow2</td><td>202002L</td><td></td></tr><tr><td>__cpp_lib_integer comparision-functions</td><td>202002L</td><td></td></tr><tr><td>__cpp_lib_integer_sequence</td><td>201304L</td><td></td></tr><tr><td>__cpp_lib_integral_constant_callable</td><td>201304L</td><td></td></tr><tr><td>__cpp_lib_interpolate</td><td>201902L</td><td></td></tr><tr><td>__cpp_lib.invoke</td><td>201411L</td><td></td></tr><tr><td>__cpp_lib_aggregate</td><td>201703L</td><td></td></tr><tr><td>__cpp_lib_is_constant Evaluated</td><td>201811L</td><td></td></tr><tr><td>__cpp_lib_is_final</td><td>201402L</td><td></td></tr><tr><td>__cpp_lib_is_invocable</td><td>201703L</td><td></td></tr><tr><td>__cpp_lib_is.layoutCompatible</td><td>201907L</td><td></td></tr><tr><td>__cpp_lib_is_nothrow.convertible</td><td>201806L</td><td></td></tr><tr><td>__cpp_lib_is_null_pointer</td><td>201309L</td><td></td></tr><tr><td>__cpp_lib_is_pointer_interconvertible</td><td>201907L</td><td></td></tr><tr><td>__cpp_lib_is_swappable</td><td>201603L</td><td></td></tr><tr><td>__cpp_lib_jthread</td><td>201911L</td><td>&lt;stop_token&gt;&lt;thread&gt;</td></tr><tr><td>__cpp_lib_latch</td><td>201907L</td><td>&lt; latch&gt;</td></tr><tr><td>__cpp_lib_laNunder</td><td>201606L</td><td>&lt; new&gt;</td></tr><tr><td>__cpp_lib_list_remove_return_type</td><td>201806L</td><td>&lt;forward_list&gt;&lt;list&gt;</td></tr><tr><td>__cpp_libLOGICAL Traits</td><td>201510L</td><td>&lt; type Traits&gt;</td></tr><tr><td>__cpp_lib.make_from_tuple</td><td>201606L</td><td>&lt; tuple&gt;</td></tr><tr><td>__cpp_lib.make_reverse_iterator</td><td>201402L</td><td>&lt;iterator&gt;</td></tr><tr><td>__cpp_lib.make_unique</td><td>201304L</td><td>&lt; memory&gt;</td></tr><tr><td>__cpp_lib_map_try_emplace</td><td>201411L</td><td>&lt; map&gt;</td></tr><tr><td>__cpp_lib mathConstants</td><td>201907L</td><td>&lt; numbers&gt;</td></tr><tr><td>__cpp_lib math_special-functions</td><td>201603L</td><td>&lt; cmath&gt;</td></tr><tr><td>__cpp_lib_memoryResource</td><td>201603L</td><td>&lt; memoryResource&gt;</td></tr><tr><td>cpp_lib_node Extract</td><td>201606L</td><td>&lt;map&gt;&lt;set&gt;&lt;unordered_map&gt;&lt;unordered_set&gt;</td></tr><tr><td>cpp_lib_nonmembercontainer_access</td><td>201411L</td><td>&lt;iterator&gt;&lt;array&gt;&lt;deque&gt;&lt;forward_list&gt;&lt;list&gt;&lt;map&gt;&lt;regex&gt;&lt;set&gt;&lt;string&gt;&lt;unordered_map&gt;&lt;unordered_set&gt;&lt;vector&gt;</td></tr><tr><td>cpp_lib_not_fn</td><td>201603L</td><td>&lt;functional&gt;</td></tr><tr><td>cpp_lib_nulliterators</td><td>201304L</td><td>&lt;iterator&gt;</td></tr><tr><td>cpp_lib_option</td><td>201606L</td><td>&lt;optional&gt;</td></tr><tr><td>cpp_lib_parallel_algorithm</td><td>201603L</td><td>&lt;algorithm&gt;&lt;numeric&gt;</td></tr><tr><td>cpp_lib_polymorphic_allocator</td><td>201902L</td><td>&lt;memory&gt;</td></tr><tr><td>cpp_lib_quoted_string_io</td><td>201304L</td><td>&lt;iomanip&gt;</td></tr><tr><td>__cpp_lib_ranges</td><td>201911L</td><td>&lt;algorithm&gt; &lt;functional&gt; &lt;iterator&gt; &lt;memory&gt; &lt;ranges&gt;</td></tr><tr><td>__cpp_lib_raw_memory_algorithms</td><td>201606L</td><td>&lt;memory&gt;</td></tr><tr><td>__cpp_lib_remove Cvref</td><td>201711L</td><td>&lt;type Traits&gt;</td></tr><tr><td>__cpp_lib_result_of_sfinae</td><td>201210L</td><td>&lt;type Traits&gt; &lt;functional&gt;</td></tr><tr><td>__cpp_lib_robust_nonmodifying_seqOps</td><td>201304L</td><td>&lt;algorithm&gt;</td></tr><tr><td>__cpp_lib_sample</td><td>201603L</td><td>&lt;algorithm&gt;</td></tr><tr><td>__cpp_lib_scoped_lock</td><td>201703L</td><td>&lt;mutex&gt;</td></tr><tr><td>__cpp_lib_semaphore</td><td>201907L</td><td>&lt;semaphore&gt;</td></tr><tr><td>__cpp_lib_shared_mutex</td><td>201505L</td><td>&lt;shared_mutex&gt;</td></tr><tr><td>__cpp_lib_shared_ptr_arrays</td><td>201707L</td><td>&lt;memory&gt;</td></tr><tr><td>__cpp_lib_shared_ptr_weak_type</td><td>201606L</td><td>&lt;memory&gt;</td></tr><tr><td>__cpp_lib_shared_timeed_mutex</td><td>201402L</td><td></td></tr><tr><td>__cpp_lib_shift</td><td>201806L</td><td></td></tr><tr><td>__cpp_libsmart_ptr_for_overwrite</td><td>201811L</td><td></td></tr><tr><td>__cpp_lib_source_location</td><td>201907L</td><td></td></tr><tr><td>__cpp_lib spans</td><td>202002L</td><td></td></tr><tr><td>__cpp_lib_ssize</td><td>201902L</td><td></td></tr><tr><td>__cpp_lib Starts Ends_with</td><td>201711L</td><td></td></tr><tr><td>__cpp_lib_string.udls</td><td>201304L</td><td></td></tr><tr><td>__cpp_lib_string_view</td><td>201803L</td><td></td></tr><tr><td>__cpp_lib_SYNCbuf</td><td>201803L</td><td></td></tr><tr><td>__cpp_lib_three_way比較 comparison</td><td>201907L</td><td></td></tr><tr><td>__cpp_lib_to_address</td><td>201711L</td><td></td></tr><tr><td>__cpp_lib_to_array</td><td>201907L</td><td></td></tr><tr><td>__cpp_lib_to chars</td><td>201611L</td><td></td></tr><tr><td>__cpp_lib_transformationtraits_aliases</td><td>201304L</td><td></td></tr><tr><td>__cpp_lib Transparent Operators</td><td>201510L</td><td></td></tr><tr><td>__cpp_lib_tuple_element_t</td><td>201402L</td><td></td></tr><tr><td>__cpp_lib_tuples_by_type</td><td>201304L</td><td></td></tr><tr><td>__cpp_lib_type_identity</td><td>201806L</td><td></td></tr><tr><td>__cpp_lib_typeTrait_variable_template</td><td>201510L</td><td></td></tr><tr><td>__cpp_lib_uncaughtExceptions</td><td>201411L</td><td></td></tr><tr><td>__cpp_lib_unordered_map_try_emplace</td><td>201411L</td><td></td></tr><tr><td>__cpp_lib_unwrap_ref</td><td>201811L</td><td></td></tr><tr><td>__cpp_libvariant</td><td>201606L</td><td></td></tr><tr><td>__cpp_lib_void_t</td><td>201411L</td><td>(type Traits&gt;</td></tr></table>

# 32.3 新增宏VA_OPT

从C99标准开始，C语言引入了可变参数宏__VA Arguments__，而顺理成章的C++11标准也将其纳入标准当中。__VA Arguments__常见的用法集中于打印日志上，例如：

```txt
define LOG(msg, ...) printf("[\"__FILE__":%d]" msg, _LINE_, _VA_args_)  
LOG("Hello %d", 2020);
```

LOG的使用和printf非常相似，并且可以很方便地将代码文件和行数记录到日志当中。不过它们也并非完全相同，因为对于函数printf来说，除了第一个参数以外的其他参数都是可选的：

```txt
printf("Hello 2020"); //编译成功
```

而对于LOG宏来说，这种写法是非法的：

```javascript
LOG("Hello 2020");
```

上面这句代码展开后应该是:

```javascript
printf("["FILE%d]"Hello2020",LINE,);
```

很明显，函数的最后多出了一个逗号，在GCC和CLang上编译都会报错。虽然在Visual Studio 2019上不会报错，但这并不具备通用性。实际上GCC和CLang也有类似扩展，只不过没有隐式地提供，我们可以使用##连接逗号和__VA Arguments：

```txt
define LOG(msg, ...) printf("[\"__FILE__%d]" msg, LINE_, #__VA Arguments)  
LOG("Hello 2020"); // GCC和CLang编译成功
```

为了用更加标准的方法解决以上问题，C++20标准引入了一个新的宏__VA_OPT__令可变参数宏更易于在可变参数为空的情况下使用。还是以刚刚的LOG为例，我们将代码修改为：

```python
define LOG(msg, ...) printf("[ " __FILE__ ':%d] " msg, _LINE__ _VA_OPT_(,) _VA_args_)
```

观察上面的代码可以发现，__LINE__后面的逗号被修改为__VA_OPT__(，)，这是告诉编译器这个逗号是可选的。当可变参数不为空的时候逗号才会被替换出来，否则就会忽略这个逗号。对于下面两句日志而言：

```matlab
LOG("Hello 2020");  
LOG("Hello %d", 2020);
```

由于第一句代码中没有可变参数，所以被忽略，替换结果如下：

```txt
printf("["FILE%D] "Hello 2020", LINE);
```

第二句代码中存在可变参数，所以被替换出来，最后结果如下：

```txt
printf("["FILE":"%d"] "Hello %d", LINE, 2020);
```

