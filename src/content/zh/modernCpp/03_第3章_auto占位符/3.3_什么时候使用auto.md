# 3.3 什么时候使用auto

合理使用auto，可以让程序员从复杂的类型编码中解放出来，不但可以少敲很多代码，也会大大提高代码的可读性。但是事情总是有它的两面性，如果滥用auto，则会让代码失去可读性，不仅让后来人难以理解，间隔时间长了可能自己写的代码也要研读很久才能弄明白其含义。所以，下面我们来探讨一下，如何合理地使用auto。这里再多说一句，每个人对auto的使用可能有不同的理解，我这里阐述的是自己认为最合适的使用场景。首先简单归纳auto的使用规则。

1. 当一眼就能看出声明变量的初始化类型的时候可以使用auto。  
2. 对于复杂的类型，例如lambda表达式、bind等直接使用auto。  
对于第一条规则，常见的是在容器的迭代器上使用，例如：

```cpp
std::map<std::string，int>str2int; //...填充str2int的代码 for(std::map<std::string，int>::const_iterator it  $=$  str2int.cbegin(); it  $! =$  str2int.cend(); ++it）{} //或者 for(std::pair<std std::string，int> &it：str2int）{}
```

上面的代码如果不用auto来声明迭代器，那么我们需要编写std::map <std::string, int>::const_iterator和std::pair<const std::string, int>来代替auto，而多出来的代码并不会增强代码的可读性，反而会让代码看起来冗余，因为通常我们一眼就能看明白it的具体类型。请注意，第二个for的it类型是std::pair<const std::string, int>，而不是std::pair<std::string, int>，如果写成后者是无法通过编译的。直接使用auto，可以避免上述问题：

```cpp
std::map<std::string, int> str2int;
// ... 填充str2int的代码
for (auto it = str2int.cbegin(); it != str2int.cend(); ++it) {}
// 或者
for (auto &it : str2int) {}
```

反过来说，如果使用auto声明变量，则会导致其他程序员阅读代码时需要翻阅初始化变量的具体类型，那么我们需要慎重考虑是否适合使用auto关键字。

对于第二条规则，我们有时候会遇到无法写出类型或者过于复杂的类型，或者即使能正确写出某些复杂类型，但是其他程序员阅读起来也很费劲，这种时候建议使用auto来声明，例如lambda表达式：

```javascript
auto l = []; (int a1, int a2) { return a1 + a2; };
```

这里1的类型可能是一个这样的名称xxx::

<lambda Efdefb7231ea076 22630c86251a36ed4>(不同的编译器命名方法会有所不同), 我们根本无法写出其类型, 只能用auto来声明。再例如:

```cpp
int sum(int a1, int a2) { return a1 + a2; } auto b = std::bind(sum, 5, std::placeholders::_1);
```

这里b的类型为std::_Binder<std::_Unforced,int(cdecl &) (int,int),int, const std::_Ph<1> &>, 绝大多数读者看到这种类型时会默契地选择使用auto来声明变量。

