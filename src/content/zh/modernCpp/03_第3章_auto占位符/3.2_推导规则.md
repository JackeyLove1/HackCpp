# 3.2 推导规则

1. 如果auto声明的变量是按值初始化，则推导出的类型会忽略cv限定符。进一步解释为，在使用auto声明变量时，既没有使用引用，也没有使用指针，那么编译器在推导的时候会忽略const和volatile限定符。当然auto本身也支持添加cv限定符：

```txt
const int i = 5;  
auto j = i; // auto推导类型为int，而非const int  
auto &m = i; // auto推导类型为const int，m推导类型为const int&  
auto *k = i; // auto推导类型为const int，k推导类型为const int*  
const auto n = j; // auto推导类型为int，n的类型为const int
```

根据规则1，在上面的代码中，虽然i是const int类型，但是因为按值初始化会忽略cv限定符，所以j的推导类型是int而不是const int。而m和k分别按引用和指针初始化，因此其cv属性保留了下来。另外，可以用const结合auto，让n的类型推导为const int。

2. 使用auto声明变量初始化时，目标对象如果是引用，则引用属性会被忽略：

```txt
int  $\mathrm{i} = 5$  int&j  $= \dot{\mathbf{i}}$  auto  $\textsf{m} = \textsf{j}$  //auto推导类型为int，而非int&
```

根据规则2，虽然j是i的引用，类型为int&，但是在推导m的时候会忽略其引用。

3. 使用auto和万能引用声明变量时（见第6章），对于左值会将 auto推导为引用类型：

```txt
int i = 5;  
auto&& m = i; // auto推导类型为int&（这里涉及引用折叠的概念）  
auto&& j = 5; // auto推导类型为int
```

根据规则3，因为i是一个左值，所以m的类型被推导为int&，auto被推导为int&，这其中用到了引用折叠的规则。而5是一个右值，因此j的类型被推导为int&&，auto被推导为int。

4. 使用auto声明变量，如果目标对象是一个数组或者函数，则auto会被推导为对应的指针类型：

```c
int i[5];   
auto m = i; // auto推导类型为int\*   
int sum(int a1, int a2)   
{ return a1+a2;   
}   
auto j = sum // auto推导类型为int (__cdecl \*) (int,int)
```

根据规则4，虽然i是数组类型，但是m会被推导退化为指针类型，同样，j也退化为函数指针类型。

5. 当auto关键字与列表初始化组合时，这里的规则有新老两个版本，这里只介绍新规则（C++17标准）。

（1）直接使用列表初始化，列表中必须为单元素，否则无法编译，auto类型被推导为单元素的类型。  
（2）用等号加列表初始化，列表中可以包含单个或者多个元素，auto类型被推导为std::initializer_list<T>，其中T是元素类型。请注意，在列表中包含多个元素的时候，元素的类型必须相同，否则编译器会报错。

```txt
auto x1 = { 1, 2 }; // x1类型为 std::initializer_list<int>  
auto x2 = { 1, 2.0 }; // 编译失败，花括号中元素类型不同  
auto x3{ 1, 2 }; // 编译失败，不是单个元素  
auto x4 = { 3 }; // x4类型为std::initializer_list<int>  
auto x5{ 3 }; // x5类型为int
```

在上面的代码中，x1根据规则5（2）被推导为std::initializer_list<T>，其中的元素都是int类型，所以x1被推导为std::initializer_list<int>。同样，x2也应该被推导为std::initializer_list<T>，但是显然两个元素类型不同，导致编译器无法确定T的类型，所以编译失败。根据规则5（1），x3包含多个元素，直接导致编译失败。x4和x1一样被推导为std::initializer_list<int>，x5被推导为单元素的类型int。

根据上面这些规则，读者可以思考下面的代码，auto会被推导成什么类型呢？

```cpp
class Base {
public:
    virtual void f()
    {
        std::cout << "Base::f" << std::endl;
    };
}；
class Derived : public Base {
public:
    virtual void f() override
    {
        std::cout << "Derived::f" << std::endl;
    };
}；
Base* d = new Derived();
auto b = *d;
b.f();
```

以上代码有Derived和Base之间的继承关系，并且Derived重写了Base的f函数。代码使用new创建了一个Derived对象，并赋值于基类的指针类型变量上。读者知道d->f()一定调用的是Derived

的f函数。但是b.f()调用的又是谁的f函数呢？实际上，由于auto b = *d这一句代码是按值赋值的，因此auto会直接推导为Base。代码自然会调用Base的复制构造函数，也就是说Derived被切割成了 Base，这里的b.f()最终调用Base的f函数。那么进一步发散，如果代码写的是auto &b = *d，结果又会如何呢？这个就交给读者自己验证了。

